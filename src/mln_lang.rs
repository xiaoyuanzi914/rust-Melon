use ::libc;
use ::c2rust_bitfields;
use core::arch::asm;
extern "C" {
    fn mln_string_dup(str: *mut mln_string_t) -> *mut mln_string_t;
    fn mln_string_pool_dup(
        pool: *mut mln_alloc_t,
        str: *mut mln_string_t,
    ) -> *mut mln_string_t;
    fn mln_string_strcmp(s1: *mut mln_string_t, s2: *mut mln_string_t) -> libc::c_int;
    fn access(__name: *const libc::c_char, __type: libc::c_int) -> libc::c_int;
    fn close(__fd: libc::c_int) -> libc::c_int;
    fn read(__fd: libc::c_int, __buf: *mut libc::c_void, __nbytes: size_t) -> ssize_t;
    fn gettimeofday(__tv: *mut timeval, __tz: *mut libc::c_void) -> libc::c_int;
    fn pthread_self() -> pthread_t;
    fn snprintf(
        _: *mut libc::c_char,
        _: libc::c_ulong,
        _: *const libc::c_char,
        _: ...
    ) -> libc::c_int;
    fn mln_rbtree_new(attr: *mut mln_rbtree_attr) -> *mut mln_rbtree_t;
    fn mln_rbtree_free(t: *mut mln_rbtree_t);
    fn mln_rbtree_insert(t: *mut mln_rbtree_t, node: *mut mln_rbtree_node_t);
    fn mln_rbtree_search(
        t: *mut mln_rbtree_t,
        key: *mut libc::c_void,
    ) -> *mut mln_rbtree_node_t;
    fn mln_rbtree_delete(t: *mut mln_rbtree_t, n: *mut mln_rbtree_node_t);
    fn mln_rbtree_node_new(
        t: *mut mln_rbtree_t,
        data: *mut libc::c_void,
    ) -> *mut mln_rbtree_node_t;
    fn mln_rbtree_node_free(t: *mut mln_rbtree_t, n: *mut mln_rbtree_node_t);
    fn mln_rbtree_iterate(
        t: *mut mln_rbtree_t,
        handler: rbtree_iterate_handler,
        udata: *mut libc::c_void,
    ) -> libc::c_int;
    fn memcpy(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memset(
        _: *mut libc::c_void,
        _: libc::c_int,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memcmp(
        _: *const libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> libc::c_int;
    fn strchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;
    fn strrchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;
    fn strlen(_: *const libc::c_char) -> libc::c_ulong;
    fn munmap(__addr: *mut libc::c_void, __len: size_t) -> libc::c_int;
    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;
    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;
    fn free(_: *mut libc::c_void);
    fn abort() -> !;
    fn getenv(__name: *const libc::c_char) -> *mut libc::c_char;
    fn mln_fileset_init(max_file: mln_size_t) -> *mut mln_fileset_t;
    fn mln_fileset_destroy(fs: *mut mln_fileset_t);
    fn mln_conf() -> *mut mln_conf_t;
    fn mln_lang_ast_file_open(file_path: *mut mln_string_t) -> libc::c_int;
    fn mln_lang_ast_parser_generate() -> *mut libc::c_void;
    fn mln_lang_ast_parser_destroy(data: *mut libc::c_void);
    fn mln_lang_ast_generate(
        pool: *mut mln_alloc_t,
        state_tbl: *mut libc::c_void,
        data: *mut mln_string_t,
        data_type: mln_u32_t,
    ) -> *mut libc::c_void;
    fn mln_lang_ast_free(ast: *mut libc::c_void);
    fn mln_gc_new(attr: *mut mln_gc_attr) -> *mut mln_gc_t;
    fn mln_gc_free(gc: *mut mln_gc_t);
    fn mln_gc_add(gc: *mut mln_gc_t, data: *mut libc::c_void) -> libc::c_int;
    fn mln_gc_suspect(gc: *mut mln_gc_t, data: *mut libc::c_void);
    fn mln_gc_collect_add(gc: *mut mln_gc_t, data: *mut libc::c_void);
    fn mln_gc_clean_add(gc: *mut mln_gc_t, data: *mut libc::c_void) -> libc::c_int;
    fn mln_gc_collect(gc: *mut mln_gc_t, root_data: *mut libc::c_void);
    fn mln_gc_remove(gc: *mut mln_gc_t, data: *mut libc::c_void, proc_gc: *mut mln_gc_t);
    fn mln_array_pool_init(
        arr: *mut mln_array_t,
        free_0: array_free,
        size: mln_size_t,
        nalloc: mln_size_t,
        pool: *mut libc::c_void,
        pool_alloc: array_pool_alloc_handler,
        pool_free: array_pool_free_handler,
    ) -> libc::c_int;
    fn mln_array_destroy(arr: *mut mln_array_t);
    fn mln_array_reset(arr: *mut mln_array_t);
    fn mln_array_push(arr: *mut mln_array_t) -> *mut libc::c_void;
    fn mln_array_pop(arr: *mut mln_array_t);
    fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> libc::c_int;
    fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
    fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
    fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> libc::c_int;
    fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
    fn fstat(__fd: libc::c_int, __buf: *mut stat) -> libc::c_int;
    fn _mln_sys_log(
        level: mln_log_level_t,
        file: *const libc::c_char,
        func: *const libc::c_char,
        line: libc::c_int,
        msg: *mut libc::c_char,
        _: ...
    );
    static mut mln_lang_int_oprs: mln_lang_method_t;
    static mut mln_lang_nil_oprs: mln_lang_method_t;
    static mut mln_lang_bool_oprs: mln_lang_method_t;
    static mut mln_lang_func_oprs: mln_lang_method_t;
    static mut mln_lang_obj_oprs: mln_lang_method_t;
    static mut mln_lang_real_oprs: mln_lang_method_t;
    static mut mln_lang_str_oprs: mln_lang_method_t;
    static mut mln_lang_array_oprs: mln_lang_method_t;
    fn mln_path_melang_dylib() -> *mut libc::c_char;
    fn dlsym(
        __handle: *mut libc::c_void,
        __name: *const libc::c_char,
    ) -> *mut libc::c_void;
    fn dlopen(__file: *const libc::c_char, __mode: libc::c_int) -> *mut libc::c_void;
    fn dlclose(__handle: *mut libc::c_void) -> libc::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1];
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __va_list_tag {
    pub gp_offset: libc::c_uint,
    pub fp_offset: libc::c_uint,
    pub overflow_arg_area: *mut libc::c_void,
    pub reg_save_area: *mut libc::c_void,
}
pub type __dev_t = libc::c_ulong;
pub type __uid_t = libc::c_uint;
pub type __gid_t = libc::c_uint;
pub type __ino_t = libc::c_ulong;
pub type __mode_t = libc::c_uint;
pub type __nlink_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __time_t = libc::c_long;
pub type __suseconds_t = libc::c_long;
pub type __blksize_t = libc::c_long;
pub type __blkcnt_t = libc::c_long;
pub type __ssize_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
pub type off_t = __off_t;
pub type ssize_t = __ssize_t;
pub type time_t = __time_t;
pub type size_t = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
pub type __pthread_list_t = __pthread_internal_list;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __pthread_mutex_s {
    pub __lock: libc::c_int,
    pub __count: libc::c_uint,
    pub __owner: libc::c_int,
    pub __nusers: libc::c_uint,
    pub __kind: libc::c_int,
    pub __spins: libc::c_short,
    pub __elision: libc::c_short,
    pub __list: __pthread_list_t,
}
pub type pthread_t = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub union pthread_mutexattr_t {
    pub __size: [libc::c_char; 4],
    pub __align: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [libc::c_char; 40],
    pub __align: libc::c_long,
}
pub type va_list = __builtin_va_list;
pub type mln_u8_t = libc::c_uchar;
pub type mln_s8_t = libc::c_char;
pub type mln_u32_t = libc::c_uint;
pub type mln_s32_t = libc::c_int;
pub type mln_u64_t = libc::c_ulong;
pub type mln_s64_t = libc::c_long;
pub type mln_s8ptr_t = *mut libc::c_char;
pub type mln_u8ptr_t = *mut libc::c_uchar;
pub type mln_size_t = size_t;
pub type mln_off_t = off_t;
pub type mln_uptr_t = libc::c_ulong;
pub type mln_sauto_t = libc::c_long;
pub type mln_uauto_t = libc::c_ulong;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct mln_rbtree_node_s {
    pub data: *mut libc::c_void,
    pub prev: *mut mln_rbtree_node_s,
    pub next: *mut mln_rbtree_node_s,
    pub parent: *mut mln_rbtree_node_s,
    pub left: *mut mln_rbtree_node_s,
    pub right: *mut mln_rbtree_node_s,
    #[bitfield(name = "nofree", ty = "mln_u32_t", bits = "0..=0")]
    #[bitfield(name = "color", ty = "mln_u32_t", bits = "1..=31")]
    pub nofree_color: [u8; 4],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 4],
}
pub type mln_rbtree_node_t = mln_rbtree_node_s;
pub type rbtree_cmp = Option::<
    unsafe extern "C" fn(*const libc::c_void, *const libc::c_void) -> libc::c_int,
>;
pub type rbtree_free_data = Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>;
pub type rbtree_iterate_handler = Option::<
    unsafe extern "C" fn(*mut mln_rbtree_node_t, *mut libc::c_void) -> libc::c_int,
>;
pub type rbtree_pool_alloc_handler = Option::<
    unsafe extern "C" fn(*mut libc::c_void, mln_size_t) -> *mut libc::c_void,
>;
pub type rbtree_pool_free_handler = Option::<
    unsafe extern "C" fn(*mut libc::c_void) -> (),
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_rbtree_attr {
    pub pool: *mut libc::c_void,
    pub pool_alloc: rbtree_pool_alloc_handler,
    pub pool_free: rbtree_pool_free_handler,
    pub cmp: rbtree_cmp,
    pub data_free: rbtree_free_data,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct rbtree_s {
    pub pool: *mut libc::c_void,
    pub pool_alloc: rbtree_pool_alloc_handler,
    pub pool_free: rbtree_pool_free_handler,
    pub cmp: rbtree_cmp,
    pub data_free: rbtree_free_data,
    pub nil: mln_rbtree_node_t,
    pub root: *mut mln_rbtree_node_t,
    pub min: *mut mln_rbtree_node_t,
    pub head: *mut mln_rbtree_node_t,
    pub tail: *mut mln_rbtree_node_t,
    pub iter: *mut mln_rbtree_node_t,
    pub nr_node: mln_uauto_t,
    #[bitfield(name = "del", ty = "mln_u32_t", bits = "0..=0")]
    pub del: [u8; 1],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 7],
}
pub type mln_rbtree_t = rbtree_s;
pub type fheap_cmp = Option::<
    unsafe extern "C" fn(*const libc::c_void, *const libc::c_void) -> libc::c_int,
>;
pub type fheap_copy = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *mut libc::c_void) -> (),
>;
pub type fheap_key_free = Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>;
pub type fheap_pool_alloc_handler = Option::<
    unsafe extern "C" fn(*mut libc::c_void, mln_size_t) -> *mut libc::c_void,
>;
pub type fheap_pool_free_handler = Option::<
    unsafe extern "C" fn(*mut libc::c_void) -> (),
>;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct mln_fheap_node_s {
    pub key: *mut libc::c_void,
    pub parent: *mut mln_fheap_node_s,
    pub child: *mut mln_fheap_node_s,
    pub left: *mut mln_fheap_node_s,
    pub right: *mut mln_fheap_node_s,
    pub degree: mln_size_t,
    #[bitfield(name = "nofree", ty = "mln_u32_t", bits = "0..=0")]
    #[bitfield(name = "mark", ty = "mln_u32_t", bits = "1..=31")]
    pub nofree_mark: [u8; 4],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 4],
}
pub type mln_fheap_node_t = mln_fheap_node_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_fheap_t {
    pub root_list: *mut mln_fheap_node_t,
    pub min: *mut mln_fheap_node_t,
    pub cmp: fheap_cmp,
    pub copy: fheap_copy,
    pub key_free: fheap_key_free,
    pub num: mln_size_t,
    pub min_val: *mut libc::c_void,
    pub pool: *mut libc::c_void,
    pub pool_alloc: fheap_pool_alloc_handler,
    pub pool_free: fheap_pool_free_handler,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct mln_event_s {
    pub fd_lock: pthread_mutex_t,
    pub timer_lock: pthread_mutex_t,
    pub cb_lock: pthread_mutex_t,
    pub callback: dispatch_callback,
    pub callback_data: *mut libc::c_void,
    #[bitfield(name = "is_break", ty = "mln_u32_t", bits = "0..=0")]
    #[bitfield(name = "padding", ty = "mln_u32_t", bits = "1..=31")]
    pub is_break_padding: [u8; 4],
    pub epollfd: libc::c_int,
    pub unusedfd: libc::c_int,
    pub ev_fd_tree: *mut mln_rbtree_t,
    pub ev_fd_wait_head: *mut mln_event_desc_t,
    pub ev_fd_wait_tail: *mut mln_event_desc_t,
    pub ev_fd_active_head: *mut mln_event_desc_t,
    pub ev_fd_active_tail: *mut mln_event_desc_t,
    pub ev_fd_timeout_heap: *mut mln_fheap_t,
    pub ev_timer_heap: *mut mln_fheap_t,
}
pub type mln_event_desc_t = mln_event_desc_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_event_desc_s {
    pub prev: *mut mln_event_desc_s,
    pub next: *mut mln_event_desc_s,
    pub act_prev: *mut mln_event_desc_s,
    pub act_next: *mut mln_event_desc_s,
    pub type_0: mln_event_type,
    pub flag: mln_u32_t,
    pub data: C2RustUnnamed,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed {
    pub tm: mln_event_tm_t,
    pub fd: mln_event_fd_t,
}
pub type mln_event_fd_t = mln_event_fd_s;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct mln_event_fd_s {
    pub fd: libc::c_int,
    pub active_flag: mln_u32_t,
    #[bitfield(name = "in_process", ty = "mln_u32_t", bits = "0..=0")]
    #[bitfield(name = "is_clear", ty = "mln_u32_t", bits = "1..=1")]
    #[bitfield(name = "in_active", ty = "mln_u32_t", bits = "2..=2")]
    #[bitfield(name = "rd_oneshot", ty = "mln_u32_t", bits = "3..=3")]
    #[bitfield(name = "wr_oneshot", ty = "mln_u32_t", bits = "4..=4")]
    #[bitfield(name = "err_oneshot", ty = "mln_u32_t", bits = "5..=5")]
    #[bitfield(name = "padding", ty = "mln_u32_t", bits = "6..=31")]
    pub in_process_is_clear_in_active_rd_oneshot_wr_oneshot_err_oneshot_padding: [u8; 4],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 4],
    pub rcv_data: *mut libc::c_void,
    pub rcv_handler: ev_fd_handler,
    pub snd_data: *mut libc::c_void,
    pub snd_handler: ev_fd_handler,
    pub err_data: *mut libc::c_void,
    pub err_handler: ev_fd_handler,
    pub timeout_data: *mut libc::c_void,
    pub timeout_handler: ev_fd_handler,
    pub timeout_node: *mut mln_fheap_node_t,
    pub end_us: mln_u64_t,
}
pub type ev_fd_handler = Option::<
    unsafe extern "C" fn(*mut mln_event_t, libc::c_int, *mut libc::c_void) -> (),
>;
pub type mln_event_t = mln_event_s;
pub type mln_event_tm_t = mln_event_tm_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_event_tm_s {
    pub data: *mut libc::c_void,
    pub handler: ev_tm_handler,
    pub end_tm: mln_uauto_t,
}
pub type ev_tm_handler = Option::<
    unsafe extern "C" fn(*mut mln_event_t, *mut libc::c_void) -> (),
>;
pub type mln_event_type = libc::c_uint;
pub const M_EV_TM: mln_event_type = 1;
pub const M_EV_FD: mln_event_type = 0;
pub type dispatch_callback = Option::<
    unsafe extern "C" fn(*mut mln_event_t, *mut libc::c_void) -> (),
>;
pub type stack_free = Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>;
pub type stack_copy = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *mut libc::c_void) -> *mut libc::c_void,
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_stack_node_s {
    pub data: *mut libc::c_void,
    pub prev: *mut mln_stack_node_s,
    pub next: *mut mln_stack_node_s,
}
pub type mln_stack_node_t = mln_stack_node_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_stack_t {
    pub bottom: *mut mln_stack_node_t,
    pub top: *mut mln_stack_node_t,
    pub free_head: *mut mln_stack_node_t,
    pub free_tail: *mut mln_stack_node_t,
    pub nr_node: mln_uauto_t,
    pub free_handler: stack_free,
    pub copy_handler: stack_copy,
}
pub type mln_alloc_shm_lock_cb_t = Option::<
    unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int,
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_alloc_s {
    pub mem: *mut libc::c_void,
    pub shm_size: mln_size_t,
    pub locker: *mut libc::c_void,
    pub lock: mln_alloc_shm_lock_cb_t,
    pub unlock: mln_alloc_shm_lock_cb_t,
    pub parent: *mut mln_alloc_s,
    pub mgr_tbl: [mln_alloc_mgr_t; 35],
    pub large_used_head: *mut mln_alloc_chunk_t,
    pub large_used_tail: *mut mln_alloc_chunk_t,
    pub shm_head: *mut mln_alloc_shm_t,
    pub shm_tail: *mut mln_alloc_shm_t,
}
pub type mln_alloc_shm_t = mln_alloc_shm_s;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct mln_alloc_shm_s {
    pub prev: *mut mln_alloc_shm_s,
    pub next: *mut mln_alloc_shm_s,
    pub pool: *mut mln_alloc_t,
    pub addr: *mut libc::c_void,
    pub size: mln_size_t,
    pub nfree: mln_u32_t,
    #[bitfield(name = "base", ty = "mln_u32_t", bits = "0..=30")]
    #[bitfield(name = "large", ty = "mln_u32_t", bits = "31..=31")]
    pub base_large: [u8; 4],
    pub bitmap: [mln_u8_t; 4096],
}
pub type mln_alloc_t = mln_alloc_s;
pub type mln_alloc_chunk_t = mln_alloc_chunk_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_alloc_chunk_s {
    pub prev: *mut mln_alloc_chunk_s,
    pub next: *mut mln_alloc_chunk_s,
    pub refer: mln_size_t,
    pub count: mln_size_t,
    pub mgr: *mut mln_alloc_mgr_t,
    pub blks: [*mut mln_alloc_blk_t; 5],
}
pub type mln_alloc_blk_t = mln_alloc_blk_s;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct mln_alloc_blk_s {
    pub prev: *mut mln_alloc_blk_s,
    pub next: *mut mln_alloc_blk_s,
    pub pool: *mut mln_alloc_t,
    pub data: *mut libc::c_void,
    pub chunk: *mut mln_alloc_chunk_t,
    pub blk_size: mln_size_t,
    #[bitfield(name = "is_large", ty = "mln_size_t", bits = "0..=0")]
    #[bitfield(name = "in_used", ty = "mln_size_t", bits = "1..=1")]
    #[bitfield(name = "padding", ty = "mln_size_t", bits = "2..=31")]
    pub is_large_in_used_padding: [u8; 4],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 4],
}
pub type mln_alloc_mgr_t = mln_alloc_mgr_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_alloc_mgr_s {
    pub blk_size: mln_size_t,
    pub free_head: *mut mln_alloc_blk_t,
    pub free_tail: *mut mln_alloc_blk_t,
    pub used_head: *mut mln_alloc_blk_t,
    pub used_tail: *mut mln_alloc_blk_t,
    pub chunk_head: *mut mln_alloc_chunk_t,
    pub chunk_tail: *mut mln_alloc_chunk_t,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct mln_string_t {
    pub data: mln_u8ptr_t,
    pub len: mln_u64_t,
    #[bitfield(name = "data_ref", ty = "mln_uauto_t", bits = "0..=0")]
    #[bitfield(name = "pool", ty = "mln_uauto_t", bits = "1..=1")]
    #[bitfield(name = "ref_0", ty = "mln_uauto_t", bits = "2..=31")]
    pub data_ref_pool_ref_0: [u8; 4],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 4],
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct mln_lex_s {
    pub pool: *mut mln_alloc_t,
    pub macros: *mut mln_rbtree_t,
    pub cur: *mut mln_lex_input_t,
    pub stack: *mut mln_stack_t,
    pub hooks: mln_lex_hooks_t,
    pub keywords: *mut mln_rbtree_t,
    pub err_msg: mln_s8ptr_t,
    pub result_buf: mln_u8ptr_t,
    pub result_pos: mln_u8ptr_t,
    pub result_buf_len: mln_u64_t,
    pub line: mln_u64_t,
    pub error: mln_s32_t,
    #[bitfield(name = "preprocess", ty = "mln_u32_t", bits = "0..=0")]
    #[bitfield(name = "ignore", ty = "mln_u32_t", bits = "1..=1")]
    pub preprocess_ignore: [u8; 1],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 3],
    pub env: *mut mln_string_t,
    pub preprocess_data: *mut mln_lex_preprocess_data_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lex_preprocess_data_t {
    pub if_level: mln_u64_t,
    pub if_matched: mln_u64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lex_hooks_t {
    pub excl_handler: lex_hook,
    pub excl_data: *mut libc::c_void,
    pub dblq_handler: lex_hook,
    pub dblq_data: *mut libc::c_void,
    pub nums_handler: lex_hook,
    pub nums_data: *mut libc::c_void,
    pub doll_handler: lex_hook,
    pub doll_data: *mut libc::c_void,
    pub perc_handler: lex_hook,
    pub perc_data: *mut libc::c_void,
    pub amp_handler: lex_hook,
    pub amp_data: *mut libc::c_void,
    pub sglq_handler: lex_hook,
    pub slgq_data: *mut libc::c_void,
    pub lpar_handler: lex_hook,
    pub lpar_data: *mut libc::c_void,
    pub rpar_handler: lex_hook,
    pub rpar_data: *mut libc::c_void,
    pub ast_handler: lex_hook,
    pub ast_data: *mut libc::c_void,
    pub plus_handler: lex_hook,
    pub plus_data: *mut libc::c_void,
    pub comma_handler: lex_hook,
    pub comma_data: *mut libc::c_void,
    pub sub_handler: lex_hook,
    pub sub_data: *mut libc::c_void,
    pub period_handler: lex_hook,
    pub period_data: *mut libc::c_void,
    pub slash_handler: lex_hook,
    pub slash_data: *mut libc::c_void,
    pub colon_handler: lex_hook,
    pub colon_data: *mut libc::c_void,
    pub semic_handler: lex_hook,
    pub semic_data: *mut libc::c_void,
    pub lagl_handler: lex_hook,
    pub lagl_data: *mut libc::c_void,
    pub equal_handler: lex_hook,
    pub equal_data: *mut libc::c_void,
    pub ragl_handler: lex_hook,
    pub ragl_data: *mut libc::c_void,
    pub ques_handler: lex_hook,
    pub ques_data: *mut libc::c_void,
    pub at_handler: lex_hook,
    pub at_data: *mut libc::c_void,
    pub lsquar_handler: lex_hook,
    pub lsquar_data: *mut libc::c_void,
    pub bslash_handler: lex_hook,
    pub bslash_data: *mut libc::c_void,
    pub rsquar_handler: lex_hook,
    pub rsquar_data: *mut libc::c_void,
    pub xor_handler: lex_hook,
    pub xor_data: *mut libc::c_void,
    pub under_handler: lex_hook,
    pub under_data: *mut libc::c_void,
    pub fulstp_handler: lex_hook,
    pub fulstp_data: *mut libc::c_void,
    pub lbrace_handler: lex_hook,
    pub lbrace_data: *mut libc::c_void,
    pub vertl_handler: lex_hook,
    pub vertl_data: *mut libc::c_void,
    pub rbrace_handler: lex_hook,
    pub rbrace_data: *mut libc::c_void,
    pub dash_handler: lex_hook,
    pub dash_data: *mut libc::c_void,
}
pub type lex_hook = Option::<
    unsafe extern "C" fn(*mut mln_lex_t, *mut libc::c_void) -> *mut libc::c_void,
>;
pub type mln_lex_t = mln_lex_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lex_input_t {
    pub type_0: mln_u32_t,
    pub fd: libc::c_int,
    pub data: *mut mln_string_t,
    pub dir: *mut mln_string_t,
    pub buf: mln_u8ptr_t,
    pub pos: mln_u8ptr_t,
    pub buf_len: mln_u64_t,
    pub line: mln_u64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_fileset_s {
    pub pool: *mut mln_alloc_t,
    pub reg_file_tree: *mut mln_rbtree_t,
    pub reg_free_head: *mut mln_file_t,
    pub reg_free_tail: *mut mln_file_t,
    pub max_file: mln_size_t,
}
pub type mln_file_t = mln_file_s;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct mln_file_s {
    pub prev: *mut mln_file_s,
    pub next: *mut mln_file_s,
    pub fd: libc::c_int,
    #[bitfield(name = "is_tmp", ty = "mln_u32_t", bits = "0..=0")]
    pub is_tmp: [u8; 1],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 3],
    pub file_path: *mut mln_string_t,
    pub fset: *mut mln_fileset_t,
    pub node: *mut mln_rbtree_node_t,
    pub refer_cnt: size_t,
    pub size: size_t,
    pub mtime: time_t,
    pub ctime: time_t,
    pub atime: time_t,
}
pub type mln_fileset_t = mln_fileset_s;
pub type ipc_handler = Option::<
    unsafe extern "C" fn(
        *mut mln_event_t,
        *mut libc::c_void,
        *mut libc::c_void,
        mln_u32_t,
        *mut *mut libc::c_void,
    ) -> (),
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_ipc_cb_s {
    pub next: *mut mln_ipc_cb_s,
    pub prev: *mut mln_ipc_cb_s,
    pub master_handler: ipc_handler,
    pub worker_handler: ipc_handler,
    pub master_data: *mut libc::c_void,
    pub worker_data: *mut libc::c_void,
    pub type_0: mln_u32_t,
}
pub type mln_ipc_cb_t = mln_ipc_cb_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_conf_item_s {
    pub type_0: mln_conf_item_type_t,
    pub val: C2RustUnnamed_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_0 {
    pub s: *mut mln_string_t,
    pub c: mln_s8_t,
    pub b: mln_u8_t,
    pub i: mln_sauto_t,
    pub f: libc::c_float,
}
pub type mln_conf_item_type_t = libc::c_uint;
pub const CONF_FLOAT: mln_conf_item_type_t = 5;
pub const CONF_INT: mln_conf_item_type_t = 4;
pub const CONF_BOOL: mln_conf_item_type_t = 3;
pub const CONF_CHAR: mln_conf_item_type_t = 2;
pub const CONF_STR: mln_conf_item_type_t = 1;
pub const CONF_NONE: mln_conf_item_type_t = 0;
pub type mln_conf_item_t = mln_conf_item_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_conf_domain_s {
    pub search: mln_conf_cmd_cb_t,
    pub insert: mln_conf_cmd_cb_t,
    pub remove: mln_conf_cmd_cb_t,
    pub domain_name: *mut mln_string_t,
    pub cmd: *mut mln_rbtree_t,
}
pub type mln_conf_cmd_cb_t = Option::<
    unsafe extern "C" fn(
        *mut mln_conf_domain_t,
        *mut libc::c_char,
    ) -> *mut mln_conf_cmd_t,
>;
pub type mln_conf_domain_t = mln_conf_domain_s;
pub type mln_conf_cmd_t = mln_conf_cmd_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_conf_cmd_s {
    pub cmd_name: *mut mln_string_t,
    pub search: mln_conf_item_cb_t,
    pub update: mln_conf_item_update_cb_t,
    pub arg_tbl: *mut mln_conf_item_t,
    pub n_args: mln_u32_t,
}
pub type mln_conf_item_update_cb_t = Option::<
    unsafe extern "C" fn(
        *mut mln_conf_cmd_t,
        *mut mln_conf_item_t,
        mln_u32_t,
    ) -> libc::c_int,
>;
pub type mln_conf_item_cb_t = Option::<
    unsafe extern "C" fn(*mut mln_conf_cmd_t, mln_u32_t) -> *mut mln_conf_item_t,
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_conf_s {
    pub lex: *mut mln_lex_t,
    pub domain: *mut mln_rbtree_t,
    pub search: mln_conf_domain_cb_t,
    pub insert: mln_conf_domain_cb_t,
    pub remove: mln_conf_domain_cb_t,
    pub cb: *mut mln_ipc_cb_t,
}
pub type mln_conf_domain_cb_t = Option::<
    unsafe extern "C" fn(*mut mln_conf_t, *mut libc::c_char) -> *mut mln_conf_domain_t,
>;
pub type mln_conf_t = mln_conf_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_stm_s {
    pub file: *mut mln_string_t,
    pub line: mln_u64_t,
    pub type_0: mln_lang_stm_type_t,
    pub data: C2RustUnnamed_1,
    pub next: *mut mln_lang_stm_s,
    pub jump: *mut libc::c_void,
    pub jump_type: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_1 {
    pub block: *mut mln_lang_block_t,
    pub func: *mut mln_lang_funcdef_t,
    pub setdef: *mut mln_lang_set_t,
    pub sw: *mut mln_lang_switch_t,
    pub w: *mut mln_lang_while_t,
    pub f: *mut mln_lang_for_t,
    pub pos: *mut mln_string_t,
}
pub type mln_lang_for_t = mln_lang_for_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_for_s {
    pub file: *mut mln_string_t,
    pub line: mln_u64_t,
    pub init_exp: *mut mln_lang_exp_t,
    pub condition: *mut mln_lang_exp_t,
    pub mod_exp: *mut mln_lang_exp_t,
    pub blockstm: *mut mln_lang_block_t,
}
pub type mln_lang_block_t = mln_lang_block_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_block_s {
    pub file: *mut mln_string_t,
    pub line: mln_u64_t,
    pub type_0: mln_lang_block_type_t,
    pub data: C2RustUnnamed_2,
    pub jump: *mut libc::c_void,
    pub jump_type: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_2 {
    pub exp: *mut mln_lang_exp_t,
    pub stm: *mut mln_lang_stm_t,
    pub pos: *mut mln_string_t,
    pub i: *mut mln_lang_if_t,
}
pub type mln_lang_if_t = mln_lang_if_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_if_s {
    pub file: *mut mln_string_t,
    pub line: mln_u64_t,
    pub condition: *mut mln_lang_exp_t,
    pub blockstm: *mut mln_lang_block_t,
    pub elsestm: *mut mln_lang_block_t,
}
pub type mln_lang_exp_t = mln_lang_exp_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_exp_s {
    pub file: *mut mln_string_t,
    pub line: mln_u64_t,
    pub assign: *mut mln_lang_assign_t,
    pub next: *mut mln_lang_exp_t,
    pub jump: *mut libc::c_void,
    pub type_0: libc::c_int,
}
pub type mln_lang_assign_t = mln_lang_assign_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_assign_s {
    pub file: *mut mln_string_t,
    pub line: mln_u64_t,
    pub left: *mut mln_lang_logiclow_t,
    pub op: mln_lang_assign_op_t,
    pub right: *mut mln_lang_assign_t,
    pub jump: *mut libc::c_void,
    pub type_0: libc::c_int,
}
pub type mln_lang_assign_op_t = mln_lang_assign_op_e;
pub type mln_lang_assign_op_e = libc::c_uint;
pub const M_ASSIGN_MODEQ: mln_lang_assign_op_e = 11;
pub const M_ASSIGN_XOREQ: mln_lang_assign_op_e = 10;
pub const M_ASSIGN_ANDEQ: mln_lang_assign_op_e = 9;
pub const M_ASSIGN_OREQ: mln_lang_assign_op_e = 8;
pub const M_ASSIGN_DIVEQ: mln_lang_assign_op_e = 7;
pub const M_ASSIGN_MULEQ: mln_lang_assign_op_e = 6;
pub const M_ASSIGN_RMOVEQ: mln_lang_assign_op_e = 5;
pub const M_ASSIGN_LMOVEQ: mln_lang_assign_op_e = 4;
pub const M_ASSIGN_SUBEQ: mln_lang_assign_op_e = 3;
pub const M_ASSIGN_PLUSEQ: mln_lang_assign_op_e = 2;
pub const M_ASSIGN_EQUAL: mln_lang_assign_op_e = 1;
pub const M_ASSIGN_NONE: mln_lang_assign_op_e = 0;
pub type mln_lang_logiclow_t = mln_lang_logiclow_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_logiclow_s {
    pub file: *mut mln_string_t,
    pub line: mln_u64_t,
    pub left: *mut mln_lang_logichigh_t,
    pub op: mln_lang_logiclow_op_t,
    pub right: *mut mln_lang_logiclow_t,
    pub jump: *mut libc::c_void,
    pub type_0: libc::c_int,
}
pub type mln_lang_logiclow_op_t = mln_lang_logiclow_op_e;
pub type mln_lang_logiclow_op_e = libc::c_uint;
pub const M_LOGICLOW_AND: mln_lang_logiclow_op_e = 2;
pub const M_LOGICLOW_OR: mln_lang_logiclow_op_e = 1;
pub const M_LOGICLOW_NONE: mln_lang_logiclow_op_e = 0;
pub type mln_lang_logichigh_t = mln_lang_logichigh_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_logichigh_s {
    pub file: *mut mln_string_t,
    pub line: mln_u64_t,
    pub left: *mut mln_lang_relativelow_t,
    pub op: mln_lang_logichigh_op_t,
    pub right: *mut mln_lang_logichigh_t,
    pub jump: *mut libc::c_void,
    pub type_0: libc::c_int,
}
pub type mln_lang_logichigh_op_t = mln_lang_logichigh_op_e;
pub type mln_lang_logichigh_op_e = libc::c_uint;
pub const M_LOGICHIGH_XOR: mln_lang_logichigh_op_e = 3;
pub const M_LOGICHIGH_AND: mln_lang_logichigh_op_e = 2;
pub const M_LOGICHIGH_OR: mln_lang_logichigh_op_e = 1;
pub const M_LOGICHIGH_NONE: mln_lang_logichigh_op_e = 0;
pub type mln_lang_relativelow_t = mln_lang_relativelow_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_relativelow_s {
    pub file: *mut mln_string_t,
    pub line: mln_u64_t,
    pub left: *mut mln_lang_relativehigh_t,
    pub op: mln_lang_relativelow_op_t,
    pub right: *mut mln_lang_relativelow_t,
    pub jump: *mut libc::c_void,
    pub type_0: libc::c_int,
}
pub type mln_lang_relativelow_op_t = mln_lang_relativelow_op_e;
pub type mln_lang_relativelow_op_e = libc::c_uint;
pub const M_RELATIVELOW_NEQUAL: mln_lang_relativelow_op_e = 2;
pub const M_RELATIVELOW_EQUAL: mln_lang_relativelow_op_e = 1;
pub const M_RELATIVELOW_NONE: mln_lang_relativelow_op_e = 0;
pub type mln_lang_relativehigh_t = mln_lang_relativehigh_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_relativehigh_s {
    pub file: *mut mln_string_t,
    pub line: mln_u64_t,
    pub left: *mut mln_lang_move_t,
    pub op: mln_lang_relativehigh_op_t,
    pub right: *mut mln_lang_relativehigh_t,
    pub jump: *mut libc::c_void,
    pub type_0: libc::c_int,
}
pub type mln_lang_relativehigh_op_t = mln_lang_relativehigh_op_e;
pub type mln_lang_relativehigh_op_e = libc::c_uint;
pub const M_RELATIVEHIGH_GREATEREQ: mln_lang_relativehigh_op_e = 4;
pub const M_RELATIVEHIGH_GREATER: mln_lang_relativehigh_op_e = 3;
pub const M_RELATIVEHIGH_LESSEQ: mln_lang_relativehigh_op_e = 2;
pub const M_RELATIVEHIGH_LESS: mln_lang_relativehigh_op_e = 1;
pub const M_RELATIVEHIGH_NONE: mln_lang_relativehigh_op_e = 0;
pub type mln_lang_move_t = mln_lang_move_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_move_s {
    pub file: *mut mln_string_t,
    pub line: mln_u64_t,
    pub left: *mut mln_lang_addsub_t,
    pub op: mln_lang_move_op_t,
    pub right: *mut mln_lang_move_t,
    pub jump: *mut libc::c_void,
    pub type_0: libc::c_int,
}
pub type mln_lang_move_op_t = mln_lang_move_op_e;
pub type mln_lang_move_op_e = libc::c_uint;
pub const M_MOVE_RMOVE: mln_lang_move_op_e = 2;
pub const M_MOVE_LMOVE: mln_lang_move_op_e = 1;
pub const M_MOVE_NONE: mln_lang_move_op_e = 0;
pub type mln_lang_addsub_t = mln_lang_addsub_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_addsub_s {
    pub file: *mut mln_string_t,
    pub line: mln_u64_t,
    pub left: *mut mln_lang_muldiv_t,
    pub op: mln_lang_addsub_op_t,
    pub right: *mut mln_lang_addsub_t,
    pub jump: *mut libc::c_void,
    pub type_0: libc::c_int,
}
pub type mln_lang_addsub_op_t = mln_lang_addsub_op_e;
pub type mln_lang_addsub_op_e = libc::c_uint;
pub const M_ADDSUB_SUB: mln_lang_addsub_op_e = 2;
pub const M_ADDSUB_PLUS: mln_lang_addsub_op_e = 1;
pub const M_ADDSUB_NONE: mln_lang_addsub_op_e = 0;
pub type mln_lang_muldiv_t = mln_lang_muldiv_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_muldiv_s {
    pub file: *mut mln_string_t,
    pub line: mln_u64_t,
    pub left: *mut mln_lang_not_t,
    pub op: mln_lang_muldiv_op_t,
    pub right: *mut mln_lang_muldiv_t,
    pub jump: *mut libc::c_void,
    pub type_0: libc::c_int,
}
pub type mln_lang_muldiv_op_t = mln_lang_muldiv_op_e;
pub type mln_lang_muldiv_op_e = libc::c_uint;
pub const M_MULDIV_MOD: mln_lang_muldiv_op_e = 3;
pub const M_MULDIV_DIV: mln_lang_muldiv_op_e = 2;
pub const M_MULDIV_MUL: mln_lang_muldiv_op_e = 1;
pub const M_MULDIV_NONE: mln_lang_muldiv_op_e = 0;
pub type mln_lang_not_t = mln_lang_not_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_not_s {
    pub file: *mut mln_string_t,
    pub line: mln_u64_t,
    pub op: mln_lang_not_op_t,
    pub right: C2RustUnnamed_3,
    pub jump: *mut libc::c_void,
    pub type_0: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_3 {
    pub not: *mut mln_lang_not_t,
    pub suffix: *mut mln_lang_suffix_t,
}
pub type mln_lang_suffix_t = mln_lang_suffix_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_suffix_s {
    pub file: *mut mln_string_t,
    pub line: mln_u64_t,
    pub left: *mut mln_lang_locate_t,
    pub op: mln_lang_suffix_op_t,
    pub jump: *mut libc::c_void,
    pub type_0: libc::c_int,
}
pub type mln_lang_suffix_op_t = mln_lang_suffix_op_e;
pub type mln_lang_suffix_op_e = libc::c_uint;
pub const M_SUFFIX_DEC: mln_lang_suffix_op_e = 2;
pub const M_SUFFIX_INC: mln_lang_suffix_op_e = 1;
pub const M_SUFFIX_NONE: mln_lang_suffix_op_e = 0;
pub type mln_lang_locate_t = mln_lang_locate_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_locate_s {
    pub file: *mut mln_string_t,
    pub line: mln_u64_t,
    pub left: *mut mln_lang_spec_t,
    pub op: mln_lang_locate_op_t,
    pub right: C2RustUnnamed_4,
    pub next: *mut mln_lang_locate_t,
    pub jump: *mut libc::c_void,
    pub type_0: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_4 {
    pub exp: *mut mln_lang_exp_t,
    pub id: *mut mln_string_t,
}
pub type mln_lang_locate_op_t = mln_lang_locate_op_e;
pub type mln_lang_locate_op_e = libc::c_uint;
pub const M_LOCATE_FUNC: mln_lang_locate_op_e = 3;
pub const M_LOCATE_PROPERTY: mln_lang_locate_op_e = 2;
pub const M_LOCATE_INDEX: mln_lang_locate_op_e = 1;
pub const M_LOCATE_NONE: mln_lang_locate_op_e = 0;
pub type mln_lang_spec_t = mln_lang_spec_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_spec_s {
    pub file: *mut mln_string_t,
    pub line: mln_u64_t,
    pub op: mln_lang_spec_op_t,
    pub data: C2RustUnnamed_5,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_5 {
    pub exp: *mut mln_lang_exp_t,
    pub factor: *mut mln_lang_factor_t,
    pub spec: *mut mln_lang_spec_t,
    pub set_name: *mut mln_string_t,
}
pub type mln_lang_factor_t = mln_lang_factor_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_factor_s {
    pub file: *mut mln_string_t,
    pub line: mln_u64_t,
    pub type_0: mln_lang_factor_type_t,
    pub data: C2RustUnnamed_6,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_6 {
    pub b: mln_u8_t,
    pub ptr: *mut mln_u8ptr_t,
    pub s_id: *mut mln_string_t,
    pub i: mln_s64_t,
    pub f: libc::c_double,
    pub array: *mut mln_lang_elemlist_t,
}
pub type mln_lang_elemlist_t = mln_lang_elemlist_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_elemlist_s {
    pub file: *mut mln_string_t,
    pub line: mln_u64_t,
    pub key: *mut mln_lang_assign_t,
    pub val: *mut mln_lang_assign_t,
    pub next: *mut mln_lang_elemlist_t,
}
pub type mln_lang_factor_type_t = libc::c_uint;
pub const M_FACTOR_NIL: mln_lang_factor_type_t = 6;
pub const M_FACTOR_ID: mln_lang_factor_type_t = 5;
pub const M_FACTOR_ARRAY: mln_lang_factor_type_t = 4;
pub const M_FACTOR_REAL: mln_lang_factor_type_t = 3;
pub const M_FACTOR_INT: mln_lang_factor_type_t = 2;
pub const M_FACTOR_STRING: mln_lang_factor_type_t = 1;
pub const M_FACTOR_BOOL: mln_lang_factor_type_t = 0;
pub type mln_lang_spec_op_t = mln_lang_spec_op_e;
pub type mln_lang_spec_op_e = libc::c_uint;
pub const M_SPEC_FACTOR: mln_lang_spec_op_e = 7;
pub const M_SPEC_PARENTH: mln_lang_spec_op_e = 6;
pub const M_SPEC_NEW: mln_lang_spec_op_e = 5;
pub const M_SPEC_DEC: mln_lang_spec_op_e = 4;
pub const M_SPEC_INC: mln_lang_spec_op_e = 3;
pub const M_SPEC_REFER: mln_lang_spec_op_e = 2;
pub const M_SPEC_REVERSE: mln_lang_spec_op_e = 1;
pub const M_SPEC_NEGATIVE: mln_lang_spec_op_e = 0;
pub type mln_lang_not_op_t = mln_lang_not_op_e;
pub type mln_lang_not_op_e = libc::c_uint;
pub const M_NOT_NOT: mln_lang_not_op_e = 1;
pub const M_NOT_NONE: mln_lang_not_op_e = 0;
pub type mln_lang_stm_t = mln_lang_stm_s;
pub type mln_lang_block_type_t = libc::c_uint;
pub const M_BLOCK_IF: mln_lang_block_type_t = 6;
pub const M_BLOCK_GOTO: mln_lang_block_type_t = 5;
pub const M_BLOCK_RETURN: mln_lang_block_type_t = 4;
pub const M_BLOCK_BREAK: mln_lang_block_type_t = 3;
pub const M_BLOCK_CONTINUE: mln_lang_block_type_t = 2;
pub const M_BLOCK_STM: mln_lang_block_type_t = 1;
pub const M_BLOCK_EXP: mln_lang_block_type_t = 0;
pub type mln_lang_while_t = mln_lang_while_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_while_s {
    pub file: *mut mln_string_t,
    pub line: mln_u64_t,
    pub condition: *mut mln_lang_exp_t,
    pub blockstm: *mut mln_lang_block_t,
}
pub type mln_lang_switch_t = mln_lang_switch_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_switch_s {
    pub file: *mut mln_string_t,
    pub line: mln_u64_t,
    pub condition: *mut mln_lang_exp_t,
    pub switchstm: *mut mln_lang_switchstm_t,
}
pub type mln_lang_switchstm_t = mln_lang_switchstm_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_switchstm_s {
    pub file: *mut mln_string_t,
    pub line: mln_u64_t,
    pub factor: *mut mln_lang_factor_t,
    pub stm: *mut mln_lang_stm_t,
    pub next: *mut mln_lang_switchstm_t,
}
pub type mln_lang_set_t = mln_lang_set_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_set_s {
    pub file: *mut mln_string_t,
    pub line: mln_u64_t,
    pub name: *mut mln_string_t,
    pub stm: *mut mln_lang_setstm_t,
}
pub type mln_lang_setstm_t = mln_lang_setstm_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_setstm_s {
    pub file: *mut mln_string_t,
    pub line: mln_u64_t,
    pub type_0: mln_lang_setstm_type_t,
    pub data: C2RustUnnamed_7,
    pub next: *mut mln_lang_setstm_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_7 {
    pub var: *mut mln_string_t,
    pub func: *mut mln_lang_funcdef_t,
}
pub type mln_lang_funcdef_t = mln_lang_funcdef_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_funcdef_s {
    pub file: *mut mln_string_t,
    pub line: mln_u64_t,
    pub name: *mut mln_string_t,
    pub args: *mut mln_lang_exp_t,
    pub stm: *mut mln_lang_stm_t,
    pub closure: *mut mln_lang_exp_t,
}
pub type mln_lang_setstm_type_t = libc::c_uint;
pub const M_SETSTM_FUNC: mln_lang_setstm_type_t = 1;
pub const M_SETSTM_VAR: mln_lang_setstm_type_t = 0;
pub type mln_lang_stm_type_t = libc::c_uint;
pub const M_STM_FOR: mln_lang_stm_type_t = 6;
pub const M_STM_WHILE: mln_lang_stm_type_t = 5;
pub const M_STM_SWITCH: mln_lang_stm_type_t = 4;
pub const M_STM_LABEL: mln_lang_stm_type_t = 3;
pub const M_STM_SET: mln_lang_stm_type_t = 2;
pub const M_STM_FUNC: mln_lang_stm_type_t = 1;
pub const M_STM_BLOCK: mln_lang_stm_type_t = 0;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct mln_gc_s {
    pub pool: *mut mln_alloc_t,
    pub item_head: *mut mln_gc_item_t,
    pub item_tail: *mut mln_gc_item_t,
    pub proc_head: *mut mln_gc_item_t,
    pub proc_tail: *mut mln_gc_item_t,
    pub iter: *mut mln_gc_item_t,
    pub item_getter: gc_item_getter,
    pub item_setter: gc_item_setter,
    pub item_freer: gc_item_freer,
    pub member_setter: gc_member_setter,
    pub move_handler: gc_move_handler,
    pub root_setter: gc_root_setter,
    pub clean_searcher: gc_clean_searcher,
    pub free_handler: gc_free_handler,
    #[bitfield(name = "del", ty = "mln_u32_t", bits = "0..=0")]
    pub del: [u8; 1],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 7],
}
pub type gc_free_handler = Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>;
pub type gc_clean_searcher = Option::<
    unsafe extern "C" fn(*mut mln_gc_t, *mut libc::c_void) -> (),
>;
pub type mln_gc_t = mln_gc_s;
pub type gc_root_setter = Option::<
    unsafe extern "C" fn(*mut mln_gc_t, *mut libc::c_void) -> (),
>;
pub type gc_move_handler = Option::<
    unsafe extern "C" fn(*mut mln_gc_t, *mut libc::c_void) -> (),
>;
pub type gc_member_setter = Option::<
    unsafe extern "C" fn(*mut mln_gc_t, *mut libc::c_void) -> (),
>;
pub type gc_item_freer = Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>;
pub type gc_item_setter = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *mut libc::c_void) -> (),
>;
pub type gc_item_getter = Option::<
    unsafe extern "C" fn(*mut libc::c_void) -> *mut libc::c_void,
>;
pub type mln_gc_item_t = mln_gc_item_s;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct mln_gc_item_s {
    pub gc: *mut mln_gc_t,
    pub data: *mut libc::c_void,
    pub prev: *mut mln_gc_item_s,
    pub next: *mut mln_gc_item_s,
    pub proc_prev: *mut mln_gc_item_s,
    pub proc_next: *mut mln_gc_item_s,
    #[bitfield(name = "suspected", ty = "mln_u32_t", bits = "0..=0")]
    #[bitfield(name = "credit", ty = "mln_u32_t", bits = "1..=1")]
    #[bitfield(name = "inc", ty = "mln_u32_t", bits = "2..=2")]
    #[bitfield(name = "visited", ty = "mln_u32_t", bits = "3..=3")]
    pub suspected_credit_inc_visited: [u8; 1],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 7],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_gc_attr {
    pub pool: *mut mln_alloc_t,
    pub item_getter: gc_item_getter,
    pub item_setter: gc_item_setter,
    pub item_freer: gc_item_freer,
    pub member_setter: gc_member_setter,
    pub move_handler: gc_move_handler,
    pub root_setter: gc_root_setter,
    pub clean_searcher: gc_clean_searcher,
    pub free_handler: gc_free_handler,
}
pub type array_pool_alloc_handler = Option::<
    unsafe extern "C" fn(*mut libc::c_void, mln_size_t) -> *mut libc::c_void,
>;
pub type array_pool_free_handler = Option::<
    unsafe extern "C" fn(*mut libc::c_void) -> (),
>;
pub type array_free = Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_array_t {
    pub elts: *mut libc::c_void,
    pub size: mln_size_t,
    pub nalloc: mln_size_t,
    pub nelts: mln_size_t,
    pub pool: *mut libc::c_void,
    pub pool_alloc: array_pool_alloc_handler,
    pub pool_free: array_pool_free_handler,
    pub free: array_free,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_funccall_val_s {
    pub name: *mut mln_string_t,
    pub prototype: *mut mln_lang_func_detail_t,
    pub object: *mut mln_lang_val_t,
    pub args: mln_array_t,
}
pub type mln_lang_val_t = mln_lang_val_s;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct mln_lang_val_s {
    pub prev: *mut mln_lang_val_s,
    pub next: *mut mln_lang_val_s,
    pub data: C2RustUnnamed_11,
    pub type_0: mln_s32_t,
    pub ref_0: mln_u32_t,
    pub udata: *mut mln_lang_val_t,
    pub func: *mut mln_lang_func_detail_t,
    #[bitfield(name = "not_modify", ty = "mln_u32_t", bits = "0..=0")]
    pub not_modify: [u8; 1],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 7],
}
pub type mln_lang_func_detail_t = mln_lang_func_detail_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_func_detail_s {
    pub exp: *mut mln_lang_exp_t,
    pub args: mln_array_t,
    pub closure: mln_array_t,
    pub type_0: mln_lang_func_type_t,
    pub data: C2RustUnnamed_8,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_8 {
    pub process: mln_lang_internal,
    pub stm: *mut mln_lang_stm_t,
}
pub type mln_lang_internal = Option::<
    unsafe extern "C" fn(*mut mln_lang_ctx_t) -> *mut mln_lang_var_t,
>;
pub type mln_lang_ctx_t = mln_lang_ctx_s;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct mln_lang_ctx_s {
    pub lang: *mut mln_lang_t,
    pub pool: *mut mln_alloc_t,
    pub fset: *mut mln_fileset_t,
    pub data: *mut libc::c_void,
    pub stm: *mut mln_lang_stm_t,
    pub run_stack: [mln_lang_stack_node_t; 1025],
    pub run_stack_top: *mut mln_lang_stack_node_t,
    pub scopes: [mln_lang_scope_t; 1025],
    pub scope_top: *mut mln_lang_scope_t,
    pub ref_0: mln_u64_t,
    pub filename: *mut mln_string_t,
    pub resource_set: *mut mln_rbtree_t,
    pub ret_var: *mut mln_lang_var_t,
    pub return_handler: mln_lang_return_handler,
    pub cache: *mut mln_lang_ast_cache_t,
    pub gc: *mut mln_gc_t,
    pub symbols: *mut mln_lang_hash_t,
    pub prev: *mut mln_lang_ctx_s,
    pub next: *mut mln_lang_ctx_s,
    pub sym_head: *mut mln_lang_symbol_node_t,
    pub sym_tail: *mut mln_lang_symbol_node_t,
    pub owner: pthread_t,
    pub alias: *mut mln_string_t,
    #[bitfield(name = "sym_count", ty = "mln_u32_t", bits = "0..=15")]
    #[bitfield(name = "ret_flag", ty = "mln_u32_t", bits = "16..=16")]
    #[bitfield(name = "op_array_flag", ty = "mln_u32_t", bits = "17..=17")]
    #[bitfield(name = "op_bool_flag", ty = "mln_u32_t", bits = "18..=18")]
    #[bitfield(name = "op_func_flag", ty = "mln_u32_t", bits = "19..=19")]
    #[bitfield(name = "op_int_flag", ty = "mln_u32_t", bits = "20..=20")]
    #[bitfield(name = "op_nil_flag", ty = "mln_u32_t", bits = "21..=21")]
    #[bitfield(name = "op_obj_flag", ty = "mln_u32_t", bits = "22..=22")]
    #[bitfield(name = "op_real_flag", ty = "mln_u32_t", bits = "23..=23")]
    #[bitfield(name = "op_str_flag", ty = "mln_u32_t", bits = "24..=24")]
    #[bitfield(name = "quit", ty = "mln_u32_t", bits = "25..=25")]
    #[bitfield(name = "padding", ty = "mln_u32_t", bits = "26..=31")]
    pub sym_count_ret_flag_op_array_flag_op_bool_flag_op_func_flag_op_int_flag_op_nil_flag_op_obj_flag_op_real_flag_op_str_flag_quit_padding: [u8; 4],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 4],
}
pub type mln_lang_symbol_node_t = mln_lang_symbol_node_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_symbol_node_s {
    pub symbol: *mut mln_string_t,
    pub ctx: *mut mln_lang_ctx_t,
    pub type_0: mln_lang_symbol_type_t,
    pub data: C2RustUnnamed_9,
    pub layer: mln_uauto_t,
    pub bucket: *mut mln_lang_hash_bucket_t,
    pub prev: *mut mln_lang_symbol_node_s,
    pub next: *mut mln_lang_symbol_node_s,
    pub scope_prev: *mut mln_lang_symbol_node_s,
    pub scope_next: *mut mln_lang_symbol_node_s,
}
pub type mln_lang_hash_bucket_t = mln_lang_hash_bucket_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_hash_bucket_s {
    pub head: *mut mln_lang_symbol_node_t,
    pub tail: *mut mln_lang_symbol_node_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_9 {
    pub var: *mut mln_lang_var_t,
    pub set: *mut mln_lang_set_detail_t,
}
pub type mln_lang_set_detail_t = mln_lang_set_detail_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_set_detail_s {
    pub name: *mut mln_string_t,
    pub members: *mut mln_rbtree_t,
    pub ref_0: mln_u64_t,
}
pub type mln_lang_var_t = mln_lang_var_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_var_s {
    pub type_0: mln_lang_var_type_t,
    pub name: *mut mln_string_t,
    pub val: *mut mln_lang_val_t,
    pub in_set: *mut mln_lang_set_detail_t,
    pub prev: *mut mln_lang_var_t,
    pub next: *mut mln_lang_var_t,
    pub ref_0: mln_uauto_t,
}
pub type mln_lang_var_type_t = libc::c_uint;
pub const M_LANG_VAR_REFER: mln_lang_var_type_t = 1;
pub const M_LANG_VAR_NORMAL: mln_lang_var_type_t = 0;
pub type mln_lang_symbol_type_t = libc::c_uint;
pub const M_LANG_SYMBOL_SET: mln_lang_symbol_type_t = 1;
pub const M_LANG_SYMBOL_VAR: mln_lang_symbol_type_t = 0;
pub type mln_lang_hash_t = mln_lang_hash_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_hash_s {
    pub bucket: *mut mln_lang_hash_bucket_t,
    pub len: mln_size_t,
}
pub type mln_lang_ast_cache_t = mln_lang_ast_cache_s;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct mln_lang_ast_cache_s {
    pub stm: *mut mln_lang_stm_t,
    pub code: *mut mln_string_t,
    #[bitfield(name = "ref_0", ty = "mln_u64_t", bits = "0..=62")]
    #[bitfield(name = "expire", ty = "mln_u64_t", bits = "63..=63")]
    pub ref_0_expire: [u8; 8],
    pub timestamp: mln_u64_t,
    pub prev: *mut mln_lang_ast_cache_s,
    pub next: *mut mln_lang_ast_cache_s,
}
pub type mln_lang_return_handler = Option::<
    unsafe extern "C" fn(*mut mln_lang_ctx_t) -> (),
>;
pub type mln_lang_scope_t = mln_lang_scope_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_scope_s {
    pub type_0: mln_lang_scope_type_t,
    pub name: *mut mln_string_t,
    pub ctx: *mut mln_lang_ctx_t,
    pub cur_stack: *mut mln_lang_stack_node_t,
    pub entry: *mut mln_lang_stm_t,
    pub layer: mln_uauto_t,
    pub sym_head: *mut mln_lang_symbol_node_t,
    pub sym_tail: *mut mln_lang_symbol_node_t,
}
pub type mln_lang_stack_node_t = mln_lang_stack_node_s;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct mln_lang_stack_node_s {
    pub ctx: *mut mln_lang_ctx_t,
    pub type_0: mln_lang_stack_node_type_t,
    #[bitfield(name = "step", ty = "mln_u32_t", bits = "0..=30")]
    #[bitfield(name = "call", ty = "mln_u32_t", bits = "31..=31")]
    pub step_call: [u8; 4],
    pub data: C2RustUnnamed_10,
    pub ret_var: *mut mln_lang_var_t,
    pub ret_var2: *mut mln_lang_var_t,
    pub pos: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_10 {
    pub stm: *mut mln_lang_stm_t,
    pub funcdef: *mut mln_lang_funcdef_t,
    pub set: *mut mln_lang_set_t,
    pub set_stm: *mut mln_lang_setstm_t,
    pub block: *mut mln_lang_block_t,
    pub w: *mut mln_lang_while_t,
    pub sw: *mut mln_lang_switch_t,
    pub sw_stm: *mut mln_lang_switchstm_t,
    pub f: *mut mln_lang_for_t,
    pub i: *mut mln_lang_if_t,
    pub exp: *mut mln_lang_exp_t,
    pub assign: *mut mln_lang_assign_t,
    pub logiclow: *mut mln_lang_logiclow_t,
    pub logichigh: *mut mln_lang_logichigh_t,
    pub relativelow: *mut mln_lang_relativelow_t,
    pub relativehigh: *mut mln_lang_relativehigh_t,
    pub move_0: *mut mln_lang_move_t,
    pub addsub: *mut mln_lang_addsub_t,
    pub muldiv: *mut mln_lang_muldiv_t,
    pub not: *mut mln_lang_not_t,
    pub suffix: *mut mln_lang_suffix_t,
    pub locate: *mut mln_lang_locate_t,
    pub spec: *mut mln_lang_spec_t,
    pub factor: *mut mln_lang_factor_t,
    pub elemlist: *mut mln_lang_elemlist_t,
}
pub type mln_lang_stack_node_type_t = libc::c_uint;
pub const M_LSNT_ELEMLIST: mln_lang_stack_node_type_t = 24;
pub const M_LSNT_FACTOR: mln_lang_stack_node_type_t = 23;
pub const M_LSNT_SPEC: mln_lang_stack_node_type_t = 22;
pub const M_LSNT_LOCATE: mln_lang_stack_node_type_t = 21;
pub const M_LSNT_SUFFIX: mln_lang_stack_node_type_t = 20;
pub const M_LSNT_NOT: mln_lang_stack_node_type_t = 19;
pub const M_LSNT_MULDIV: mln_lang_stack_node_type_t = 18;
pub const M_LSNT_ADDSUB: mln_lang_stack_node_type_t = 17;
pub const M_LSNT_MOVE: mln_lang_stack_node_type_t = 16;
pub const M_LSNT_RELATIVEHIGH: mln_lang_stack_node_type_t = 15;
pub const M_LSNT_RELATIVELOW: mln_lang_stack_node_type_t = 14;
pub const M_LSNT_LOGICHIGH: mln_lang_stack_node_type_t = 13;
pub const M_LSNT_LOGICLOW: mln_lang_stack_node_type_t = 12;
pub const M_LSNT_ASSIGN: mln_lang_stack_node_type_t = 11;
pub const M_LSNT_EXP: mln_lang_stack_node_type_t = 10;
pub const M_LSNT_IF: mln_lang_stack_node_type_t = 9;
pub const M_LSNT_FOR: mln_lang_stack_node_type_t = 8;
pub const M_LSNT_SWITCHSTM: mln_lang_stack_node_type_t = 7;
pub const M_LSNT_SWITCH: mln_lang_stack_node_type_t = 6;
pub const M_LSNT_WHILE: mln_lang_stack_node_type_t = 5;
pub const M_LSNT_BLOCK: mln_lang_stack_node_type_t = 4;
pub const M_LSNT_SETSTM: mln_lang_stack_node_type_t = 3;
pub const M_LSNT_SET: mln_lang_stack_node_type_t = 2;
pub const M_LSNT_FUNCDEF: mln_lang_stack_node_type_t = 1;
pub const M_LSNT_STM: mln_lang_stack_node_type_t = 0;
pub type mln_lang_scope_type_t = libc::c_uint;
pub const M_LANG_SCOPE_TYPE_FUNC: mln_lang_scope_type_t = 1;
pub const M_LANG_SCOPE_TYPE_SET: mln_lang_scope_type_t = 0;
pub type mln_lang_t = mln_lang_s;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct mln_lang_s {
    pub ev: *mut mln_event_t,
    pub pool: *mut mln_alloc_t,
    pub run_head: *mut mln_lang_ctx_t,
    pub run_tail: *mut mln_lang_ctx_t,
    pub wait_head: *mut mln_lang_ctx_t,
    pub wait_tail: *mut mln_lang_ctx_t,
    pub resource_set: *mut mln_rbtree_t,
    #[bitfield(name = "wait", ty = "mln_u64_t", bits = "0..=61")]
    #[bitfield(name = "quit", ty = "mln_u64_t", bits = "62..=62")]
    #[bitfield(name = "cache", ty = "mln_u64_t", bits = "63..=63")]
    pub wait_quit_cache: [u8; 8],
    pub shift_table: *mut libc::c_void,
    pub cache_head: *mut mln_lang_ast_cache_t,
    pub cache_tail: *mut mln_lang_ast_cache_t,
    pub signal: mln_lang_run_ctl_t,
    pub clear: mln_lang_run_ctl_t,
    pub launcher: ev_fd_handler,
    pub alias_set: *mut mln_rbtree_t,
    pub lock: pthread_mutex_t,
}
pub type mln_lang_run_ctl_t = Option::<
    unsafe extern "C" fn(*mut mln_lang_t) -> libc::c_int,
>;
pub type mln_lang_func_type_t = libc::c_uint;
pub const M_FUNC_EXTERNAL: mln_lang_func_type_t = 1;
pub const M_FUNC_INTERNAL: mln_lang_func_type_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_11 {
    pub i: mln_s64_t,
    pub b: mln_u8_t,
    pub f: libc::c_double,
    pub s: *mut mln_string_t,
    pub obj: *mut mln_lang_object_t,
    pub func: *mut mln_lang_func_detail_t,
    pub array: *mut mln_lang_array_t,
    pub call: *mut mln_lang_funccall_val_t,
}
pub type mln_lang_funccall_val_t = mln_lang_funccall_val_s;
pub type mln_lang_array_t = mln_lang_array_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_array_s {
    pub elems_index: *mut mln_rbtree_t,
    pub elems_key: *mut mln_rbtree_t,
    pub index: mln_u64_t,
    pub ref_0: mln_u64_t,
    pub gc_item: *mut mln_lang_gc_item_t,
    pub ctx: *mut mln_lang_ctx_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_gc_item_t {
    pub gc: *mut mln_gc_t,
    pub type_0: mln_lang_gc_type_t,
    pub data: C2RustUnnamed_12,
    pub gc_data: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_12 {
    pub obj: *mut mln_lang_object_t,
    pub array: *mut mln_lang_array_t,
}
pub type mln_lang_object_t = mln_lang_object_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_object_s {
    pub in_set: *mut mln_lang_set_detail_t,
    pub members: *mut mln_rbtree_t,
    pub ref_0: mln_u64_t,
    pub gc_item: *mut mln_lang_gc_item_t,
    pub ctx: *mut mln_lang_ctx_t,
}
pub type mln_lang_gc_type_t = libc::c_uint;
pub const M_GC_ARRAY: mln_lang_gc_type_t = 1;
pub const M_GC_OBJ: mln_lang_gc_type_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_array_elem_s {
    pub index: mln_u64_t,
    pub key: *mut mln_lang_var_t,
    pub value: *mut mln_lang_var_t,
}
pub type mln_lang_array_elem_t = mln_lang_array_elem_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_methods_s {
    pub assign_handler: mln_lang_op,
    pub pluseq_handler: mln_lang_op,
    pub subeq_handler: mln_lang_op,
    pub lmoveq_handler: mln_lang_op,
    pub rmoveq_handler: mln_lang_op,
    pub muleq_handler: mln_lang_op,
    pub diveq_handler: mln_lang_op,
    pub oreq_handler: mln_lang_op,
    pub andeq_handler: mln_lang_op,
    pub xoreq_handler: mln_lang_op,
    pub modeq_handler: mln_lang_op,
    pub cor_handler: mln_lang_op,
    pub cand_handler: mln_lang_op,
    pub cxor_handler: mln_lang_op,
    pub equal_handler: mln_lang_op,
    pub nonequal_handler: mln_lang_op,
    pub less_handler: mln_lang_op,
    pub lesseq_handler: mln_lang_op,
    pub grea_handler: mln_lang_op,
    pub greale_handler: mln_lang_op,
    pub lmov_handler: mln_lang_op,
    pub rmov_handler: mln_lang_op,
    pub plus_handler: mln_lang_op,
    pub sub_handler: mln_lang_op,
    pub mul_handler: mln_lang_op,
    pub div_handler: mln_lang_op,
    pub mod_handler: mln_lang_op,
    pub sdec_handler: mln_lang_op,
    pub sinc_handler: mln_lang_op,
    pub index_handler: mln_lang_op,
    pub property_handler: mln_lang_op,
    pub negative_handler: mln_lang_op,
    pub reverse_handler: mln_lang_op,
    pub not_handler: mln_lang_op,
    pub pinc_handler: mln_lang_op,
    pub pdec_handler: mln_lang_op,
}
pub type mln_lang_op = Option::<
    unsafe extern "C" fn(
        *mut mln_lang_ctx_t,
        *mut *mut mln_lang_var_t,
        *mut mln_lang_var_t,
        *mut mln_lang_var_t,
    ) -> libc::c_int,
>;
pub type mln_lang_method_t = mln_lang_methods_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_resource_s {
    pub name: *mut mln_string_t,
    pub data: *mut libc::c_void,
    pub free_handler: mln_lang_resource_free,
}
pub type mln_lang_resource_free = Option::<
    unsafe extern "C" fn(*mut libc::c_void) -> (),
>;
pub type mln_lang_resource_t = mln_lang_resource_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_ctx_pipe_elem_s {
    pub type_0: libc::c_int,
    pub data: C2RustUnnamed_13,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_13 {
    pub i: mln_s64_t,
    pub r: libc::c_double,
    pub s: *mut mln_string_t,
}
pub type mln_lang_ctx_pipe_elem_t = mln_lang_ctx_pipe_elem_s;
pub type mln_lang_stack_handler = Option::<
    unsafe extern "C" fn(*mut mln_lang_ctx_t) -> (),
>;
pub type import_init_t = Option::<
    unsafe extern "C" fn(*mut mln_lang_ctx_t, *mut mln_conf_t) -> *mut mln_lang_var_t,
>;
pub type import_destroy_t = Option::<unsafe extern "C" fn(*mut mln_lang_t) -> ()>;
pub type mln_lang_ctx_pipe_recv_cb_t = Option::<
    unsafe extern "C" fn(*mut mln_lang_ctx_t, *mut mln_lang_val_t) -> libc::c_int,
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_import_t {
    pub name: *mut mln_string_t,
    pub ref_0: mln_size_t,
    pub count: mln_size_t,
    pub handle: *mut libc::c_void,
    pub node: *mut mln_rbtree_node_t,
    pub lang: *mut mln_lang_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_ctx_import_t {
    pub i: *mut mln_lang_import_t,
    pub ctx: *mut mln_lang_ctx_t,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct mln_lang_ctx_pipe_t {
    pub ctx: *mut mln_lang_ctx_t,
    pub list: mln_array_t,
    pub lock: pthread_mutex_t,
    pub recv_handler: mln_lang_ctx_pipe_recv_cb_t,
    #[bitfield(name = "subscribed", ty = "mln_u32_t", bits = "0..=0")]
    #[bitfield(name = "padding", ty = "mln_u32_t", bits = "1..=31")]
    pub subscribed_padding: [u8; 4],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 4],
}
pub type mln_log_level_t = libc::c_uint;
pub const error: mln_log_level_t = 4;
pub const warn: mln_log_level_t = 3;
pub const debug: mln_log_level_t = 2;
pub const report: mln_log_level_t = 1;
pub const none: mln_log_level_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_scan_s {
    pub cnt: *mut libc::c_int,
    pub tree: *mut mln_rbtree_t,
    pub tree2: *mut mln_rbtree_t,
    pub ctx: *mut mln_lang_ctx_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_gc_scan_s {
    pub tree: *mut mln_rbtree_t,
    pub gc: *mut mln_gc_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mln_lang_gc_setter_s {
    pub visited: *mut mln_rbtree_t,
    pub gc: *mut mln_gc_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: libc::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3],
}
#[inline]
unsafe extern "C" fn mln_alloc_init(mut parent: *mut mln_alloc_t) -> *mut mln_alloc_t {
    let mut pool: *mut mln_alloc_t = 0 as *mut mln_alloc_t;
    if !parent.is_null() {
        if !((*parent).mem).is_null() {
            if ((*parent).lock).expect("non-null function pointer")((*parent).locker)
                != 0 as libc::c_int
            {
                return 0 as *mut mln_alloc_t;
            }
        }
        pool = mln_alloc_m(
            parent,
            ::core::mem::size_of::<mln_alloc_t>() as libc::c_ulong,
        ) as *mut mln_alloc_t;
        if !((*parent).mem).is_null() {
            ((*parent).unlock).expect("non-null function pointer")((*parent).locker);
        }
    } else {
        pool = malloc(::core::mem::size_of::<mln_alloc_t>() as libc::c_ulong)
            as *mut mln_alloc_t;
    }
    if pool.is_null() {
        return pool;
    }
    mln_alloc_mgr_table_init(((*pool).mgr_tbl).as_mut_ptr());
    (*pool).parent = parent;
    (*pool).large_used_tail = 0 as *mut mln_alloc_chunk_t;
    (*pool).large_used_head = (*pool).large_used_tail;
    (*pool).shm_tail = 0 as *mut mln_alloc_shm_t;
    (*pool).shm_head = (*pool).shm_tail;
    (*pool).mem = 0 as *mut libc::c_void;
    (*pool).shm_size = 0 as libc::c_int as mln_size_t;
    (*pool).locker = 0 as *mut libc::c_void;
    (*pool).lock = None;
    (*pool).unlock = None;
    return pool;
}
#[inline]
unsafe extern "C" fn mln_alloc_mgr_table_init(mut tbl: *mut mln_alloc_mgr_t) {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut blk_size: mln_size_t = 0;
    let mut am: *mut mln_alloc_mgr_t = 0 as *mut mln_alloc_mgr_t;
    let mut amprev: *mut mln_alloc_mgr_t = 0 as *mut mln_alloc_mgr_t;
    i = 0 as libc::c_int;
    while i
        < 18 as libc::c_int * 2 as libc::c_int - (2 as libc::c_int - 1 as libc::c_int)
    {
        blk_size = 0 as libc::c_int as mln_size_t;
        j = 0 as libc::c_int;
        while (j as libc::c_ulong)
            < ((i / 2 as libc::c_int) as libc::c_ulong)
                .wrapping_add(4 as libc::c_int as mln_size_t)
        {
            blk_size |= (1 as libc::c_int as mln_size_t) << j;
            j += 1;
            j;
        }
        am = &mut *tbl.offset(i as isize) as *mut mln_alloc_mgr_t;
        (*am).free_tail = 0 as *mut mln_alloc_blk_t;
        (*am).free_head = (*am).free_tail;
        (*am).used_tail = 0 as *mut mln_alloc_blk_t;
        (*am).used_head = (*am).used_tail;
        (*am).chunk_tail = 0 as *mut mln_alloc_chunk_t;
        (*am).chunk_head = (*am).chunk_tail;
        (*am).blk_size = blk_size.wrapping_add(1 as libc::c_int as libc::c_ulong);
        if i != 0 as libc::c_int {
            amprev = &mut *tbl.offset((i - 1 as libc::c_int) as isize)
                as *mut mln_alloc_mgr_t;
            (*amprev).free_tail = 0 as *mut mln_alloc_blk_t;
            (*amprev).free_head = (*amprev).free_tail;
            (*amprev).used_tail = 0 as *mut mln_alloc_blk_t;
            (*amprev).used_head = (*amprev).used_tail;
            (*amprev).chunk_tail = 0 as *mut mln_alloc_chunk_t;
            (*amprev).chunk_head = (*amprev).chunk_tail;
            (*amprev)
                .blk_size = ((*am).blk_size)
                .wrapping_add((*tbl.offset((i - 2 as libc::c_int) as isize)).blk_size)
                >> 1 as libc::c_int;
        }
        i += 2 as libc::c_int;
    }
}
#[inline]
unsafe extern "C" fn mln_alloc_m(
    mut pool: *mut mln_alloc_t,
    mut size: mln_size_t,
) -> *mut libc::c_void {
    let mut current_block: u64;
    let mut blk: *mut mln_alloc_blk_t = 0 as *mut mln_alloc_blk_t;
    let mut am: *mut mln_alloc_mgr_t = 0 as *mut mln_alloc_mgr_t;
    let mut ch: *mut mln_alloc_chunk_t = 0 as *mut mln_alloc_chunk_t;
    let mut ptr: mln_u8ptr_t = 0 as *mut libc::c_uchar;
    let mut n: mln_size_t = 0;
    if !((*pool).mem).is_null() {
        return mln_alloc_shm_m(pool, size);
    }
    am = mln_alloc_get_mgr_by_size(((*pool).mgr_tbl).as_mut_ptr(), size);
    if am.is_null() {
        n = size
            .wrapping_add(::core::mem::size_of::<mln_alloc_blk_t>() as libc::c_ulong)
            .wrapping_add(::core::mem::size_of::<mln_alloc_chunk_t>() as libc::c_ulong)
            .wrapping_add(3 as libc::c_int as libc::c_ulong) >> 2 as libc::c_int;
        size = n << 2 as libc::c_int;
        if !((*pool).parent).is_null() {
            if !((*(*pool).parent).mem).is_null() {
                if ((*(*pool).parent).lock)
                    .expect("non-null function pointer")((*(*pool).parent).locker)
                    != 0 as libc::c_int
                {
                    return 0 as *mut libc::c_void;
                }
            }
            ptr = mln_alloc_c((*pool).parent, size) as mln_u8ptr_t;
            if !((*(*pool).parent).mem).is_null() {
                ((*(*pool).parent).unlock)
                    .expect("non-null function pointer")((*(*pool).parent).locker);
            }
        } else {
            ptr = calloc(1 as libc::c_int as libc::c_ulong, size) as mln_u8ptr_t;
        }
        if ptr.is_null() {
            return 0 as *mut libc::c_void;
        }
        ch = ptr as *mut mln_alloc_chunk_t;
        (*ch).refer = 1 as libc::c_int as mln_size_t;
        mln_chunk_chain_add(
            &mut (*pool).large_used_head,
            &mut (*pool).large_used_tail,
            ch,
        );
        blk = ptr
            .offset(
                ::core::mem::size_of::<mln_alloc_chunk_t>() as libc::c_ulong as isize,
            ) as *mut mln_alloc_blk_t;
        (*blk)
            .data = ptr
            .offset(
                ::core::mem::size_of::<mln_alloc_chunk_t>() as libc::c_ulong as isize,
            )
            .offset(::core::mem::size_of::<mln_alloc_blk_t>() as libc::c_ulong as isize)
            as *mut libc::c_void;
        (*blk).chunk = ch;
        (*blk).pool = pool;
        (*blk)
            .blk_size = size
            .wrapping_sub(
                (::core::mem::size_of::<mln_alloc_chunk_t>() as libc::c_ulong)
                    .wrapping_add(
                        ::core::mem::size_of::<mln_alloc_blk_t>() as libc::c_ulong,
                    ),
            );
        (*blk).set_is_large(1 as libc::c_int as mln_size_t);
        (*blk).set_in_used(1 as libc::c_int as mln_size_t);
        (*ch).blks[0 as libc::c_int as usize] = blk;
        return (*blk).data;
    }
    if ((*am).free_head).is_null() {
        n = (::core::mem::size_of::<mln_alloc_blk_t>() as libc::c_ulong)
            .wrapping_add((*am).blk_size)
            .wrapping_add(3 as libc::c_int as libc::c_ulong) >> 2 as libc::c_int;
        size = n << 2 as libc::c_int;
        n = (::core::mem::size_of::<mln_alloc_chunk_t>() as libc::c_ulong)
            .wrapping_add((4 as libc::c_int as libc::c_ulong).wrapping_mul(size))
            .wrapping_add(3 as libc::c_int as libc::c_ulong) >> 2 as libc::c_int;
        if !((*pool).parent).is_null() {
            if !((*(*pool).parent).mem).is_null() {
                if ((*(*pool).parent).lock)
                    .expect("non-null function pointer")((*(*pool).parent).locker)
                    != 0 as libc::c_int
                {
                    return 0 as *mut libc::c_void;
                }
            }
            ptr = mln_alloc_m((*pool).parent, n << 2 as libc::c_int) as mln_u8ptr_t;
            if !((*(*pool).parent).mem).is_null() {
                ((*(*pool).parent).unlock)
                    .expect("non-null function pointer")((*(*pool).parent).locker);
            }
        } else {
            ptr = malloc(n << 2 as libc::c_int) as mln_u8ptr_t;
        }
        if ptr.is_null() {
            loop {
                if !(am
                    < ((*pool).mgr_tbl)
                        .as_mut_ptr()
                        .offset((18 as libc::c_int * 2 as libc::c_int) as isize)
                        .offset(-((2 as libc::c_int - 1 as libc::c_int) as isize)))
                {
                    current_block = 7427571413727699167;
                    break;
                }
                if !((*am).free_head).is_null() {
                    current_block = 17809101626333725014;
                    break;
                }
                am = am.offset(1);
                am;
            }
            match current_block {
                17809101626333725014 => {}
                _ => return 0 as *mut libc::c_void,
            }
        } else {
            ch = ptr as *mut mln_alloc_chunk_t;
            mln_chunk_chain_add(&mut (*am).chunk_head, &mut (*am).chunk_tail, ch);
            (*ch).count = 0 as libc::c_int as mln_size_t;
            (*ch).refer = (*ch).count;
            (*ch).mgr = am;
            ptr = ptr
                .offset(
                    ::core::mem::size_of::<mln_alloc_chunk_t>() as libc::c_ulong as isize,
                );
            n = 0 as libc::c_int as mln_size_t;
            while n < 4 as libc::c_int as libc::c_ulong {
                blk = ptr as *mut mln_alloc_blk_t;
                mln_blk_chain_add(&mut (*am).free_head, &mut (*am).free_tail, blk);
                (*blk).pool = pool;
                (*blk)
                    .data = ptr
                    .offset(
                        ::core::mem::size_of::<mln_alloc_blk_t>() as libc::c_ulong
                            as isize,
                    ) as *mut libc::c_void;
                (*blk).chunk = ch;
                (*blk).blk_size = (*am).blk_size;
                (*blk).set_in_used(0 as libc::c_int as mln_size_t);
                (*blk).set_is_large((*blk).in_used());
                (*ch).blks[n as usize] = blk;
                ptr = ptr.offset(size as isize);
                n = n.wrapping_add(1);
                n;
            }
            (*ch).blks[n as usize] = 0 as *mut mln_alloc_blk_t;
        }
    }
    blk = (*am).free_tail;
    mln_blk_chain_del(&mut (*am).free_head, &mut (*am).free_tail, blk);
    mln_blk_chain_add(&mut (*am).used_head, &mut (*am).used_tail, blk);
    (*blk).set_in_used(1 as libc::c_int as mln_size_t);
    (*(*blk).chunk).refer = ((*(*blk).chunk).refer).wrapping_add(1);
    (*(*blk).chunk).refer;
    return (*blk).data;
}
#[inline]
unsafe extern "C" fn mln_blk_chain_add(
    mut head: *mut *mut mln_alloc_blk_t,
    mut tail: *mut *mut mln_alloc_blk_t,
    mut node: *mut mln_alloc_blk_t,
) {
    (*node).next = 0 as *mut mln_alloc_blk_s;
    if (*head).is_null() {
        *head = node;
    } else {
        (**tail).next = node;
    }
    (*node).prev = *tail;
    *tail = node;
}
#[inline]
unsafe extern "C" fn mln_blk_chain_del(
    mut head: *mut *mut mln_alloc_blk_t,
    mut tail: *mut *mut mln_alloc_blk_t,
    mut node: *mut mln_alloc_blk_t,
) {
    if *head == node {
        if *tail == node {
            *tail = 0 as *mut mln_alloc_blk_t;
            *head = *tail;
        } else {
            *head = (*node).next;
            (**head).prev = 0 as *mut mln_alloc_blk_s;
        }
    } else if *tail == node {
        *tail = (*node).prev;
        (**tail).next = 0 as *mut mln_alloc_blk_s;
    } else {
        (*(*node).prev).next = (*node).next;
        (*(*node).next).prev = (*node).prev;
    }
    (*node).next = 0 as *mut mln_alloc_blk_s;
    (*node).prev = (*node).next;
}
#[inline]
unsafe extern "C" fn mln_chunk_chain_add(
    mut head: *mut *mut mln_alloc_chunk_t,
    mut tail: *mut *mut mln_alloc_chunk_t,
    mut node: *mut mln_alloc_chunk_t,
) {
    (*node).next = 0 as *mut mln_alloc_chunk_s;
    if (*head).is_null() {
        *head = node;
    } else {
        (**tail).next = node;
    }
    (*node).prev = *tail;
    *tail = node;
}
#[inline]
unsafe extern "C" fn mln_alloc_c(
    mut pool: *mut mln_alloc_t,
    mut size: mln_size_t,
) -> *mut libc::c_void {
    let mut ptr: mln_u8ptr_t = mln_alloc_m(pool, size) as mln_u8ptr_t;
    if ptr.is_null() {
        return 0 as *mut libc::c_void;
    }
    memset(ptr as *mut libc::c_void, 0 as libc::c_int, size);
    return ptr as *mut libc::c_void;
}
#[inline]
unsafe extern "C" fn mln_alloc_get_mgr_by_size(
    mut tbl: *mut mln_alloc_mgr_t,
    mut size: mln_size_t,
) -> *mut mln_alloc_mgr_t {
    if size
        > (*tbl
            .offset(
                (18 as libc::c_int * 2 as libc::c_int
                    - (2 as libc::c_int - 1 as libc::c_int) - 1 as libc::c_int) as isize,
            ))
            .blk_size
    {
        return 0 as *mut mln_alloc_mgr_t;
    }
    if size <= (*tbl.offset(0 as libc::c_int as isize)).blk_size {
        return &mut *tbl.offset(0 as libc::c_int as isize) as *mut mln_alloc_mgr_t;
    }
    let mut am: *mut mln_alloc_mgr_t = tbl;
    let mut off: mln_size_t = 0 as libc::c_int as mln_size_t;
    asm!(
        "bsr {0}, {1}", lateout(reg) off, in(reg) &size, options(preserves_flags)
    );
    off = off
        .wrapping_sub(4 as libc::c_int as mln_size_t)
        .wrapping_mul(2 as libc::c_int as libc::c_ulong);
    if (*am.offset(off as isize)).blk_size >= size {
        return &mut *am.offset(off as isize) as *mut mln_alloc_mgr_t;
    }
    if (*am.offset(off.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize))
        .blk_size >= size
    {
        return &mut *am
            .offset(off.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize)
            as *mut mln_alloc_mgr_t;
    }
    return &mut *am.offset(off.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize)
        as *mut mln_alloc_mgr_t;
}
#[inline]
unsafe extern "C" fn mln_alloc_shm_m(
    mut pool: *mut mln_alloc_t,
    mut size: mln_size_t,
) -> *mut libc::c_void {
    let mut as_0: *mut mln_alloc_shm_t = 0 as *mut mln_alloc_shm_t;
    let mut Boff: mln_off_t = -(1 as libc::c_int) as mln_off_t;
    let mut boff: mln_off_t = -(1 as libc::c_int) as mln_off_t;
    if size
        > ((1 as libc::c_int * 1024 as libc::c_int + 512 as libc::c_int)
            * 1024 as libc::c_int) as libc::c_ulong
    {
        return mln_alloc_shm_large_m(pool, size);
    }
    let mut current_block_8: u64;
    if ((*pool).shm_head).is_null() {
        current_block_8 = 9124099917951443736;
    } else {
        as_0 = (*pool).shm_head;
        while !as_0.is_null() {
            if mln_alloc_shm_allowed(as_0, &mut Boff, &mut boff, size) != 0 {
                break;
            }
            as_0 = (*as_0).next;
        }
        if as_0.is_null() {
            current_block_8 = 9124099917951443736;
        } else {
            current_block_8 = 2979737022853876585;
        }
    }
    match current_block_8 {
        9124099917951443736 => {
            as_0 = mln_alloc_shm_new_block(pool, &mut Boff, &mut boff, size);
            if as_0.is_null() {
                return 0 as *mut libc::c_void;
            }
        }
        _ => {}
    }
    return mln_alloc_shm_set_bitmap(as_0, Boff, boff, size);
}
#[inline]
unsafe extern "C" fn mln_alloc_shm_set_bitmap(
    mut as_0: *mut mln_alloc_shm_t,
    mut Boff: mln_off_t,
    mut boff: mln_off_t,
    mut size: mln_size_t,
) -> *mut libc::c_void {
    let mut i: libc::c_int = 0;
    let mut n: libc::c_int = size
        .wrapping_add(::core::mem::size_of::<mln_alloc_blk_t>() as libc::c_ulong)
        .wrapping_add(64 as libc::c_int as libc::c_ulong)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong)
        .wrapping_div(64 as libc::c_int as libc::c_ulong) as libc::c_int;
    let mut p: mln_u8ptr_t = 0 as *mut libc::c_uchar;
    let mut pend: mln_u8ptr_t = 0 as *mut libc::c_uchar;
    let mut addr: mln_u8ptr_t = 0 as *mut libc::c_uchar;
    let mut blk: *mut mln_alloc_blk_t = 0 as *mut mln_alloc_blk_t;
    addr = ((*as_0).addr)
        .offset(
            ((Boff * 8 as libc::c_int as libc::c_long
                + (7 as libc::c_int as libc::c_long - boff))
                * 64 as libc::c_int as libc::c_long) as isize,
        ) as mln_u8ptr_t;
    blk = addr as *mut mln_alloc_blk_t;
    memset(
        blk as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<mln_alloc_blk_t>() as libc::c_ulong,
    );
    (*blk).pool = (*as_0).pool;
    (*blk)
        .data = addr
        .offset(::core::mem::size_of::<mln_alloc_blk_t>() as libc::c_ulong as isize)
        as *mut libc::c_void;
    (*blk).chunk = as_0 as *mut mln_alloc_chunk_t;
    (*blk).blk_size = size;
    (*blk)
        .set_padding(
            ((Boff & 0xffff as libc::c_int as libc::c_long) << 8 as libc::c_int
                | boff & 0xff as libc::c_int as libc::c_long) as mln_size_t,
        );
    (*blk).set_is_large(0 as libc::c_int as mln_size_t);
    (*blk).set_in_used(1 as libc::c_int as mln_size_t);
    p = ((*as_0).bitmap).as_mut_ptr().offset(Boff as isize);
    pend = p.offset(4096 as libc::c_int as isize);
    i = boff as libc::c_int;
    while p < pend {
        *p = (*p as libc::c_int | (1 as libc::c_int as mln_u8_t as libc::c_int) << i)
            as libc::c_uchar;
        (*as_0).nfree = ((*as_0).nfree).wrapping_sub(1);
        (*as_0).nfree;
        n -= 1;
        if n <= 0 as libc::c_int {
            break;
        }
        i -= 1;
        if i < 0 as libc::c_int {
            i = 7 as libc::c_int;
            p = p.offset(1);
            p;
        }
    }
    return (*blk).data;
}
#[inline]
unsafe extern "C" fn mln_alloc_shm_new_block(
    mut pool: *mut mln_alloc_t,
    mut Boff: *mut mln_off_t,
    mut boff: *mut mln_off_t,
    mut size: mln_size_t,
) -> *mut mln_alloc_shm_t {
    let mut ret: *mut mln_alloc_shm_t = 0 as *mut mln_alloc_shm_t;
    ret = mln_alloc_shm_new(
        pool,
        (2 as libc::c_int * 1024 as libc::c_int * 1024 as libc::c_int) as mln_size_t,
        0 as libc::c_int,
    );
    if ret.is_null() {
        return 0 as *mut mln_alloc_shm_t;
    }
    mln_alloc_shm_allowed(ret, Boff, boff, size);
    return ret;
}
#[inline]
unsafe extern "C" fn mln_alloc_shm_allowed(
    mut as_0: *mut mln_alloc_shm_t,
    mut Boff: *mut mln_off_t,
    mut boff: *mut mln_off_t,
    mut size: mln_size_t,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = -(1 as libc::c_int);
    let mut s: libc::c_int = -(1 as libc::c_int);
    let mut n: libc::c_int = size
        .wrapping_add(::core::mem::size_of::<mln_alloc_blk_t>() as libc::c_ulong)
        .wrapping_add(64 as libc::c_int as libc::c_ulong)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong)
        .wrapping_div(64 as libc::c_int as libc::c_ulong) as libc::c_int;
    let mut p: mln_u8ptr_t = 0 as *mut libc::c_uchar;
    let mut pend: mln_u8ptr_t = 0 as *mut libc::c_uchar;
    let mut save: mln_u8ptr_t = 0 as mln_u8ptr_t;
    if n as libc::c_uint > (*as_0).nfree {
        return 0 as libc::c_int;
    }
    p = ((*as_0).bitmap).as_mut_ptr();
    pend = p.offset(4096 as libc::c_int as isize);
    while p < pend {
        if *p as libc::c_int & 0xff as libc::c_int == 0xff as libc::c_int {
            if !save.is_null() {
                j = -(1 as libc::c_int);
                s = -(1 as libc::c_int);
                save = 0 as mln_u8ptr_t;
            }
        } else {
            i = 7 as libc::c_int;
            while i >= 0 as libc::c_int {
                if *p as libc::c_int & (1 as libc::c_int as mln_u8_t as libc::c_int) << i
                    == 0
                {
                    if save.is_null() {
                        j = n;
                        s = i;
                        save = p;
                    }
                    j -= 1;
                    if j <= 0 as libc::c_int {
                        break;
                    }
                } else if !save.is_null() {
                    j = -(1 as libc::c_int);
                    s = -(1 as libc::c_int);
                    save = 0 as mln_u8ptr_t;
                }
                i -= 1;
                i;
            }
            if !save.is_null() && j == 0 {
                *Boff = save.offset_from(((*as_0).bitmap).as_mut_ptr()) as libc::c_long;
                *boff = s as mln_off_t;
                return 1 as libc::c_int;
            }
        }
        p = p.offset(1);
        p;
    }
    return 0 as libc::c_int;
}
#[inline]
unsafe extern "C" fn mln_alloc_shm_new(
    mut pool: *mut mln_alloc_t,
    mut size: mln_size_t,
    mut is_large: libc::c_int,
) -> *mut mln_alloc_shm_t {
    let mut n: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut shm: *mut mln_alloc_shm_t = 0 as *mut mln_alloc_shm_t;
    let mut tmp: *mut mln_alloc_shm_t = 0 as *mut mln_alloc_shm_t;
    let mut p: mln_u8ptr_t = ((*pool).mem)
        .offset(::core::mem::size_of::<mln_alloc_t>() as libc::c_ulong as isize)
        as mln_u8ptr_t;
    tmp = (*pool).shm_head;
    while !tmp.is_null() {
        if ((*tmp).addr as mln_u8ptr_t).offset_from(p) as libc::c_long as libc::c_ulong
            >= size
        {
            break;
        }
        p = ((*tmp).addr).offset((*tmp).size as isize) as mln_u8ptr_t;
        tmp = (*tmp).next;
    }
    if tmp.is_null()
        && ((((*pool).mem).offset((*pool).shm_size as isize) as mln_u8ptr_t)
            .offset_from(p) as libc::c_long as libc::c_ulong) < size
    {
        return 0 as *mut mln_alloc_shm_t;
    }
    shm = p as *mut mln_alloc_shm_t;
    (*shm).pool = pool;
    (*shm).addr = p as *mut libc::c_void;
    (*shm).size = size;
    (*shm)
        .nfree = (if is_large != 0 {
        1 as libc::c_int as libc::c_ulong
    } else {
        size.wrapping_div(64 as libc::c_int as libc::c_ulong)
    }) as mln_u32_t;
    (*shm).set_base((*shm).nfree);
    (*shm).set_large(is_large as mln_u32_t);
    (*shm).next = 0 as *mut mln_alloc_shm_s;
    (*shm).prev = (*shm).next;
    if tmp.is_null() {
        mln_alloc_shm_chain_add(&mut (*pool).shm_head, &mut (*pool).shm_tail, shm);
    } else if tmp == (*pool).shm_head {
        (*shm).next = tmp;
        (*shm).prev = 0 as *mut mln_alloc_shm_s;
        (*tmp).prev = shm;
        (*pool).shm_head = shm;
    } else {
        (*shm).next = tmp;
        (*shm).prev = (*tmp).prev;
        (*(*tmp).prev).next = shm;
        (*tmp).prev = shm;
    }
    if is_large == 0 {
        memset(
            ((*shm).bitmap).as_mut_ptr() as *mut libc::c_void,
            0 as libc::c_int,
            4096 as libc::c_int as libc::c_ulong,
        );
        n = (::core::mem::size_of::<mln_alloc_shm_t>() as libc::c_ulong)
            .wrapping_add(64 as libc::c_int as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong)
            .wrapping_div(64 as libc::c_int as libc::c_ulong) as libc::c_int;
        (*shm)
            .nfree = ((*shm).nfree as libc::c_uint).wrapping_sub(n as libc::c_uint)
            as mln_u32_t as mln_u32_t;
        (*shm).set_base((*shm).base() - n as mln_u32_t);
        i = 0 as libc::c_int;
        j = 0 as libc::c_int;
        while n > 0 as libc::c_int {
            (*shm)
                .bitmap[i
                as usize] = ((*shm).bitmap[i as usize] as libc::c_int
                | (1 as libc::c_int) << 7 as libc::c_int - j) as mln_u8_t;
            j += 1;
            if j >= 8 as libc::c_int {
                j = 0 as libc::c_int;
                i += 1;
                i;
            }
            n -= 1;
            n;
        }
    }
    return shm;
}
#[inline]
unsafe extern "C" fn mln_alloc_shm_chain_add(
    mut head: *mut *mut mln_alloc_shm_t,
    mut tail: *mut *mut mln_alloc_shm_t,
    mut node: *mut mln_alloc_shm_t,
) {
    (*node).next = 0 as *mut mln_alloc_shm_s;
    if (*head).is_null() {
        *head = node;
    } else {
        (**tail).next = node;
    }
    (*node).prev = *tail;
    *tail = node;
}
#[inline]
unsafe extern "C" fn mln_alloc_shm_large_m(
    mut pool: *mut mln_alloc_t,
    mut size: mln_size_t,
) -> *mut libc::c_void {
    let mut as_0: *mut mln_alloc_shm_t = 0 as *mut mln_alloc_shm_t;
    let mut blk: *mut mln_alloc_blk_t = 0 as *mut mln_alloc_blk_t;
    as_0 = mln_alloc_shm_new(
        pool,
        size
            .wrapping_add(::core::mem::size_of::<mln_alloc_shm_t>() as libc::c_ulong)
            .wrapping_add(::core::mem::size_of::<mln_alloc_blk_t>() as libc::c_ulong),
        1 as libc::c_int,
    );
    if as_0.is_null() {
        return 0 as *mut libc::c_void;
    }
    (*as_0).nfree = 0 as libc::c_int as mln_u32_t;
    blk = ((*as_0).addr)
        .offset(::core::mem::size_of::<mln_alloc_shm_t>() as libc::c_ulong as isize)
        as *mut mln_alloc_blk_t;
    memset(
        blk as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<mln_alloc_blk_t>() as libc::c_ulong,
    );
    (*blk).pool = pool;
    (*blk).blk_size = size;
    (*blk)
        .data = ((*as_0).addr)
        .offset(::core::mem::size_of::<mln_alloc_shm_t>() as libc::c_ulong as isize)
        .offset(::core::mem::size_of::<mln_alloc_blk_t>() as libc::c_ulong as isize);
    (*blk).chunk = as_0 as *mut mln_alloc_chunk_t;
    (*blk).set_is_large(1 as libc::c_int as mln_size_t);
    (*blk).set_in_used(1 as libc::c_int as mln_size_t);
    return (*blk).data;
}
#[inline]
unsafe extern "C" fn mln_alloc_destroy(mut pool: *mut mln_alloc_t) {
    if pool.is_null() {
        return;
    }
    let mut parent: *mut mln_alloc_t = (*pool).parent;
    if !parent.is_null() && !((*parent).mem).is_null() {
        if ((*parent).lock).expect("non-null function pointer")((*parent).locker)
            != 0 as libc::c_int
        {
            return;
        }
    }
    if ((*pool).mem).is_null() {
        let mut am: *mut mln_alloc_mgr_t = 0 as *mut mln_alloc_mgr_t;
        let mut amend: *mut mln_alloc_mgr_t = 0 as *mut mln_alloc_mgr_t;
        amend = ((*pool).mgr_tbl)
            .as_mut_ptr()
            .offset((18 as libc::c_int * 2 as libc::c_int) as isize)
            .offset(-((2 as libc::c_int - 1 as libc::c_int) as isize));
        let mut ch: *mut mln_alloc_chunk_t = 0 as *mut mln_alloc_chunk_t;
        am = ((*pool).mgr_tbl).as_mut_ptr();
        while am < amend {
            loop {
                ch = (*am).chunk_head;
                if ch.is_null() {
                    break;
                }
                mln_chunk_chain_del(&mut (*am).chunk_head, &mut (*am).chunk_tail, ch);
                if !parent.is_null() {
                    mln_alloc_free(ch as *mut libc::c_void);
                } else {
                    free(ch as *mut libc::c_void);
                }
            }
            am = am.offset(1);
            am;
        }
        loop {
            ch = (*pool).large_used_head;
            if ch.is_null() {
                break;
            }
            mln_chunk_chain_del(
                &mut (*pool).large_used_head,
                &mut (*pool).large_used_tail,
                ch,
            );
            if !parent.is_null() {
                mln_alloc_free(ch as *mut libc::c_void);
            } else {
                free(ch as *mut libc::c_void);
            }
        }
        if !parent.is_null() {
            mln_alloc_free(pool as *mut libc::c_void);
        } else {
            free(pool as *mut libc::c_void);
        }
    } else {
        munmap((*pool).mem, (*pool).shm_size);
    }
    if !parent.is_null() && !((*parent).mem).is_null() {
        ((*parent).unlock).expect("non-null function pointer")((*parent).locker);
    }
}
#[inline]
unsafe extern "C" fn mln_alloc_free(mut ptr: *mut libc::c_void) {
    if ptr.is_null() {
        return;
    }
    let mut pool: *mut mln_alloc_t = 0 as *mut mln_alloc_t;
    let mut ch: *mut mln_alloc_chunk_t = 0 as *mut mln_alloc_chunk_t;
    let mut am: *mut mln_alloc_mgr_t = 0 as *mut mln_alloc_mgr_t;
    let mut blk: *mut mln_alloc_blk_t = 0 as *mut mln_alloc_blk_t;
    blk = (ptr as mln_u8ptr_t)
        .offset(-(::core::mem::size_of::<mln_alloc_blk_t>() as libc::c_ulong as isize))
        as *mut mln_alloc_blk_t;
    pool = (*blk).pool;
    if !((*pool).mem).is_null() {
        mln_alloc_free_shm(ptr);
        return;
    }
    if (*blk).is_large() != 0 {
        mln_chunk_chain_del(
            &mut (*pool).large_used_head,
            &mut (*pool).large_used_tail,
            (*blk).chunk,
        );
        if !((*pool).parent).is_null() {
            if !((*(*pool).parent).mem).is_null() {
                if ((*(*pool).parent).lock)
                    .expect("non-null function pointer")((*(*pool).parent).locker)
                    != 0 as libc::c_int
                {
                    return;
                }
            }
            mln_alloc_free((*blk).chunk as *mut libc::c_void);
            if !((*(*pool).parent).mem).is_null() {
                ((*(*pool).parent).unlock)
                    .expect("non-null function pointer")((*(*pool).parent).locker);
            }
        } else {
            free((*blk).chunk as *mut libc::c_void);
        }
        return;
    }
    ch = (*blk).chunk;
    am = (*ch).mgr;
    (*blk).set_in_used(0 as libc::c_int as mln_size_t);
    mln_blk_chain_del(&mut (*am).used_head, &mut (*am).used_tail, blk);
    mln_blk_chain_add(&mut (*am).free_head, &mut (*am).free_tail, blk);
    (*ch).refer = ((*ch).refer).wrapping_sub(1);
    if (*ch).refer == 0
        && {
            (*ch).count = ((*ch).count).wrapping_add(1);
            (*ch).count > 1023 as libc::c_int as libc::c_ulong
        }
    {
        let mut blks: *mut *mut mln_alloc_blk_t = ((*ch).blks).as_mut_ptr();
        while !(*blks).is_null() {
            let fresh0 = blks;
            blks = blks.offset(1);
            mln_blk_chain_del(&mut (*am).free_head, &mut (*am).free_tail, *fresh0);
        }
        mln_chunk_chain_del(&mut (*am).chunk_head, &mut (*am).chunk_tail, ch);
        if !((*pool).parent).is_null() {
            if !((*(*pool).parent).mem).is_null() {
                if ((*(*pool).parent).lock)
                    .expect("non-null function pointer")((*(*pool).parent).locker)
                    != 0 as libc::c_int
                {
                    return;
                }
            }
            mln_alloc_free(ch as *mut libc::c_void);
            if !((*(*pool).parent).mem).is_null() {
                ((*(*pool).parent).unlock)
                    .expect("non-null function pointer")((*(*pool).parent).locker);
            }
        } else {
            free(ch as *mut libc::c_void);
        }
    }
}
#[inline]
unsafe extern "C" fn mln_chunk_chain_del(
    mut head: *mut *mut mln_alloc_chunk_t,
    mut tail: *mut *mut mln_alloc_chunk_t,
    mut node: *mut mln_alloc_chunk_t,
) {
    if *head == node {
        if *tail == node {
            *tail = 0 as *mut mln_alloc_chunk_t;
            *head = *tail;
        } else {
            *head = (*node).next;
            (**head).prev = 0 as *mut mln_alloc_chunk_s;
        }
    } else if *tail == node {
        *tail = (*node).prev;
        (**tail).next = 0 as *mut mln_alloc_chunk_s;
    } else {
        (*(*node).prev).next = (*node).next;
        (*(*node).next).prev = (*node).prev;
    }
    (*node).next = 0 as *mut mln_alloc_chunk_s;
    (*node).prev = (*node).next;
}
#[inline]
unsafe extern "C" fn mln_alloc_free_shm(mut ptr: *mut libc::c_void) {
    let mut blk: *mut mln_alloc_blk_t = 0 as *mut mln_alloc_blk_t;
    let mut as_0: *mut mln_alloc_shm_t = 0 as *mut mln_alloc_shm_t;
    let mut Boff: mln_off_t = 0;
    let mut boff: mln_off_t = 0;
    let mut p: mln_u8ptr_t = 0 as *mut libc::c_uchar;
    let mut pend: mln_u8ptr_t = 0 as *mut libc::c_uchar;
    let mut i: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    blk = (ptr as mln_u8ptr_t)
        .offset(-(::core::mem::size_of::<mln_alloc_blk_t>() as libc::c_ulong as isize))
        as *mut mln_alloc_blk_t;
    as_0 = (*blk).chunk as *mut mln_alloc_shm_t;
    if (*as_0).large() == 0 {
        Boff = ((*blk).padding() as libc::c_int >> 8 as libc::c_int
            & 0xffff as libc::c_int) as mln_off_t;
        boff = ((*blk).padding() as libc::c_int & 0xff as libc::c_int) as mln_off_t;
        (*blk).set_in_used(0 as libc::c_int as mln_size_t);
        p = ((*as_0).bitmap).as_mut_ptr().offset(Boff as isize);
        n = ((*blk).blk_size)
            .wrapping_add(::core::mem::size_of::<mln_alloc_blk_t>() as libc::c_ulong)
            .wrapping_add(64 as libc::c_int as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong)
            .wrapping_div(64 as libc::c_int as libc::c_ulong) as libc::c_int;
        i = boff as libc::c_int;
        pend = ((*as_0).bitmap).as_mut_ptr().offset(4096 as libc::c_int as isize);
        while p < pend {
            *p = (*p as libc::c_int
                & !((1 as libc::c_int as mln_u8_t as libc::c_int) << i))
                as libc::c_uchar;
            (*as_0).nfree = ((*as_0).nfree).wrapping_add(1);
            (*as_0).nfree;
            n -= 1;
            if n <= 0 as libc::c_int {
                break;
            }
            i -= 1;
            if i < 0 as libc::c_int {
                i = 7 as libc::c_int;
                p = p.offset(1);
                p;
            }
        }
    }
    if (*as_0).large() as libc::c_int != 0 || (*as_0).nfree == (*as_0).base() {
        mln_alloc_shm_chain_del(
            &mut (*(*as_0).pool).shm_head,
            &mut (*(*as_0).pool).shm_tail,
            as_0,
        );
    }
}
#[inline]
unsafe extern "C" fn mln_alloc_shm_chain_del(
    mut head: *mut *mut mln_alloc_shm_t,
    mut tail: *mut *mut mln_alloc_shm_t,
    mut node: *mut mln_alloc_shm_t,
) {
    if *head == node {
        if *tail == node {
            *tail = 0 as *mut mln_alloc_shm_t;
            *head = *tail;
        } else {
            *head = (*node).next;
            (**head).prev = 0 as *mut mln_alloc_shm_s;
        }
    } else if *tail == node {
        *tail = (*node).prev;
        (**tail).next = 0 as *mut mln_alloc_shm_s;
    } else {
        (*(*node).prev).next = (*node).next;
        (*(*node).next).prev = (*node).prev;
    }
    (*node).next = 0 as *mut mln_alloc_shm_s;
    (*node).prev = (*node).next;
}
#[inline]
unsafe extern "C" fn mln_lang_sym_scope_chain_del(
    mut head: *mut *mut mln_lang_symbol_node_t,
    mut tail: *mut *mut mln_lang_symbol_node_t,
    mut node: *mut mln_lang_symbol_node_t,
) {
    if *head == node {
        if *tail == node {
            *tail = 0 as *mut mln_lang_symbol_node_t;
            *head = *tail;
        } else {
            *head = (*node).scope_next;
            (**head).scope_prev = 0 as *mut mln_lang_symbol_node_s;
        }
    } else if *tail == node {
        *tail = (*node).scope_prev;
        (**tail).scope_next = 0 as *mut mln_lang_symbol_node_s;
    } else {
        (*(*node).scope_prev).scope_next = (*node).scope_next;
        (*(*node).scope_next).scope_prev = (*node).scope_prev;
    }
    (*node).scope_next = 0 as *mut mln_lang_symbol_node_s;
    (*node).scope_prev = (*node).scope_next;
}
#[inline]
unsafe extern "C" fn mln_lang_sym_scope_chain_add(
    mut head: *mut *mut mln_lang_symbol_node_t,
    mut tail: *mut *mut mln_lang_symbol_node_t,
    mut node: *mut mln_lang_symbol_node_t,
) {
    (*node).scope_next = 0 as *mut mln_lang_symbol_node_s;
    if (*head).is_null() {
        *head = node;
    } else {
        (**tail).scope_next = node;
    }
    (*node).scope_prev = *tail;
    *tail = node;
}
#[inline]
unsafe extern "C" fn mln_lang_sym_chain_add(
    mut head: *mut *mut mln_lang_symbol_node_t,
    mut tail: *mut *mut mln_lang_symbol_node_t,
    mut node: *mut mln_lang_symbol_node_t,
) {
    (*node).next = 0 as *mut mln_lang_symbol_node_s;
    if (*head).is_null() {
        *head = node;
    } else {
        (**tail).next = node;
    }
    (*node).prev = *tail;
    *tail = node;
}
#[inline]
unsafe extern "C" fn mln_lang_sym_chain_del(
    mut head: *mut *mut mln_lang_symbol_node_t,
    mut tail: *mut *mut mln_lang_symbol_node_t,
    mut node: *mut mln_lang_symbol_node_t,
) {
    if *head == node {
        if *tail == node {
            *tail = 0 as *mut mln_lang_symbol_node_t;
            *head = *tail;
        } else {
            *head = (*node).next;
            (**head).prev = 0 as *mut mln_lang_symbol_node_s;
        }
    } else if *tail == node {
        *tail = (*node).prev;
        (**tail).next = 0 as *mut mln_lang_symbol_node_s;
    } else {
        (*(*node).prev).next = (*node).next;
        (*(*node).next).prev = (*node).prev;
    }
    (*node).next = 0 as *mut mln_lang_symbol_node_s;
    (*node).prev = (*node).next;
}
#[inline]
unsafe extern "C" fn mln_lang_ast_cache_chain_del(
    mut head: *mut *mut mln_lang_ast_cache_t,
    mut tail: *mut *mut mln_lang_ast_cache_t,
    mut node: *mut mln_lang_ast_cache_t,
) {
    if *head == node {
        if *tail == node {
            *tail = 0 as *mut mln_lang_ast_cache_t;
            *head = *tail;
        } else {
            *head = (*node).next;
            (**head).prev = 0 as *mut mln_lang_ast_cache_s;
        }
    } else if *tail == node {
        *tail = (*node).prev;
        (**tail).next = 0 as *mut mln_lang_ast_cache_s;
    } else {
        (*(*node).prev).next = (*node).next;
        (*(*node).next).prev = (*node).prev;
    }
    (*node).next = 0 as *mut mln_lang_ast_cache_s;
    (*node).prev = (*node).next;
}
#[inline]
unsafe extern "C" fn mln_lang_ast_cache_chain_add(
    mut head: *mut *mut mln_lang_ast_cache_t,
    mut tail: *mut *mut mln_lang_ast_cache_t,
    mut node: *mut mln_lang_ast_cache_t,
) {
    (*node).next = 0 as *mut mln_lang_ast_cache_s;
    if (*head).is_null() {
        *head = node;
    } else {
        (**tail).next = node;
    }
    (*node).prev = *tail;
    *tail = node;
}
#[inline]
unsafe extern "C" fn mln_lang_ctx_chain_add(
    mut head: *mut *mut mln_lang_ctx_t,
    mut tail: *mut *mut mln_lang_ctx_t,
    mut node: *mut mln_lang_ctx_t,
) {
    (*node).next = 0 as *mut mln_lang_ctx_s;
    if (*head).is_null() {
        *head = node;
    } else {
        (**tail).next = node;
    }
    (*node).prev = *tail;
    *tail = node;
}
#[inline]
unsafe extern "C" fn mln_lang_ctx_chain_del(
    mut head: *mut *mut mln_lang_ctx_t,
    mut tail: *mut *mut mln_lang_ctx_t,
    mut node: *mut mln_lang_ctx_t,
) {
    if *head == node {
        if *tail == node {
            *tail = 0 as *mut mln_lang_ctx_t;
            *head = *tail;
        } else {
            *head = (*node).next;
            (**head).prev = 0 as *mut mln_lang_ctx_s;
        }
    } else if *tail == node {
        *tail = (*node).prev;
        (**tail).next = 0 as *mut mln_lang_ctx_s;
    } else {
        (*(*node).prev).next = (*node).next;
        (*(*node).next).prev = (*node).prev;
    }
    (*node).next = 0 as *mut mln_lang_ctx_s;
    (*node).prev = (*node).next;
}
#[no_mangle]
pub static mut mln_lang_methods: [*mut mln_lang_method_t; 9] = unsafe {
    [
        &mln_lang_nil_oprs as *const mln_lang_method_t as *mut mln_lang_method_t,
        &mln_lang_int_oprs as *const mln_lang_method_t as *mut mln_lang_method_t,
        &mln_lang_bool_oprs as *const mln_lang_method_t as *mut mln_lang_method_t,
        &mln_lang_real_oprs as *const mln_lang_method_t as *mut mln_lang_method_t,
        &mln_lang_str_oprs as *const mln_lang_method_t as *mut mln_lang_method_t,
        &mln_lang_obj_oprs as *const mln_lang_method_t as *mut mln_lang_method_t,
        &mln_lang_func_oprs as *const mln_lang_method_t as *mut mln_lang_method_t,
        &mln_lang_array_oprs as *const mln_lang_method_t as *mut mln_lang_method_t,
        0 as *const mln_lang_method_t as *mut mln_lang_method_t,
    ]
};
#[no_mangle]
pub static mut mln_lang_stack_map: [mln_lang_stack_handler; 25] = unsafe {
    [
        Some(
            mln_lang_stack_handler_stm as unsafe extern "C" fn(*mut mln_lang_ctx_t) -> (),
        ),
        Some(
            mln_lang_stack_handler_funcdef
                as unsafe extern "C" fn(*mut mln_lang_ctx_t) -> (),
        ),
        Some(
            mln_lang_stack_handler_set as unsafe extern "C" fn(*mut mln_lang_ctx_t) -> (),
        ),
        Some(
            mln_lang_stack_handler_setstm
                as unsafe extern "C" fn(*mut mln_lang_ctx_t) -> (),
        ),
        Some(
            mln_lang_stack_handler_block
                as unsafe extern "C" fn(*mut mln_lang_ctx_t) -> (),
        ),
        Some(
            mln_lang_stack_handler_while
                as unsafe extern "C" fn(*mut mln_lang_ctx_t) -> (),
        ),
        Some(
            mln_lang_stack_handler_switch
                as unsafe extern "C" fn(*mut mln_lang_ctx_t) -> (),
        ),
        Some(
            mln_lang_stack_handler_switchstm
                as unsafe extern "C" fn(*mut mln_lang_ctx_t) -> (),
        ),
        Some(
            mln_lang_stack_handler_for as unsafe extern "C" fn(*mut mln_lang_ctx_t) -> (),
        ),
        Some(
            mln_lang_stack_handler_if as unsafe extern "C" fn(*mut mln_lang_ctx_t) -> (),
        ),
        Some(
            mln_lang_stack_handler_exp as unsafe extern "C" fn(*mut mln_lang_ctx_t) -> (),
        ),
        Some(
            mln_lang_stack_handler_assign
                as unsafe extern "C" fn(*mut mln_lang_ctx_t) -> (),
        ),
        Some(
            mln_lang_stack_handler_logiclow
                as unsafe extern "C" fn(*mut mln_lang_ctx_t) -> (),
        ),
        Some(
            mln_lang_stack_handler_logichigh
                as unsafe extern "C" fn(*mut mln_lang_ctx_t) -> (),
        ),
        Some(
            mln_lang_stack_handler_relativelow
                as unsafe extern "C" fn(*mut mln_lang_ctx_t) -> (),
        ),
        Some(
            mln_lang_stack_handler_relativehigh
                as unsafe extern "C" fn(*mut mln_lang_ctx_t) -> (),
        ),
        Some(
            mln_lang_stack_handler_move
                as unsafe extern "C" fn(*mut mln_lang_ctx_t) -> (),
        ),
        Some(
            mln_lang_stack_handler_addsub
                as unsafe extern "C" fn(*mut mln_lang_ctx_t) -> (),
        ),
        Some(
            mln_lang_stack_handler_muldiv
                as unsafe extern "C" fn(*mut mln_lang_ctx_t) -> (),
        ),
        Some(
            mln_lang_stack_handler_not as unsafe extern "C" fn(*mut mln_lang_ctx_t) -> (),
        ),
        Some(
            mln_lang_stack_handler_suffix
                as unsafe extern "C" fn(*mut mln_lang_ctx_t) -> (),
        ),
        Some(
            mln_lang_stack_handler_locate
                as unsafe extern "C" fn(*mut mln_lang_ctx_t) -> (),
        ),
        Some(
            mln_lang_stack_handler_spec
                as unsafe extern "C" fn(*mut mln_lang_ctx_t) -> (),
        ),
        Some(
            mln_lang_stack_handler_factor
                as unsafe extern "C" fn(*mut mln_lang_ctx_t) -> (),
        ),
        Some(
            mln_lang_stack_handler_elemlist
                as unsafe extern "C" fn(*mut mln_lang_ctx_t) -> (),
        ),
    ]
};
#[no_mangle]
pub unsafe extern "C" fn mln_lang_new(
    mut ev: *mut mln_event_t,
    mut signal: mln_lang_run_ctl_t,
    mut clear: mln_lang_run_ctl_t,
) -> *mut mln_lang_t {
    let mut lang: *mut mln_lang_t = 0 as *mut mln_lang_t;
    let mut rbattr: mln_rbtree_attr = mln_rbtree_attr {
        pool: 0 as *mut libc::c_void,
        pool_alloc: None,
        pool_free: None,
        cmp: None,
        data_free: None,
    };
    let mut pool: *mut mln_alloc_t = 0 as *mut mln_alloc_t;
    pool = mln_alloc_init(0 as *mut mln_alloc_t);
    if pool.is_null() {
        return 0 as *mut mln_lang_t;
    }
    lang = mln_alloc_m(pool, ::core::mem::size_of::<mln_lang_t>() as libc::c_ulong)
        as *mut mln_lang_t;
    if lang.is_null() {
        mln_alloc_destroy(pool);
        return 0 as *mut mln_lang_t;
    }
    (*lang).ev = ev;
    (*lang).pool = pool;
    (*lang).run_tail = 0 as *mut mln_lang_ctx_t;
    (*lang).run_head = (*lang).run_tail;
    (*lang).wait_tail = 0 as *mut mln_lang_ctx_t;
    (*lang).wait_head = (*lang).wait_tail;
    (*lang).resource_set = 0 as *mut mln_rbtree_t;
    (*lang).cache_head = 0 as *mut mln_lang_ast_cache_t;
    (*lang).cache_tail = 0 as *mut mln_lang_ast_cache_t;
    (*lang).shift_table = 0 as *mut libc::c_void;
    (*lang).set_wait(0 as libc::c_int as mln_u64_t);
    (*lang).set_quit(0 as libc::c_int as mln_u64_t);
    (*lang).set_cache(0 as libc::c_int as mln_u64_t);
    (*lang).signal = signal;
    (*lang)
        .launcher = Some(
        mln_lang_run_handler
            as unsafe extern "C" fn(
                *mut mln_event_t,
                libc::c_int,
                *mut libc::c_void,
            ) -> (),
    );
    (*lang).clear = clear;
    (*lang).alias_set = 0 as *mut mln_rbtree_t;
    if pthread_mutex_init(&mut (*lang).lock, 0 as *const pthread_mutexattr_t)
        != 0 as libc::c_int
    {
        mln_alloc_destroy(pool);
        return 0 as *mut mln_lang_t;
    }
    rbattr.pool = pool as *mut libc::c_void;
    rbattr
        .pool_alloc = ::core::mem::transmute::<
        Option::<
            unsafe extern "C" fn(*mut mln_alloc_t, mln_size_t) -> *mut libc::c_void,
        >,
        rbtree_pool_alloc_handler,
    >(
        Some(
            mln_alloc_m
                as unsafe extern "C" fn(
                    *mut mln_alloc_t,
                    mln_size_t,
                ) -> *mut libc::c_void,
        ),
    );
    rbattr
        .pool_free = ::core::mem::transmute::<
        Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
        rbtree_pool_free_handler,
    >(Some(mln_alloc_free as unsafe extern "C" fn(*mut libc::c_void) -> ()));
    rbattr
        .cmp = ::core::mem::transmute::<
        Option::<
            unsafe extern "C" fn(
                *const mln_lang_resource_t,
                *const mln_lang_resource_t,
            ) -> libc::c_int,
        >,
        rbtree_cmp,
    >(
        Some(
            mln_lang_resource_cmp
                as unsafe extern "C" fn(
                    *const mln_lang_resource_t,
                    *const mln_lang_resource_t,
                ) -> libc::c_int,
        ),
    );
    rbattr
        .data_free = ::core::mem::transmute::<
        Option::<unsafe extern "C" fn(*mut mln_lang_resource_t) -> ()>,
        rbtree_free_data,
    >(
        Some(
            mln_lang_resource_free_handler
                as unsafe extern "C" fn(*mut mln_lang_resource_t) -> (),
        ),
    );
    (*lang).resource_set = mln_rbtree_new(&mut rbattr);
    if ((*lang).resource_set).is_null() {
        mln_lang_free(lang);
        return 0 as *mut mln_lang_t;
    }
    (*lang).shift_table = mln_lang_ast_parser_generate();
    if ((*lang).shift_table).is_null() {
        mln_lang_free(lang);
        return 0 as *mut mln_lang_t;
    }
    rbattr
        .cmp = ::core::mem::transmute::<
        Option::<
            unsafe extern "C" fn(*mut mln_lang_ctx_t, *mut mln_lang_ctx_t) -> libc::c_int,
        >,
        rbtree_cmp,
    >(
        Some(
            mln_lang_ctx_alias_cmp
                as unsafe extern "C" fn(
                    *mut mln_lang_ctx_t,
                    *mut mln_lang_ctx_t,
                ) -> libc::c_int,
        ),
    );
    rbattr.data_free = None;
    (*lang).alias_set = mln_rbtree_new(&mut rbattr);
    if ((*lang).alias_set).is_null() {
        mln_lang_free(lang);
        return 0 as *mut mln_lang_t;
    }
    return lang;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_free(mut lang: *mut mln_lang_t) {
    if lang.is_null() {
        return;
    }
    let mut pool: *mut mln_alloc_t = (*lang).pool;
    pthread_mutex_lock(&mut (*lang).lock);
    if (*lang).wait() != 0 {
        (*lang).set_quit(1 as libc::c_int as mln_u64_t);
        pthread_mutex_unlock(&mut (*lang).lock);
        return;
    }
    let mut ctx: *mut mln_lang_ctx_t = 0 as *mut mln_lang_ctx_t;
    let mut cache: *mut mln_lang_ast_cache_t = 0 as *mut mln_lang_ast_cache_t;
    loop {
        ctx = (*lang).run_head;
        if ctx.is_null() {
            break;
        }
        mln_lang_ctx_chain_del(&mut (*lang).run_head, &mut (*lang).run_tail, ctx);
        mln_lang_ctx_free(ctx);
    }
    loop {
        ctx = (*lang).wait_head;
        if ctx.is_null() {
            break;
        }
        mln_lang_ctx_chain_del(&mut (*lang).wait_head, &mut (*lang).wait_tail, ctx);
        mln_lang_ctx_free(ctx);
    }
    if !((*lang).resource_set).is_null() {
        mln_rbtree_free((*lang).resource_set);
    }
    if !((*lang).shift_table).is_null() {
        mln_lang_ast_parser_destroy((*lang).shift_table);
    }
    loop {
        cache = (*lang).cache_head;
        if cache.is_null() {
            break;
        }
        mln_lang_ast_cache_chain_del(
            &mut (*lang).cache_head,
            &mut (*lang).cache_tail,
            cache,
        );
        mln_lang_ast_cache_free(cache);
    }
    if !((*lang).alias_set).is_null() {
        mln_rbtree_free((*lang).alias_set);
    }
    pthread_mutex_unlock(&mut (*lang).lock);
    pthread_mutex_destroy(&mut (*lang).lock);
    mln_alloc_free(lang as *mut libc::c_void);
    mln_alloc_destroy(pool);
}
unsafe extern "C" fn mln_lang_run_handler(
    mut ev: *mut mln_event_t,
    mut fd: libc::c_int,
    mut data: *mut libc::c_void,
) {
    let mut n: libc::c_int = 0;
    let mut lang: *mut mln_lang_t = data as *mut mln_lang_t;
    let mut ctx: *mut mln_lang_ctx_t = 0 as *mut mln_lang_ctx_t;
    let mut node: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
    if pthread_mutex_trylock(&mut (*lang).lock) != 0 as libc::c_int {
        return;
    }
    ctx = (*lang).run_head;
    if !ctx.is_null() && (*ctx).owner == 0 as libc::c_int as libc::c_ulong {
        let mut current_block_19: u64;
        mln_lang_ctx_chain_del(&mut (*lang).run_head, &mut (*lang).run_tail, ctx);
        mln_lang_ctx_chain_add(&mut (*lang).run_head, &mut (*lang).run_tail, ctx);
        (*ctx).owner = pthread_self();
        pthread_mutex_unlock(&mut (*lang).lock);
        n = 0 as libc::c_int;
        loop {
            if !(n < 1700 as libc::c_int) {
                current_block_19 = 7149356873433890176;
                break;
            }
            node = (*ctx).run_stack_top;
            if !node.is_null() {
                (mln_lang_stack_map[(*node).type_0 as usize])
                    .expect("non-null function pointer")(ctx);
                if (*ctx).ref_0 != 0 {
                    current_block_19 = 7149356873433890176;
                    break;
                }
                if !((*ctx).quit() != 0) {
                    n += 1;
                    n;
                    continue;
                }
            }
            if ((*ctx).return_handler).is_some() {
                ((*ctx).return_handler).expect("non-null function pointer")(ctx);
            }
            mln_lang_job_free(ctx);
            pthread_mutex_lock(&mut (*lang).lock);
            current_block_19 = 4258578298084173086;
            break;
        }
        match current_block_19 {
            7149356873433890176 => {
                if (*ctx).ref_0 == 0
                    && (((*ctx).run_stack_top).is_null()
                        || (*(*ctx).run_stack_top).type_0 as libc::c_uint
                            != M_LSNT_ASSIGN as libc::c_int as libc::c_uint)
                {
                    mln_gc_collect((*ctx).gc, ctx as *mut libc::c_void);
                }
                pthread_mutex_lock(&mut (*lang).lock);
                (*ctx).owner = 0 as libc::c_int as pthread_t;
            }
            _ => {}
        }
        if !((*lang).run_head).is_null() {
            ((*lang).signal).expect("non-null function pointer")(lang);
        }
    } else {
        ((*lang).clear).expect("non-null function pointer")(lang);
    }
    pthread_mutex_unlock(&mut (*lang).lock);
}
#[inline]
unsafe extern "C" fn mln_lang_ast_cache_new(
    mut lang: *mut mln_lang_t,
    mut stm: *mut mln_lang_stm_t,
    mut code: *mut mln_string_t,
    mut timestamp: mln_u64_t,
) -> *mut mln_lang_ast_cache_t {
    let mut cache: *mut mln_lang_ast_cache_t = 0 as *mut mln_lang_ast_cache_t;
    cache = mln_alloc_m(
        (*lang).pool,
        ::core::mem::size_of::<mln_lang_ast_cache_t>() as libc::c_ulong,
    ) as *mut mln_lang_ast_cache_t;
    if cache.is_null() {
        return 0 as *mut mln_lang_ast_cache_t;
    }
    (*cache).stm = stm;
    (*cache).code = mln_string_pool_dup((*lang).pool, code);
    if ((*cache).code).is_null() {
        mln_alloc_free(cache as *mut libc::c_void);
        return 0 as *mut mln_lang_ast_cache_t;
    }
    (*cache).set_ref_0(0 as libc::c_int as mln_u64_t);
    (*cache).set_expire(0 as libc::c_int as mln_u64_t);
    (*cache).timestamp = timestamp;
    (*cache).next = 0 as *mut mln_lang_ast_cache_s;
    (*cache).prev = (*cache).next;
    return cache;
}
#[inline]
unsafe extern "C" fn mln_lang_ast_cache_free(mut cache: *mut mln_lang_ast_cache_t) {
    if cache.is_null() {
        return;
    }
    if !((*cache).stm).is_null() {
        mln_lang_ast_free((*cache).stm as *mut libc::c_void);
    }
    if !((*cache).code).is_null() {
        let mut __s: *mut mln_string_t = (*cache).code;
        if !__s.is_null() {
            let ref mut fresh1 = (*__s).ref_0();
            let fresh2 = *fresh1;
            *fresh1 = (*fresh1).wrapping_sub(1);
            if fresh2 <= 1 as libc::c_int as libc::c_ulong {
                if (*__s).data_ref() == 0 && !((*__s).data).is_null() {
                    if (*__s).pool() != 0 {
                        mln_alloc_free((*__s).data as *mut libc::c_void);
                    } else {
                        free((*__s).data as *mut libc::c_void);
                    }
                }
                if (*__s).pool() != 0 {
                    mln_alloc_free(__s as *mut libc::c_void);
                } else {
                    free(__s as *mut libc::c_void);
                }
            }
        }
    }
    mln_alloc_free(cache as *mut libc::c_void);
}
#[inline]
unsafe extern "C" fn mln_lang_ast_cache_search(
    mut lang: *mut mln_lang_t,
    mut type_0: mln_u32_t,
    mut content: *mut mln_string_t,
) -> *mut mln_lang_ast_cache_t {
    let mut cache: *mut mln_lang_ast_cache_t = 0 as *mut mln_lang_ast_cache_t;
    let mut data: mln_string_t = mln_string_t {
        data: 0 as *mut libc::c_uchar,
        len: 0,
        data_ref_pool_ref_0: [0; 4],
        c2rust_padding: [0; 4],
    };
    let mut buf: mln_u8ptr_t = 0 as mln_u8ptr_t;
    let mut stm: *mut mln_lang_stm_t = 0 as *mut mln_lang_stm_t;
    let mut fd: libc::c_int = 0;
    let mut st: stat = stat {
        st_dev: 0,
        st_ino: 0,
        st_nlink: 0,
        st_mode: 0,
        st_uid: 0,
        st_gid: 0,
        __pad0: 0,
        st_rdev: 0,
        st_size: 0,
        st_blksize: 0,
        st_blocks: 0,
        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },
        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },
        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },
        __glibc_reserved: [0; 3],
    };
    let mut now: mln_u64_t = 0;
    let mut tv: timeval = timeval { tv_sec: 0, tv_usec: 0 };
    gettimeofday(&mut tv, 0 as *mut libc::c_void);
    now = (tv.tv_sec * 1000000 as libc::c_int as libc::c_long + tv.tv_usec) as mln_u64_t;
    if type_0 == 1 as libc::c_int as libc::c_uint {
        if (*content).len >= 1 as libc::c_int as libc::c_ulong
            && (*((*content).data).offset(0 as libc::c_int as isize) as libc::c_int
                == '/' as i32 as mln_u8_t as libc::c_int
                || *((*content).data).offset(0 as libc::c_int as isize) as libc::c_int
                    == '@' as i32 as mln_u8_t as libc::c_int)
        {
            ({
                data.data = (*content).data;
                data.len = (*content).len;
                data.set_data_ref(1 as libc::c_int as mln_uauto_t);
                data.set_pool(0 as libc::c_int as mln_uauto_t);
                data.set_ref_0(1 as libc::c_int as mln_uauto_t);
                &mut data;
                &mut data
            });
        } else {
            fd = mln_lang_ast_file_open(content);
            if fd < 0 as libc::c_int {
                return 0 as *mut mln_lang_ast_cache_t;
            }
            if fstat(fd, &mut st) < 0 as libc::c_int {
                close(fd);
                return 0 as *mut mln_lang_ast_cache_t;
            }
            buf = malloc(st.st_size as libc::c_ulong) as mln_u8ptr_t;
            if buf.is_null() {
                close(fd);
                return 0 as *mut mln_lang_ast_cache_t;
            }
            if read(fd, buf as *mut libc::c_void, st.st_size as size_t) != st.st_size {
                free(buf as *mut libc::c_void);
                close(fd);
                return 0 as *mut mln_lang_ast_cache_t;
            }
            close(fd);
            ({
                data.data = buf;
                data.len = st.st_size as mln_u64_t;
                data.set_data_ref(1 as libc::c_int as mln_uauto_t);
                data.set_pool(0 as libc::c_int as mln_uauto_t);
                data.set_ref_0(1 as libc::c_int as mln_uauto_t);
                &mut data;
                &mut data
            });
        }
    } else {
        data = *content;
    }
    cache = (*lang).cache_head;
    while !cache.is_null() {
        if !((*cache).expire() != 0) {
            if now.wrapping_sub((*cache).timestamp)
                >= 30000000 as libc::c_int as libc::c_ulong
            {
                (*cache).set_expire(1 as libc::c_int as mln_u64_t);
            } else if (*(*cache).code).len == data.len
                && memcmp(
                    (*(*cache).code).data as *const libc::c_void,
                    data.data as *const libc::c_void,
                    data.len,
                ) == 0
            {
                if !buf.is_null() {
                    free(buf as *mut libc::c_void);
                }
                return cache;
            }
        }
        cache = (*cache).next;
    }
    stm = mln_lang_ast_generate((*lang).pool, (*lang).shift_table, content, type_0)
        as *mut mln_lang_stm_t;
    if stm.is_null() {
        if !buf.is_null() {
            free(buf as *mut libc::c_void);
        }
        return 0 as *mut mln_lang_ast_cache_t;
    }
    cache = mln_lang_ast_cache_new(lang, stm, &mut data, now);
    if !buf.is_null() {
        free(buf as *mut libc::c_void);
    }
    if cache.is_null() {
        mln_lang_ast_free(stm as *mut libc::c_void);
        return 0 as *mut mln_lang_ast_cache_t;
    }
    mln_lang_ast_cache_chain_add(
        &mut (*lang).cache_head,
        &mut (*lang).cache_tail,
        cache,
    );
    return cache;
}
#[inline]
unsafe extern "C" fn mln_lang_ctx_new(
    mut lang: *mut mln_lang_t,
    mut data: *mut libc::c_void,
    mut filename: *mut mln_string_t,
    mut type_0: mln_u32_t,
    mut content: *mut mln_string_t,
    mut alias: *mut mln_string_t,
) -> *mut mln_lang_ctx_t {
    let mut ctx: *mut mln_lang_ctx_t = 0 as *mut mln_lang_ctx_t;
    let mut rbattr: mln_rbtree_attr = mln_rbtree_attr {
        pool: 0 as *mut libc::c_void,
        pool_alloc: None,
        pool_free: None,
        cmp: None,
        data_free: None,
    };
    let mut gcattr: mln_gc_attr = mln_gc_attr {
        pool: 0 as *mut mln_alloc_t,
        item_getter: None,
        item_setter: None,
        item_freer: None,
        member_setter: None,
        move_handler: None,
        root_setter: None,
        clean_searcher: None,
        free_handler: None,
    };
    let mut outer_scope: *mut mln_lang_scope_t = 0 as *mut mln_lang_scope_t;
    let mut base_scope: *mut mln_string_t = 0 as *mut mln_string_t;
    let mut tmp: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"__main__\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 9]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    ctx = mln_alloc_m(
        (*lang).pool,
        ::core::mem::size_of::<mln_lang_ctx_t>() as libc::c_ulong,
    ) as *mut mln_lang_ctx_t;
    if ctx.is_null() {
        return 0 as *mut mln_lang_ctx_t;
    }
    (*ctx).lang = lang;
    (*ctx).pool = mln_alloc_init(0 as *mut mln_alloc_t);
    if ((*ctx).pool).is_null() {
        mln_alloc_free(ctx as *mut libc::c_void);
        return 0 as *mut mln_lang_ctx_t;
    }
    (*ctx).fset = mln_fileset_init(67 as libc::c_int as mln_size_t);
    if ((*ctx).fset).is_null() {
        mln_alloc_destroy((*ctx).pool);
        mln_alloc_free(ctx as *mut libc::c_void);
        return 0 as *mut mln_lang_ctx_t;
    }
    (*ctx).data = data;
    if (*lang).cache() != 0 {
        (*ctx).cache = mln_lang_ast_cache_search(lang, type_0, content);
        if ((*ctx).cache).is_null() {
            (*ctx).stm = 0 as *mut mln_lang_stm_t;
        } else {
            (*ctx).stm = (*(*ctx).cache).stm;
            (*(*ctx).cache).set_ref_0((*(*ctx).cache).ref_0() + 1);
            (*(*ctx).cache).ref_0();
        }
    } else {
        (*ctx).cache = 0 as *mut mln_lang_ast_cache_t;
        (*ctx)
            .stm = mln_lang_ast_generate(
            (*ctx).pool,
            (*lang).shift_table,
            content,
            type_0,
        ) as *mut mln_lang_stm_t;
    }
    (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
    (*ctx).scope_top = 0 as *mut mln_lang_scope_t;
    (*ctx).ref_0 = 0 as libc::c_int as mln_u64_t;
    (*ctx).filename = 0 as *mut mln_string_t;
    (*ctx).symbols = 0 as *mut mln_lang_hash_t;
    (*ctx).alias = 0 as *mut mln_string_t;
    rbattr.pool = (*ctx).pool as *mut libc::c_void;
    rbattr
        .pool_alloc = ::core::mem::transmute::<
        Option::<
            unsafe extern "C" fn(*mut mln_alloc_t, mln_size_t) -> *mut libc::c_void,
        >,
        rbtree_pool_alloc_handler,
    >(
        Some(
            mln_alloc_m
                as unsafe extern "C" fn(
                    *mut mln_alloc_t,
                    mln_size_t,
                ) -> *mut libc::c_void,
        ),
    );
    rbattr
        .pool_free = ::core::mem::transmute::<
        Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
        rbtree_pool_free_handler,
    >(Some(mln_alloc_free as unsafe extern "C" fn(*mut libc::c_void) -> ()));
    rbattr
        .cmp = ::core::mem::transmute::<
        Option::<
            unsafe extern "C" fn(
                *const mln_lang_resource_t,
                *const mln_lang_resource_t,
            ) -> libc::c_int,
        >,
        rbtree_cmp,
    >(
        Some(
            mln_lang_resource_cmp
                as unsafe extern "C" fn(
                    *const mln_lang_resource_t,
                    *const mln_lang_resource_t,
                ) -> libc::c_int,
        ),
    );
    rbattr
        .data_free = ::core::mem::transmute::<
        Option::<unsafe extern "C" fn(*mut mln_lang_resource_t) -> ()>,
        rbtree_free_data,
    >(
        Some(
            mln_lang_ctx_resource_free_handler
                as unsafe extern "C" fn(*mut mln_lang_resource_t) -> (),
        ),
    );
    (*ctx).resource_set = mln_rbtree_new(&mut rbattr);
    if ((*ctx).resource_set).is_null() {
        if !((*ctx).cache).is_null() {
            (*(*ctx).cache).set_ref_0((*(*ctx).cache).ref_0() - 1);
            if (*(*ctx).cache).ref_0() == 0 {
                mln_lang_ast_cache_chain_del(
                    &mut (*(*ctx).lang).cache_head,
                    &mut (*(*ctx).lang).cache_tail,
                    (*ctx).cache,
                );
                mln_lang_ast_cache_free((*ctx).cache);
            }
        } else {
            mln_lang_ast_free((*ctx).stm as *mut libc::c_void);
        }
        mln_fileset_destroy((*ctx).fset);
        mln_alloc_destroy((*ctx).pool);
        mln_alloc_free(ctx as *mut libc::c_void);
        return 0 as *mut mln_lang_ctx_t;
    }
    (*ctx).ret_var = 0 as *mut mln_lang_var_t;
    (*ctx).return_handler = None;
    (*ctx).next = 0 as *mut mln_lang_ctx_s;
    (*ctx).prev = (*ctx).next;
    (*ctx).sym_tail = 0 as *mut mln_lang_symbol_node_t;
    (*ctx).sym_head = (*ctx).sym_tail;
    (*ctx).owner = 0 as libc::c_int as pthread_t;
    (*ctx).set_sym_count(0 as libc::c_int as mln_u32_t);
    (*ctx).set_op_str_flag(0 as libc::c_int as mln_u32_t);
    (*ctx).set_op_real_flag((*ctx).op_str_flag());
    (*ctx).set_op_obj_flag((*ctx).op_real_flag());
    (*ctx).set_op_nil_flag((*ctx).op_obj_flag());
    (*ctx).set_op_int_flag((*ctx).op_nil_flag());
    (*ctx).set_op_func_flag((*ctx).op_int_flag());
    (*ctx).set_op_bool_flag((*ctx).op_func_flag());
    (*ctx).set_op_array_flag((*ctx).op_bool_flag());
    (*ctx).set_ret_flag((*ctx).op_array_flag());
    (*ctx).set_quit(0 as libc::c_int as mln_u32_t);
    gcattr.pool = (*ctx).pool;
    gcattr
        .item_getter = ::core::mem::transmute::<
        Option::<unsafe extern "C" fn(*mut mln_lang_gc_item_t) -> *mut libc::c_void>,
        gc_item_getter,
    >(
        Some(
            mln_lang_gc_item_getter
                as unsafe extern "C" fn(*mut mln_lang_gc_item_t) -> *mut libc::c_void,
        ),
    );
    gcattr
        .item_setter = ::core::mem::transmute::<
        Option::<unsafe extern "C" fn(*mut mln_lang_gc_item_t, *mut libc::c_void) -> ()>,
        gc_item_setter,
    >(
        Some(
            mln_lang_gc_item_setter
                as unsafe extern "C" fn(*mut mln_lang_gc_item_t, *mut libc::c_void) -> (),
        ),
    );
    gcattr
        .item_freer = ::core::mem::transmute::<
        Option::<unsafe extern "C" fn(*mut mln_lang_gc_item_t) -> ()>,
        gc_item_freer,
    >(
        Some(
            mln_lang_gc_item_free as unsafe extern "C" fn(*mut mln_lang_gc_item_t) -> (),
        ),
    );
    gcattr
        .member_setter = ::core::mem::transmute::<
        Option::<unsafe extern "C" fn(*mut mln_gc_t, *mut mln_lang_gc_item_t) -> ()>,
        gc_member_setter,
    >(
        Some(
            mln_lang_gc_item_member_setter
                as unsafe extern "C" fn(*mut mln_gc_t, *mut mln_lang_gc_item_t) -> (),
        ),
    );
    gcattr
        .move_handler = ::core::mem::transmute::<
        Option::<unsafe extern "C" fn(*mut mln_gc_t, *mut mln_lang_gc_item_t) -> ()>,
        gc_move_handler,
    >(
        Some(
            mln_lang_gc_item_move_handler
                as unsafe extern "C" fn(*mut mln_gc_t, *mut mln_lang_gc_item_t) -> (),
        ),
    );
    gcattr
        .root_setter = ::core::mem::transmute::<
        Option::<unsafe extern "C" fn(*mut mln_gc_t, *mut mln_lang_ctx_t) -> ()>,
        gc_root_setter,
    >(
        Some(
            mln_lang_gc_item_root_setter
                as unsafe extern "C" fn(*mut mln_gc_t, *mut mln_lang_ctx_t) -> (),
        ),
    );
    gcattr
        .clean_searcher = ::core::mem::transmute::<
        Option::<unsafe extern "C" fn(*mut mln_gc_t, *mut mln_lang_gc_item_t) -> ()>,
        gc_clean_searcher,
    >(
        Some(
            mln_lang_gc_item_clean_searcher
                as unsafe extern "C" fn(*mut mln_gc_t, *mut mln_lang_gc_item_t) -> (),
        ),
    );
    gcattr
        .free_handler = ::core::mem::transmute::<
        Option::<unsafe extern "C" fn(*mut mln_lang_gc_item_t) -> ()>,
        gc_free_handler,
    >(
        Some(
            mln_lang_gc_item_free_handler
                as unsafe extern "C" fn(*mut mln_lang_gc_item_t) -> (),
        ),
    );
    (*ctx).gc = mln_gc_new(&mut gcattr);
    if ((*ctx).gc).is_null() {
        mln_lang_ctx_free(ctx);
        return 0 as *mut mln_lang_ctx_t;
    }
    (*ctx).symbols = mln_lang_hash_new(ctx);
    if ((*ctx).symbols).is_null() {
        mln_lang_ctx_free(ctx);
        return 0 as *mut mln_lang_ctx_t;
    }
    if !((*ctx).stm).is_null() {
        let mut node: *mut mln_lang_stack_node_t = ({
            let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
            if ((*ctx).run_stack_top).is_null() {
                (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                n = (*ctx).run_stack_top;
            } else if (((*ctx).run_stack_top)
                .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                < 1024 as libc::c_int as libc::c_long
            {
                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                n = (*ctx).run_stack_top;
            }
            if !n.is_null() {
                (*n).type_0 = M_LSNT_STM;
                (*n).pos = 0 as *mut libc::c_void;
                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                (*n).ret_var = (*n).ret_var2;
                (*n).set_step(0 as libc::c_int as mln_u32_t);
                (*n).set_call(0 as libc::c_int as mln_u32_t);
                match M_LSNT_STM as libc::c_int {
                    0 => {
                        (*n).data.stm = (*ctx).stm;
                    }
                    1 => {
                        (*n).data.funcdef = (*ctx).stm as *mut mln_lang_funcdef_t;
                    }
                    2 => {
                        (*n).data.set = (*ctx).stm as *mut mln_lang_set_t;
                    }
                    3 => {
                        (*n).data.set_stm = (*ctx).stm as *mut mln_lang_setstm_t;
                    }
                    4 => {
                        (*n).data.block = (*ctx).stm as *mut mln_lang_block_t;
                    }
                    5 => {
                        (*n).data.w = (*ctx).stm as *mut mln_lang_while_t;
                    }
                    6 => {
                        (*n).data.sw = (*ctx).stm as *mut mln_lang_switch_t;
                    }
                    7 => {
                        (*n).data.sw_stm = (*ctx).stm as *mut mln_lang_switchstm_t;
                    }
                    8 => {
                        (*n).data.f = (*ctx).stm as *mut mln_lang_for_t;
                    }
                    9 => {
                        (*n).data.i = (*ctx).stm as *mut mln_lang_if_t;
                    }
                    10 => {
                        (*n).data.exp = (*ctx).stm as *mut mln_lang_exp_t;
                    }
                    11 => {
                        (*n).data.assign = (*ctx).stm as *mut mln_lang_assign_t;
                    }
                    12 => {
                        (*n).data.logiclow = (*ctx).stm as *mut mln_lang_logiclow_t;
                    }
                    13 => {
                        (*n).data.logichigh = (*ctx).stm as *mut mln_lang_logichigh_t;
                        (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                    }
                    14 => {
                        (*n)
                            .data
                            .relativelow = (*ctx).stm as *mut mln_lang_relativelow_t;
                        (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                    }
                    15 => {
                        (*n)
                            .data
                            .relativehigh = (*ctx).stm as *mut mln_lang_relativehigh_t;
                        (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                    }
                    16 => {
                        (*n).data.move_0 = (*ctx).stm as *mut mln_lang_move_t;
                        (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                    }
                    17 => {
                        (*n).data.addsub = (*ctx).stm as *mut mln_lang_addsub_t;
                        (*n).pos = (*n).data.addsub as *mut libc::c_void;
                    }
                    18 => {
                        (*n).data.muldiv = (*ctx).stm as *mut mln_lang_muldiv_t;
                        (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                    }
                    19 => {
                        (*n).data.not = (*ctx).stm as *mut mln_lang_not_t;
                        (*n).pos = (*n).data.not as *mut libc::c_void;
                    }
                    20 => {
                        (*n).data.suffix = (*ctx).stm as *mut mln_lang_suffix_t;
                    }
                    21 => {
                        (*n).data.locate = (*ctx).stm as *mut mln_lang_locate_t;
                    }
                    22 => {
                        (*n).data.spec = (*ctx).stm as *mut mln_lang_spec_t;
                    }
                    23 => {
                        (*n).data.factor = (*ctx).stm as *mut mln_lang_factor_t;
                    }
                    _ => {
                        (*n).data.elemlist = (*ctx).stm as *mut mln_lang_elemlist_t;
                    }
                }
            }
            n
        });
        if node.is_null() {
            mln_lang_ctx_free(ctx);
            return 0 as *mut mln_lang_ctx_t;
        }
    }
    base_scope = mln_string_pool_dup((*ctx).pool, &mut tmp);
    if base_scope.is_null() {
        mln_lang_ctx_free(ctx);
        return 0 as *mut mln_lang_ctx_t;
    }
    outer_scope = ({
        let mut s: *mut mln_lang_scope_t = 0 as *mut mln_lang_scope_t;
        let mut last: *mut mln_lang_scope_t = 0 as *mut mln_lang_scope_t;
        last = (*ctx).scope_top;
        if last.is_null() {
            (*ctx).scope_top = ((*ctx).scopes).as_mut_ptr();
            s = (*ctx).scope_top;
        } else if (last.offset_from(((*ctx).scopes).as_mut_ptr()) as libc::c_long)
            < 1024 as libc::c_int as libc::c_long
        {
            (*ctx).scope_top = ((*ctx).scope_top).offset(1);
            s = (*ctx).scope_top;
        }
        if !s.is_null() {
            (*s).ctx = ctx;
            (*s).type_0 = M_LANG_SCOPE_TYPE_FUNC;
            if !base_scope.is_null() {
                (*s)
                    .name = ({
                    let mut __s: *mut mln_string_t = base_scope;
                    (*__s).set_ref_0((*__s).ref_0() + 1);
                    (*__s).ref_0();
                    __s
                });
            } else {
                (*s).name = 0 as *mut mln_string_t;
            }
            (*s).cur_stack = 0 as *mut mln_lang_stack_node_t;
            (*s).entry = (*ctx).stm;
            (*s)
                .layer = if last.is_null() {
                1 as libc::c_int as libc::c_ulong
            } else {
                ((*last).layer).wrapping_add(1 as libc::c_int as libc::c_ulong)
            };
            (*s).sym_tail = 0 as *mut mln_lang_symbol_node_t;
            (*s).sym_head = (*s).sym_tail;
        }
        s
    });
    if outer_scope.is_null() {
        let mut __s: *mut mln_string_t = base_scope;
        if !__s.is_null() {
            let ref mut fresh3 = (*__s).ref_0();
            let fresh4 = *fresh3;
            *fresh3 = (*fresh3).wrapping_sub(1);
            if fresh4 <= 1 as libc::c_int as libc::c_ulong {
                if (*__s).data_ref() == 0 && !((*__s).data).is_null() {
                    if (*__s).pool() != 0 {
                        mln_alloc_free((*__s).data as *mut libc::c_void);
                    } else {
                        free((*__s).data as *mut libc::c_void);
                    }
                }
                if (*__s).pool() != 0 {
                    mln_alloc_free(__s as *mut libc::c_void);
                } else {
                    free(__s as *mut libc::c_void);
                }
            }
        }
        mln_lang_ctx_free(ctx);
        return 0 as *mut mln_lang_ctx_t;
    }
    let mut __s: *mut mln_string_t = base_scope;
    if !__s.is_null() {
        let ref mut fresh5 = (*__s).ref_0();
        let fresh6 = *fresh5;
        *fresh5 = (*fresh5).wrapping_sub(1);
        if fresh6 <= 1 as libc::c_int as libc::c_ulong {
            if (*__s).data_ref() == 0 && !((*__s).data).is_null() {
                if (*__s).pool() != 0 {
                    mln_alloc_free((*__s).data as *mut libc::c_void);
                } else {
                    free((*__s).data as *mut libc::c_void);
                }
            }
            if (*__s).pool() != 0 {
                mln_alloc_free(__s as *mut libc::c_void);
            } else {
                free(__s as *mut libc::c_void);
            }
        }
    }
    if !filename.is_null() {
        (*ctx).filename = mln_string_pool_dup((*ctx).pool, filename);
        if ((*ctx).filename).is_null() {
            mln_lang_ctx_free(ctx);
            return 0 as *mut mln_lang_ctx_t;
        }
    }
    if mln_lang_internal_func_installer(ctx) < 0 as libc::c_int {
        mln_lang_ctx_free(ctx);
        return 0 as *mut mln_lang_ctx_t;
    }
    if !alias.is_null() {
        let mut rn: *mut mln_rbtree_node_t = 0 as *mut mln_rbtree_node_t;
        (*ctx).alias = mln_string_pool_dup((*ctx).pool, alias);
        if ((*ctx).alias).is_null() {
            mln_lang_ctx_free(ctx);
            return 0 as *mut mln_lang_ctx_t;
        }
        rn = mln_rbtree_search((*(*ctx).lang).alias_set, ctx as *mut libc::c_void);
        if !(rn == &mut (*(*(*ctx).lang).alias_set).nil as *mut mln_rbtree_node_t) {
            mln_lang_ctx_free(ctx);
            return 0 as *mut mln_lang_ctx_t;
        }
        rn = mln_rbtree_node_new((*(*ctx).lang).alias_set, ctx as *mut libc::c_void);
        if rn.is_null() {
            mln_lang_ctx_free(ctx);
            return 0 as *mut mln_lang_ctx_t;
        }
        mln_rbtree_insert((*(*ctx).lang).alias_set, rn);
    }
    return ctx;
}
#[inline]
unsafe extern "C" fn mln_lang_ctx_free(mut ctx: *mut mln_lang_ctx_t) {
    if ctx.is_null() {
        return;
    }
    let mut sym: *mut mln_lang_symbol_node_t = 0 as *mut mln_lang_symbol_node_t;
    let mut rn: *mut mln_rbtree_node_t = 0 as *mut mln_rbtree_node_t;
    if !((*ctx).alias).is_null() {
        rn = mln_rbtree_search((*(*ctx).lang).alias_set, ctx as *mut libc::c_void);
        if !(rn == &mut (*(*(*ctx).lang).alias_set).nil as *mut mln_rbtree_node_t) {
            mln_rbtree_delete((*(*ctx).lang).alias_set, rn);
            mln_rbtree_node_free((*(*ctx).lang).alias_set, rn);
        }
        let mut __s: *mut mln_string_t = (*ctx).alias;
        if !__s.is_null() {
            let ref mut fresh7 = (*__s).ref_0();
            let fresh8 = *fresh7;
            *fresh7 = (*fresh7).wrapping_sub(1);
            if fresh8 <= 1 as libc::c_int as libc::c_ulong {
                if (*__s).data_ref() == 0 && !((*__s).data).is_null() {
                    if (*__s).pool() != 0 {
                        mln_alloc_free((*__s).data as *mut libc::c_void);
                    } else {
                        free((*__s).data as *mut libc::c_void);
                    }
                }
                if (*__s).pool() != 0 {
                    mln_alloc_free(__s as *mut libc::c_void);
                } else {
                    free(__s as *mut libc::c_void);
                }
            }
        }
    }
    if !((*ctx).ret_var).is_null() {
        __mln_lang_var_free((*ctx).ret_var as *mut libc::c_void);
    }
    if !((*ctx).filename).is_null() {
        let mut __s: *mut mln_string_t = (*ctx).filename;
        if !__s.is_null() {
            let ref mut fresh9 = (*__s).ref_0();
            let fresh10 = *fresh9;
            *fresh9 = (*fresh9).wrapping_sub(1);
            if fresh10 <= 1 as libc::c_int as libc::c_ulong {
                if (*__s).data_ref() == 0 && !((*__s).data).is_null() {
                    if (*__s).pool() != 0 {
                        mln_alloc_free((*__s).data as *mut libc::c_void);
                    } else {
                        free((*__s).data as *mut libc::c_void);
                    }
                }
                if (*__s).pool() != 0 {
                    mln_alloc_free(__s as *mut libc::c_void);
                } else {
                    free(__s as *mut libc::c_void);
                }
            }
        }
    }
    while !((*ctx).run_stack_top).is_null() {
        let mut n: *mut mln_lang_stack_node_t = ({
            let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
            if !n_0.is_null()
                && {
                    (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                    (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                }
            {
                (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
            }
            n_0
        });
        if !n.is_null() {
            if !((*n).ret_var).is_null() {
                __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                (*n).ret_var = 0 as *mut mln_lang_var_t;
            }
            if !((*n).ret_var2).is_null() {
                __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
            }
        }
    }
    while !((*ctx).scope_top).is_null() {
        let mut s: *mut mln_lang_scope_t = (*ctx).scope_top;
        let mut sym_0: *mut mln_lang_symbol_node_t = 0 as *mut mln_lang_symbol_node_t;
        if !s.is_null() {
            if !((*s).name).is_null() {
                let mut __s: *mut mln_string_t = (*s).name;
                if !__s.is_null() {
                    let ref mut fresh11 = (*__s).ref_0();
                    let fresh12 = *fresh11;
                    *fresh11 = (*fresh11).wrapping_sub(1);
                    if fresh12 <= 1 as libc::c_int as libc::c_ulong {
                        if (*__s).data_ref() == 0 && !((*__s).data).is_null() {
                            if (*__s).pool() != 0 {
                                mln_alloc_free((*__s).data as *mut libc::c_void);
                            } else {
                                free((*__s).data as *mut libc::c_void);
                            }
                        }
                        if (*__s).pool() != 0 {
                            mln_alloc_free(__s as *mut libc::c_void);
                        } else {
                            free(__s as *mut libc::c_void);
                        }
                    }
                }
            }
            loop {
                sym_0 = (*s).sym_head;
                if sym_0.is_null() {
                    break;
                }
                mln_lang_sym_scope_chain_del(
                    &mut (*s).sym_head,
                    &mut (*s).sym_tail,
                    sym_0,
                );
                mln_lang_sym_chain_del(
                    &mut (*(*sym_0).bucket).head,
                    &mut (*(*sym_0).bucket).tail,
                    sym_0,
                );
                mln_lang_symbol_node_free(sym_0 as *mut libc::c_void);
            }
            (*ctx).scope_top = ((*ctx).scope_top).offset(-1);
            if (*ctx).scope_top < ((*ctx).scopes).as_mut_ptr() {
                (*ctx).scope_top = 0 as *mut mln_lang_scope_t;
            }
        }
    }
    loop {
        sym = (*ctx).sym_head;
        if sym.is_null() {
            break;
        }
        mln_lang_sym_chain_del(&mut (*ctx).sym_head, &mut (*ctx).sym_tail, sym);
        (*sym).ctx = 0 as *mut mln_lang_ctx_t;
        mln_lang_symbol_node_free(sym as *mut libc::c_void);
    }
    if !((*ctx).symbols).is_null() {
        mln_lang_hash_free((*ctx).symbols);
    }
    if !((*ctx).gc).is_null() {
        mln_gc_free((*ctx).gc);
    }
    if !((*ctx).resource_set).is_null() {
        mln_rbtree_free((*ctx).resource_set);
    }
    if !((*ctx).stm).is_null() {
        if !((*ctx).cache).is_null() {
            (*(*ctx).cache).set_ref_0((*(*ctx).cache).ref_0() - 1);
            if (*(*ctx).cache).ref_0() == 0 {
                mln_lang_ast_cache_chain_del(
                    &mut (*(*ctx).lang).cache_head,
                    &mut (*(*ctx).lang).cache_tail,
                    (*ctx).cache,
                );
                mln_lang_ast_cache_free((*ctx).cache);
            }
        } else {
            mln_lang_ast_free((*ctx).stm as *mut libc::c_void);
        }
    }
    mln_fileset_destroy((*ctx).fset);
    mln_alloc_destroy((*ctx).pool);
    mln_alloc_free(ctx as *mut libc::c_void);
}
unsafe extern "C" fn mln_lang_ctx_alias_cmp(
    mut ctx1: *mut mln_lang_ctx_t,
    mut ctx2: *mut mln_lang_ctx_t,
) -> libc::c_int {
    return mln_string_strcmp((*ctx1).alias, (*ctx2).alias);
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_ctx_suspend(mut ctx: *mut mln_lang_ctx_t) {
    if (*ctx).ref_0 != 0 {
        return;
    }
    (*ctx).ref_0 = ((*ctx).ref_0).wrapping_add(1);
    (*ctx).ref_0;
    mln_lang_ctx_chain_del(
        &mut (*(*ctx).lang).run_head,
        &mut (*(*ctx).lang).run_tail,
        ctx,
    );
    mln_lang_ctx_chain_add(
        &mut (*(*ctx).lang).wait_head,
        &mut (*(*ctx).lang).wait_tail,
        ctx,
    );
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_ctx_continue(mut ctx: *mut mln_lang_ctx_t) {
    if (*ctx).ref_0 == 0 {
        return;
    }
    (*ctx).ref_0 = ((*ctx).ref_0).wrapping_sub(1);
    (*ctx).ref_0;
    mln_lang_ctx_chain_del(
        &mut (*(*ctx).lang).wait_head,
        &mut (*(*ctx).lang).wait_tail,
        ctx,
    );
    mln_lang_ctx_chain_add(
        &mut (*(*ctx).lang).run_head,
        &mut (*(*ctx).lang).run_tail,
        ctx,
    );
    if !((*(*ctx).lang).run_head).is_null() {
        ((*(*ctx).lang).signal).expect("non-null function pointer")((*ctx).lang);
    } else {
        ((*(*ctx).lang).clear).expect("non-null function pointer")((*ctx).lang);
    };
}
#[inline]
unsafe extern "C" fn mln_lang_ctx_get_class(
    mut ctx: *mut mln_lang_ctx_t,
) -> *mut mln_lang_set_detail_t {
    let mut hb: *mut mln_lang_hash_bucket_t = 0 as *mut mln_lang_hash_bucket_t;
    let mut s: *mut mln_string_t = 0 as *mut mln_string_t;
    let mut name: *mut mln_string_t = 0 as *mut mln_string_t;
    let mut tmp: mln_lang_symbol_node_t = mln_lang_symbol_node_t {
        symbol: 0 as *mut mln_string_t,
        ctx: 0 as *mut mln_lang_ctx_t,
        type_0: M_LANG_SYMBOL_VAR,
        data: C2RustUnnamed_9 {
            var: 0 as *mut mln_lang_var_t,
        },
        layer: 0,
        bucket: 0 as *mut mln_lang_hash_bucket_t,
        prev: 0 as *mut mln_lang_symbol_node_s,
        next: 0 as *mut mln_lang_symbol_node_s,
        scope_prev: 0 as *mut mln_lang_symbol_node_s,
        scope_next: 0 as *mut mln_lang_symbol_node_s,
    };
    let mut sym: *mut mln_lang_symbol_node_t = 0 as *mut mln_lang_symbol_node_t;
    if (*(*ctx).scope_top).type_0 as libc::c_uint
        != M_LANG_SCOPE_TYPE_SET as libc::c_int as libc::c_uint
    {
        return 0 as *mut mln_lang_set_detail_t;
    }
    name = (*(*ctx).scope_top).name;
    tmp.symbol = name;
    tmp.layer = (*((*ctx).scope_top).offset(-(1 as libc::c_int as isize))).layer;
    hb = mln_lang_hash_get_bucket((*ctx).symbols, &mut tmp);
    sym = (*hb).tail;
    while !sym.is_null() {
        s = (*sym).symbol;
        if !((*s).len != (*name).len || (*sym).layer != tmp.layer) {
            if memcmp(
                (*s).data as *const libc::c_void,
                (*name).data as *const libc::c_void,
                (*s).len,
            ) == 0
            {
                return (*sym).data.set;
            }
        }
        sym = (*sym).prev;
    }
    return 0 as *mut mln_lang_set_detail_t;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_ctx_global_var_add(
    mut ctx: *mut mln_lang_ctx_t,
    mut name: *mut mln_string_t,
    mut val: *mut libc::c_void,
    mut type_0: mln_u32_t,
) -> libc::c_int {
    let mut v: *mut mln_lang_val_t = 0 as *mut mln_lang_val_t;
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    v = __mln_lang_val_new(ctx, type_0 as mln_s32_t, val);
    if v.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    var = __mln_lang_var_new_ref_string(
        ctx,
        name,
        M_LANG_VAR_NORMAL,
        v,
        0 as *mut mln_lang_set_detail_t,
    );
    if var.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        __mln_lang_val_free(v as *mut libc::c_void);
        return -(1 as libc::c_int);
    }
    if __mln_lang_symbol_node_join(ctx, M_LANG_SYMBOL_VAR, var as *mut libc::c_void)
        < 0 as libc::c_int
    {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        __mln_lang_var_free(var as *mut libc::c_void);
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_job_new(
    mut lang: *mut mln_lang_t,
    mut alias: *mut mln_string_t,
    mut type_0: mln_u32_t,
    mut data: *mut mln_string_t,
    mut udata: *mut libc::c_void,
    mut handler: mln_lang_return_handler,
) -> *mut mln_lang_ctx_t {
    let mut ctx: *mut mln_lang_ctx_t = 0 as *mut mln_lang_ctx_t;
    pthread_mutex_lock(&mut (*lang).lock);
    ctx = __mln_lang_job_new(lang, alias, type_0, data, udata, handler);
    pthread_mutex_unlock(&mut (*lang).lock);
    return ctx;
}
#[inline]
unsafe extern "C" fn __mln_lang_job_new(
    mut lang: *mut mln_lang_t,
    mut alias: *mut mln_string_t,
    mut type_0: mln_u32_t,
    mut data: *mut mln_string_t,
    mut udata: *mut libc::c_void,
    mut handler: mln_lang_return_handler,
) -> *mut mln_lang_ctx_t {
    let mut ctx: *mut mln_lang_ctx_t = mln_lang_ctx_new(
        lang,
        udata,
        if type_0 == 1 as libc::c_int as libc::c_uint {
            data
        } else {
            0 as *mut mln_string_t
        },
        type_0,
        data,
        alias,
    );
    if ctx.is_null() {
        return 0 as *mut mln_lang_ctx_t;
    }
    (*ctx).return_handler = handler;
    mln_lang_ctx_chain_add(&mut (*lang).run_head, &mut (*lang).run_tail, ctx);
    if !((*lang).run_head).is_null() {
        if ((*lang).signal).expect("non-null function pointer")(lang) < 0 as libc::c_int
        {
            mln_lang_ctx_chain_del(&mut (*lang).run_head, &mut (*lang).run_tail, ctx);
            mln_lang_ctx_free(ctx);
            return 0 as *mut mln_lang_ctx_t;
        }
    } else {
        ((*lang).clear).expect("non-null function pointer")(lang);
    }
    return ctx;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_job_free(mut ctx: *mut mln_lang_ctx_t) {
    if ctx.is_null() {
        return;
    }
    let mut lang: *mut mln_lang_t = (*ctx).lang;
    pthread_mutex_lock(&mut (*lang).lock);
    __mln_lang_job_free(ctx);
    pthread_mutex_unlock(&mut (*lang).lock);
}
#[inline]
unsafe extern "C" fn __mln_lang_job_free(mut ctx: *mut mln_lang_ctx_t) {
    if ctx.is_null() {
        return;
    }
    let mut lang: *mut mln_lang_t = (*ctx).lang;
    if (*ctx).ref_0 != 0 {
        mln_lang_ctx_chain_del(&mut (*lang).wait_head, &mut (*lang).wait_tail, ctx);
    } else {
        mln_lang_ctx_chain_del(&mut (*lang).run_head, &mut (*lang).run_tail, ctx);
    }
    mln_lang_ctx_free(ctx);
    if !((*lang).run_head).is_null() {
        ((*lang).signal).expect("non-null function pointer")(lang);
    } else {
        ((*lang).clear).expect("non-null function pointer")(lang);
    };
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_var_create_call(
    mut ctx: *mut mln_lang_ctx_t,
    mut call: *mut mln_lang_funccall_val_t,
) -> *mut mln_lang_var_t {
    return __mln_lang_var_create_call(ctx, call);
}
#[inline]
unsafe extern "C" fn __mln_lang_var_create_call(
    mut ctx: *mut mln_lang_ctx_t,
    mut call: *mut mln_lang_funccall_val_t,
) -> *mut mln_lang_var_t {
    let mut val: *mut mln_lang_val_t = 0 as *mut mln_lang_val_t;
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    val = __mln_lang_val_new(ctx, 8 as libc::c_int, call as *mut libc::c_void);
    if val.is_null() {
        return 0 as *mut mln_lang_var_t;
    }
    var = __mln_lang_var_new_ref_string(
        ctx,
        0 as *mut mln_string_t,
        M_LANG_VAR_NORMAL,
        val,
        0 as *mut mln_lang_set_detail_t,
    );
    if var.is_null() {
        __mln_lang_val_free(val as *mut libc::c_void);
        return 0 as *mut mln_lang_var_t;
    }
    return var;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_var_create_nil(
    mut ctx: *mut mln_lang_ctx_t,
    mut name: *mut mln_string_t,
) -> *mut mln_lang_var_t {
    return __mln_lang_var_create_nil(ctx, name);
}
#[inline]
unsafe extern "C" fn __mln_lang_var_create_nil(
    mut ctx: *mut mln_lang_ctx_t,
    mut name: *mut mln_string_t,
) -> *mut mln_lang_var_t {
    let mut val: *mut mln_lang_val_t = 0 as *mut mln_lang_val_t;
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    val = __mln_lang_val_new(ctx, 0 as libc::c_int, 0 as *mut libc::c_void);
    if val.is_null() {
        return 0 as *mut mln_lang_var_t;
    }
    var = __mln_lang_var_new_ref_string(
        ctx,
        name,
        M_LANG_VAR_NORMAL,
        val,
        0 as *mut mln_lang_set_detail_t,
    );
    if var.is_null() {
        __mln_lang_val_free(val as *mut libc::c_void);
        return 0 as *mut mln_lang_var_t;
    }
    return var;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_var_create_obj(
    mut ctx: *mut mln_lang_ctx_t,
    mut in_set: *mut mln_lang_set_detail_t,
    mut name: *mut mln_string_t,
) -> *mut mln_lang_var_t {
    return __mln_lang_var_create_obj(ctx, in_set, name);
}
#[inline]
unsafe extern "C" fn __mln_lang_var_create_obj(
    mut ctx: *mut mln_lang_ctx_t,
    mut in_set: *mut mln_lang_set_detail_t,
    mut name: *mut mln_string_t,
) -> *mut mln_lang_var_t {
    let mut val: *mut mln_lang_val_t = 0 as *mut mln_lang_val_t;
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut obj: *mut mln_lang_object_t = 0 as *mut mln_lang_object_t;
    obj = mln_lang_object_new(ctx, in_set);
    if obj.is_null() {
        return 0 as *mut mln_lang_var_t;
    }
    val = __mln_lang_val_new(ctx, 5 as libc::c_int, obj as *mut libc::c_void);
    if val.is_null() {
        mln_lang_object_free(obj);
        return 0 as *mut mln_lang_var_t;
    }
    var = __mln_lang_var_new_ref_string(
        ctx,
        name,
        M_LANG_VAR_NORMAL,
        val,
        0 as *mut mln_lang_set_detail_t,
    );
    if var.is_null() {
        __mln_lang_val_free(val as *mut libc::c_void);
        return 0 as *mut mln_lang_var_t;
    }
    return var;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_var_create_true(
    mut ctx: *mut mln_lang_ctx_t,
    mut name: *mut mln_string_t,
) -> *mut mln_lang_var_t {
    return __mln_lang_var_create_true(ctx, name);
}
#[inline]
unsafe extern "C" fn __mln_lang_var_create_true(
    mut ctx: *mut mln_lang_ctx_t,
    mut name: *mut mln_string_t,
) -> *mut mln_lang_var_t {
    let mut val: *mut mln_lang_val_t = 0 as *mut mln_lang_val_t;
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut t: mln_u8_t = 1 as libc::c_int as mln_u8_t;
    val = __mln_lang_val_new(
        ctx,
        2 as libc::c_int,
        &mut t as *mut mln_u8_t as *mut libc::c_void,
    );
    if val.is_null() {
        return 0 as *mut mln_lang_var_t;
    }
    var = __mln_lang_var_new_ref_string(
        ctx,
        name,
        M_LANG_VAR_NORMAL,
        val,
        0 as *mut mln_lang_set_detail_t,
    );
    if var.is_null() {
        __mln_lang_val_free(val as *mut libc::c_void);
        return 0 as *mut mln_lang_var_t;
    }
    return var;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_var_create_false(
    mut ctx: *mut mln_lang_ctx_t,
    mut name: *mut mln_string_t,
) -> *mut mln_lang_var_t {
    let mut val: *mut mln_lang_val_t = 0 as *mut mln_lang_val_t;
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut t: mln_u8_t = 0 as libc::c_int as mln_u8_t;
    val = __mln_lang_val_new(
        ctx,
        2 as libc::c_int,
        &mut t as *mut mln_u8_t as *mut libc::c_void,
    );
    if val.is_null() {
        return 0 as *mut mln_lang_var_t;
    }
    var = __mln_lang_var_new_ref_string(
        ctx,
        name,
        M_LANG_VAR_NORMAL,
        val,
        0 as *mut mln_lang_set_detail_t,
    );
    if var.is_null() {
        __mln_lang_val_free(val as *mut libc::c_void);
        return 0 as *mut mln_lang_var_t;
    }
    return var;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_var_create_int(
    mut ctx: *mut mln_lang_ctx_t,
    mut off: mln_s64_t,
    mut name: *mut mln_string_t,
) -> *mut mln_lang_var_t {
    return __mln_lang_var_create_int(ctx, off, name);
}
#[inline]
unsafe extern "C" fn __mln_lang_var_create_int(
    mut ctx: *mut mln_lang_ctx_t,
    mut off: mln_s64_t,
    mut name: *mut mln_string_t,
) -> *mut mln_lang_var_t {
    let mut val: *mut mln_lang_val_t = 0 as *mut mln_lang_val_t;
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    val = __mln_lang_val_new(
        ctx,
        1 as libc::c_int,
        &mut off as *mut mln_s64_t as *mut libc::c_void,
    );
    if val.is_null() {
        return 0 as *mut mln_lang_var_t;
    }
    var = __mln_lang_var_new_ref_string(
        ctx,
        name,
        M_LANG_VAR_NORMAL,
        val,
        0 as *mut mln_lang_set_detail_t,
    );
    if var.is_null() {
        __mln_lang_val_free(val as *mut libc::c_void);
        return 0 as *mut mln_lang_var_t;
    }
    return var;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_var_create_real(
    mut ctx: *mut mln_lang_ctx_t,
    mut f: libc::c_double,
    mut name: *mut mln_string_t,
) -> *mut mln_lang_var_t {
    return __mln_lang_var_create_real(ctx, f, name);
}
#[inline]
unsafe extern "C" fn __mln_lang_var_create_real(
    mut ctx: *mut mln_lang_ctx_t,
    mut f: libc::c_double,
    mut name: *mut mln_string_t,
) -> *mut mln_lang_var_t {
    let mut val: *mut mln_lang_val_t = 0 as *mut mln_lang_val_t;
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    val = __mln_lang_val_new(
        ctx,
        3 as libc::c_int,
        &mut f as *mut libc::c_double as *mut libc::c_void,
    );
    if val.is_null() {
        return 0 as *mut mln_lang_var_t;
    }
    var = __mln_lang_var_new_ref_string(
        ctx,
        name,
        M_LANG_VAR_NORMAL,
        val,
        0 as *mut mln_lang_set_detail_t,
    );
    if var.is_null() {
        __mln_lang_val_free(val as *mut libc::c_void);
        return 0 as *mut mln_lang_var_t;
    }
    return var;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_var_create_bool(
    mut ctx: *mut mln_lang_ctx_t,
    mut b: mln_u8_t,
    mut name: *mut mln_string_t,
) -> *mut mln_lang_var_t {
    return __mln_lang_var_create_bool(ctx, b, name);
}
#[inline]
unsafe extern "C" fn __mln_lang_var_create_bool(
    mut ctx: *mut mln_lang_ctx_t,
    mut b: mln_u8_t,
    mut name: *mut mln_string_t,
) -> *mut mln_lang_var_t {
    let mut val: *mut mln_lang_val_t = 0 as *mut mln_lang_val_t;
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    val = __mln_lang_val_new(
        ctx,
        2 as libc::c_int,
        &mut b as *mut mln_u8_t as *mut libc::c_void,
    );
    if val.is_null() {
        return 0 as *mut mln_lang_var_t;
    }
    var = __mln_lang_var_new_ref_string(
        ctx,
        name,
        M_LANG_VAR_NORMAL,
        val,
        0 as *mut mln_lang_set_detail_t,
    );
    if var.is_null() {
        __mln_lang_val_free(val as *mut libc::c_void);
        return 0 as *mut mln_lang_var_t;
    }
    return var;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_var_create_ref_string(
    mut ctx: *mut mln_lang_ctx_t,
    mut s: *mut mln_string_t,
    mut name: *mut mln_string_t,
) -> *mut mln_lang_var_t {
    return __mln_lang_var_create_ref_string(ctx, s, name);
}
#[inline]
unsafe extern "C" fn __mln_lang_var_create_ref_string(
    mut ctx: *mut mln_lang_ctx_t,
    mut s: *mut mln_string_t,
    mut name: *mut mln_string_t,
) -> *mut mln_lang_var_t {
    let mut val: *mut mln_lang_val_t = 0 as *mut mln_lang_val_t;
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    val = __mln_lang_val_new(
        ctx,
        4 as libc::c_int,
        ({
            let mut __s: *mut mln_string_t = s;
            (*__s).set_ref_0((*__s).ref_0() + 1);
            (*__s).ref_0();
            __s
        }) as *mut libc::c_void,
    );
    if val.is_null() {
        let mut __s: *mut mln_string_t = s;
        if !__s.is_null() {
            let ref mut fresh13 = (*__s).ref_0();
            let fresh14 = *fresh13;
            *fresh13 = (*fresh13).wrapping_sub(1);
            if fresh14 <= 1 as libc::c_int as libc::c_ulong {
                if (*__s).data_ref() == 0 && !((*__s).data).is_null() {
                    if (*__s).pool() != 0 {
                        mln_alloc_free((*__s).data as *mut libc::c_void);
                    } else {
                        free((*__s).data as *mut libc::c_void);
                    }
                }
                if (*__s).pool() != 0 {
                    mln_alloc_free(__s as *mut libc::c_void);
                } else {
                    free(__s as *mut libc::c_void);
                }
            }
        }
        return 0 as *mut mln_lang_var_t;
    }
    var = __mln_lang_var_new_ref_string(
        ctx,
        name,
        M_LANG_VAR_NORMAL,
        val,
        0 as *mut mln_lang_set_detail_t,
    );
    if var.is_null() {
        __mln_lang_val_free(val as *mut libc::c_void);
        return 0 as *mut mln_lang_var_t;
    }
    return var;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_var_create_string(
    mut ctx: *mut mln_lang_ctx_t,
    mut s: *mut mln_string_t,
    mut name: *mut mln_string_t,
) -> *mut mln_lang_var_t {
    let mut val: *mut mln_lang_val_t = 0 as *mut mln_lang_val_t;
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut dup: *mut mln_string_t = 0 as *mut mln_string_t;
    dup = mln_string_pool_dup((*ctx).pool, s);
    if dup.is_null() {
        return 0 as *mut mln_lang_var_t;
    }
    val = __mln_lang_val_new(ctx, 4 as libc::c_int, dup as *mut libc::c_void);
    if val.is_null() {
        let mut __s: *mut mln_string_t = dup;
        if !__s.is_null() {
            let ref mut fresh15 = (*__s).ref_0();
            let fresh16 = *fresh15;
            *fresh15 = (*fresh15).wrapping_sub(1);
            if fresh16 <= 1 as libc::c_int as libc::c_ulong {
                if (*__s).data_ref() == 0 && !((*__s).data).is_null() {
                    if (*__s).pool() != 0 {
                        mln_alloc_free((*__s).data as *mut libc::c_void);
                    } else {
                        free((*__s).data as *mut libc::c_void);
                    }
                }
                if (*__s).pool() != 0 {
                    mln_alloc_free(__s as *mut libc::c_void);
                } else {
                    free(__s as *mut libc::c_void);
                }
            }
        }
        return 0 as *mut mln_lang_var_t;
    }
    var = __mln_lang_var_new_ref_string(
        ctx,
        name,
        M_LANG_VAR_NORMAL,
        val,
        0 as *mut mln_lang_set_detail_t,
    );
    if var.is_null() {
        __mln_lang_val_free(val as *mut libc::c_void);
        return 0 as *mut mln_lang_var_t;
    }
    return var;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_var_create_array(
    mut ctx: *mut mln_lang_ctx_t,
    mut name: *mut mln_string_t,
) -> *mut mln_lang_var_t {
    return __mln_lang_var_create_array(ctx, name);
}
#[inline]
unsafe extern "C" fn __mln_lang_var_create_array(
    mut ctx: *mut mln_lang_ctx_t,
    mut name: *mut mln_string_t,
) -> *mut mln_lang_var_t {
    let mut val: *mut mln_lang_val_t = 0 as *mut mln_lang_val_t;
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut array: *mut mln_lang_array_t = 0 as *mut mln_lang_array_t;
    array = __mln_lang_array_new(ctx);
    if array.is_null() {
        return 0 as *mut mln_lang_var_t;
    }
    val = __mln_lang_val_new(ctx, 7 as libc::c_int, array as *mut libc::c_void);
    if val.is_null() {
        __mln_lang_array_free(array);
        return 0 as *mut mln_lang_var_t;
    }
    var = __mln_lang_var_new_ref_string(
        ctx,
        name,
        M_LANG_VAR_NORMAL,
        val,
        0 as *mut mln_lang_set_detail_t,
    );
    if var.is_null() {
        __mln_lang_val_free(val as *mut libc::c_void);
        return 0 as *mut mln_lang_var_t;
    }
    return var;
}
#[inline]
unsafe extern "C" fn mln_lang_stack_node_get_ctx_ret_var(
    mut node: *mut mln_lang_stack_node_t,
    mut ctx: *mut mln_lang_ctx_t,
) {
    if !((*node).ret_var).is_null() {
        __mln_lang_var_free((*node).ret_var as *mut libc::c_void);
    }
    (*node).ret_var = (*ctx).ret_var;
    (*ctx).ret_var = 0 as *mut mln_lang_var_t;
}
#[inline]
unsafe extern "C" fn mln_lang_stack_node_reset_ret_val(
    mut node: *mut mln_lang_stack_node_t,
) {
    if ((*node).ret_var).is_null() {
        return;
    }
    __mln_lang_var_free((*node).ret_var as *mut libc::c_void);
    (*node).ret_var = 0 as *mut mln_lang_var_t;
}
#[inline]
unsafe extern "C" fn mln_lang_stack_node_set_ret_var(
    mut node: *mut mln_lang_stack_node_t,
    mut ret_var: *mut mln_lang_var_t,
) {
    mln_lang_stack_node_reset_ret_val(node);
    (*node).ret_var = ret_var;
}
#[inline]
unsafe extern "C" fn mln_lang_ctx_reset_ret_var(mut ctx: *mut mln_lang_ctx_t) {
    if ((*ctx).ret_var).is_null() {
        return;
    }
    __mln_lang_var_free((*ctx).ret_var as *mut libc::c_void);
    (*ctx).ret_var = 0 as *mut mln_lang_var_t;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_ctx_set_ret_var(
    mut ctx: *mut mln_lang_ctx_t,
    mut var: *mut mln_lang_var_t,
) {
    __mln_lang_ctx_set_ret_var(ctx, var);
}
#[inline]
unsafe extern "C" fn __mln_lang_ctx_set_ret_var(
    mut ctx: *mut mln_lang_ctx_t,
    mut var: *mut mln_lang_var_t,
) {
    mln_lang_ctx_reset_ret_var(ctx);
    (*ctx).ret_var = var;
}
#[inline]
unsafe extern "C" fn mln_lang_ctx_get_node_ret_val(
    mut ctx: *mut mln_lang_ctx_t,
    mut node: *mut mln_lang_stack_node_t,
) {
    if !((*ctx).ret_var).is_null() {
        __mln_lang_var_free((*ctx).ret_var as *mut libc::c_void);
    }
    (*ctx).ret_var = (*node).ret_var;
    (*node).ret_var = 0 as *mut mln_lang_var_t;
}
#[inline]
unsafe extern "C" fn mln_lang_symbol_node_new(
    mut ctx: *mut mln_lang_ctx_t,
    mut symbol: *mut mln_string_t,
    mut type_0: mln_lang_symbol_type_t,
    mut data: *mut libc::c_void,
) -> *mut mln_lang_symbol_node_t {
    let mut ls: *mut mln_lang_symbol_node_t = 0 as *mut mln_lang_symbol_node_t;
    ls = (*ctx).sym_head;
    if !ls.is_null() {
        mln_lang_sym_chain_del(&mut (*ctx).sym_head, &mut (*ctx).sym_tail, ls);
        (*ctx).set_sym_count((*ctx).sym_count() - 1);
        (*ctx).sym_count();
    } else {
        ls = mln_alloc_m(
            (*ctx).pool,
            ::core::mem::size_of::<mln_lang_symbol_node_t>() as libc::c_ulong,
        ) as *mut mln_lang_symbol_node_t;
        if ls.is_null() {
            return 0 as *mut mln_lang_symbol_node_t;
        }
        (*ls).ctx = ctx;
        (*ls).next = 0 as *mut mln_lang_symbol_node_s;
        (*ls).prev = (*ls).next;
    }
    (*ls).symbol = symbol;
    (*ls).type_0 = type_0;
    match type_0 as libc::c_uint {
        0 => {
            (*ls).data.var = data as *mut mln_lang_var_t;
        }
        _ => {
            (*ls).data.set = data as *mut mln_lang_set_detail_t;
        }
    }
    (*ls).layer = (*(*ctx).scope_top).layer;
    (*ls).bucket = 0 as *mut mln_lang_hash_bucket_t;
    (*ls).scope_next = 0 as *mut mln_lang_symbol_node_s;
    (*ls).scope_prev = (*ls).scope_next;
    return ls;
}
unsafe extern "C" fn mln_lang_symbol_node_free(mut data: *mut libc::c_void) {
    if data.is_null() {
        return;
    }
    let mut ls: *mut mln_lang_symbol_node_t = data as *mut mln_lang_symbol_node_t;
    match (*ls).type_0 as libc::c_uint {
        0 => {
            if !((*ls).data.var).is_null() {
                __mln_lang_var_free((*ls).data.var as *mut libc::c_void);
                (*ls).data.var = 0 as *mut mln_lang_var_t;
            }
        }
        _ => {
            if !((*ls).data.set).is_null() {
                mln_lang_set_detail_self_free((*ls).data.set);
                (*ls).data.set = 0 as *mut mln_lang_set_detail_t;
            }
        }
    }
    if !((*ls).ctx).is_null()
        && ((*(*ls).ctx).sym_count() as libc::c_int) < 65535 as libc::c_int
    {
        mln_lang_sym_chain_add(
            &mut (*(*ls).ctx).sym_head,
            &mut (*(*ls).ctx).sym_tail,
            ls,
        );
        (*(*ls).ctx).set_sym_count((*(*ls).ctx).sym_count() + 1);
        (*(*ls).ctx).sym_count();
    } else {
        mln_alloc_free(ls as *mut libc::c_void);
    };
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_symbol_node_join(
    mut ctx: *mut mln_lang_ctx_t,
    mut type_0: mln_lang_symbol_type_t,
    mut data: *mut libc::c_void,
) -> libc::c_int {
    return __mln_lang_symbol_node_join(ctx, type_0, data);
}
#[inline]
unsafe extern "C" fn __mln_lang_symbol_node_join(
    mut ctx: *mut mln_lang_ctx_t,
    mut type_0: mln_lang_symbol_type_t,
    mut data: *mut libc::c_void,
) -> libc::c_int {
    let mut symbol: *mut mln_lang_symbol_node_t = 0 as *mut mln_lang_symbol_node_t;
    let mut tmp: *mut mln_lang_symbol_node_t = 0 as *mut mln_lang_symbol_node_t;
    let mut name: *mut mln_string_t = if type_0 as libc::c_uint
        == M_LANG_SYMBOL_VAR as libc::c_int as libc::c_uint
    {
        (*(data as *mut mln_lang_var_t)).name
    } else {
        (*(data as *mut mln_lang_set_detail_t)).name
    };
    symbol = mln_lang_symbol_node_new(ctx, name, type_0, data);
    if symbol.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    (*symbol).bucket = mln_lang_hash_get_bucket((*ctx).symbols, symbol);
    tmp = (*(*symbol).bucket).tail;
    while !tmp.is_null() {
        if !((*tmp).layer != (*symbol).layer || (*(*tmp).symbol).len != (*name).len) {
            if memcmp(
                (*(*tmp).symbol).data as *const libc::c_void,
                (*name).data as *const libc::c_void,
                (*name).len,
            ) == 0
            {
                mln_lang_sym_chain_del(
                    &mut (*(*tmp).bucket).head,
                    &mut (*(*tmp).bucket).tail,
                    tmp,
                );
                mln_lang_sym_scope_chain_del(
                    &mut (*(*ctx).scope_top).sym_head,
                    &mut (*(*ctx).scope_top).sym_tail,
                    tmp,
                );
                mln_lang_symbol_node_free(tmp as *mut libc::c_void);
                break;
            }
        }
        tmp = (*tmp).prev;
    }
    mln_lang_sym_chain_add(
        &mut (*(*symbol).bucket).head,
        &mut (*(*symbol).bucket).tail,
        symbol,
    );
    mln_lang_sym_scope_chain_add(
        &mut (*(*ctx).scope_top).sym_head,
        &mut (*(*ctx).scope_top).sym_tail,
        symbol,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_symbol_node_upper_join(
    mut ctx: *mut mln_lang_ctx_t,
    mut type_0: mln_lang_symbol_type_t,
    mut data: *mut libc::c_void,
) -> libc::c_int {
    let mut symbol: *mut mln_lang_symbol_node_t = 0 as *mut mln_lang_symbol_node_t;
    let mut tmp: *mut mln_lang_symbol_node_t = 0 as *mut mln_lang_symbol_node_t;
    let mut name: *mut mln_string_t = if type_0 as libc::c_uint
        == M_LANG_SYMBOL_VAR as libc::c_int as libc::c_uint
    {
        (*(data as *mut mln_lang_var_t)).name
    } else {
        (*(data as *mut mln_lang_set_detail_t)).name
    };
    symbol = mln_lang_symbol_node_new(ctx, name, type_0, data);
    if symbol.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    (*symbol)
        .layer = if ({
        let mut in_0: libc::c_int = 0 as libc::c_int;
        let mut s: *mut mln_lang_scope_t = ((*ctx).scope_top)
            .offset(-(1 as libc::c_int as isize));
        if !s.is_null()
            && s.offset_from(((*ctx).scopes).as_mut_ptr()) as libc::c_long
                <= 1024 as libc::c_int as libc::c_long
        {
            in_0 = 1 as libc::c_int;
        }
        in_0
    }) == 0
    {
        (*(*ctx).scope_top).layer
    } else {
        (*((*ctx).scope_top).offset(-(1 as libc::c_int as isize))).layer
    };
    (*symbol).bucket = mln_lang_hash_get_bucket((*ctx).symbols, symbol);
    tmp = (*(*symbol).bucket).tail;
    while !tmp.is_null() {
        if !((*tmp).layer != (*symbol).layer || (*(*tmp).symbol).len != (*name).len) {
            if memcmp(
                (*(*tmp).symbol).data as *const libc::c_void,
                (*name).data as *const libc::c_void,
                (*name).len,
            ) == 0
            {
                mln_lang_sym_chain_del(
                    &mut (*(*tmp).bucket).head,
                    &mut (*(*tmp).bucket).tail,
                    tmp,
                );
                if ({
                    let mut in_0: libc::c_int = 0 as libc::c_int;
                    let mut s: *mut mln_lang_scope_t = ((*ctx).scope_top)
                        .offset(-(1 as libc::c_int as isize));
                    if !s.is_null()
                        && s.offset_from(((*ctx).scopes).as_mut_ptr()) as libc::c_long
                            <= 1024 as libc::c_int as libc::c_long
                    {
                        in_0 = 1 as libc::c_int;
                    }
                    in_0
                }) == 0
                {
                    mln_lang_sym_scope_chain_del(
                        &mut (*(*ctx).scope_top).sym_head,
                        &mut (*(*ctx).scope_top).sym_tail,
                        tmp,
                    );
                } else {
                    mln_lang_sym_scope_chain_del(
                        &mut (*((*ctx).scope_top).offset(-(1 as libc::c_int as isize)))
                            .sym_head,
                        &mut (*((*ctx).scope_top).offset(-(1 as libc::c_int as isize)))
                            .sym_tail,
                        tmp,
                    );
                }
                mln_lang_symbol_node_free(tmp as *mut libc::c_void);
                break;
            }
        }
        tmp = (*tmp).prev;
    }
    mln_lang_sym_chain_add(
        &mut (*(*symbol).bucket).head,
        &mut (*(*symbol).bucket).tail,
        symbol,
    );
    if ({
        let mut in_0: libc::c_int = 0 as libc::c_int;
        let mut s: *mut mln_lang_scope_t = ((*ctx).scope_top)
            .offset(-(1 as libc::c_int as isize));
        if !s.is_null()
            && s.offset_from(((*ctx).scopes).as_mut_ptr()) as libc::c_long
                <= 1024 as libc::c_int as libc::c_long
        {
            in_0 = 1 as libc::c_int;
        }
        in_0
    }) == 0
    {
        mln_lang_sym_scope_chain_add(
            &mut (*(*ctx).scope_top).sym_head,
            &mut (*(*ctx).scope_top).sym_tail,
            symbol,
        );
    } else {
        mln_lang_sym_scope_chain_add(
            &mut (*((*ctx).scope_top).offset(-(1 as libc::c_int as isize))).sym_head,
            &mut (*((*ctx).scope_top).offset(-(1 as libc::c_int as isize))).sym_tail,
            symbol,
        );
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_symbol_node_search(
    mut ctx: *mut mln_lang_ctx_t,
    mut name: *mut mln_string_t,
    mut local: libc::c_int,
) -> *mut mln_lang_symbol_node_t {
    return __mln_lang_symbol_node_search(ctx, name, local);
}
#[inline]
unsafe extern "C" fn __mln_lang_symbol_node_search(
    mut ctx: *mut mln_lang_ctx_t,
    mut name: *mut mln_string_t,
    mut local: libc::c_int,
) -> *mut mln_lang_symbol_node_t {
    let mut sym: *mut mln_lang_symbol_node_t = 0 as *mut mln_lang_symbol_node_t;
    let mut tmp: mln_lang_symbol_node_t = mln_lang_symbol_node_t {
        symbol: 0 as *mut mln_string_t,
        ctx: 0 as *mut mln_lang_ctx_t,
        type_0: M_LANG_SYMBOL_VAR,
        data: C2RustUnnamed_9 {
            var: 0 as *mut mln_lang_var_t,
        },
        layer: 0,
        bucket: 0 as *mut mln_lang_hash_bucket_t,
        prev: 0 as *mut mln_lang_symbol_node_s,
        next: 0 as *mut mln_lang_symbol_node_s,
        scope_prev: 0 as *mut mln_lang_symbol_node_s,
        scope_next: 0 as *mut mln_lang_symbol_node_s,
    };
    let mut hb: *mut mln_lang_hash_bucket_t = 0 as *mut mln_lang_hash_bucket_t;
    let mut scope: *mut mln_lang_scope_t = (*ctx).scope_top;
    tmp.symbol = name;
    while !scope.is_null() {
        tmp.layer = (*scope).layer;
        hb = mln_lang_hash_get_bucket((*ctx).symbols, &mut tmp);
        sym = (*hb).tail;
        while !sym.is_null() {
            if !((*sym).layer != (*scope).layer || (*(*sym).symbol).len != (*name).len) {
                if memcmp(
                    (*(*sym).symbol).data as *const libc::c_void,
                    (*name).data as *const libc::c_void,
                    (*name).len,
                ) == 0
                {
                    return sym;
                }
            }
            sym = (*sym).prev;
        }
        if local != 0 || scope == ((*ctx).scopes).as_mut_ptr() {
            break;
        }
        scope = ((*ctx).scopes).as_mut_ptr();
    }
    return 0 as *mut mln_lang_symbol_node_t;
}
#[inline]
unsafe extern "C" fn mln_lang_symbol_node_id_search(
    mut ctx: *mut mln_lang_ctx_t,
    mut name: *mut mln_string_t,
) -> *mut mln_lang_symbol_node_t {
    return __mln_lang_symbol_node_search(
        ctx,
        name,
        if (*name).len > 0 as libc::c_int as libc::c_ulong
            && *((*name).data).offset(0 as libc::c_int as isize) as libc::c_int
                > 64 as libc::c_int
            && (*((*name).data).offset(0 as libc::c_int as isize) as libc::c_int)
                < 91 as libc::c_int
        {
            0 as libc::c_int
        } else {
            1 as libc::c_int
        },
    );
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_set_detail_new(
    mut pool: *mut mln_alloc_t,
    mut name: *mut mln_string_t,
) -> *mut mln_lang_set_detail_t {
    let mut rbattr: mln_rbtree_attr = mln_rbtree_attr {
        pool: 0 as *mut libc::c_void,
        pool_alloc: None,
        pool_free: None,
        cmp: None,
        data_free: None,
    };
    let mut lcd: *mut mln_lang_set_detail_t = 0 as *mut mln_lang_set_detail_t;
    lcd = mln_alloc_m(
        pool,
        ::core::mem::size_of::<mln_lang_set_detail_t>() as libc::c_ulong,
    ) as *mut mln_lang_set_detail_t;
    if lcd.is_null() {
        return 0 as *mut mln_lang_set_detail_t;
    }
    (*lcd).name = mln_string_pool_dup(pool, name);
    if ((*lcd).name).is_null() {
        mln_alloc_free(lcd as *mut libc::c_void);
        return 0 as *mut mln_lang_set_detail_t;
    }
    rbattr.pool = pool as *mut libc::c_void;
    rbattr
        .pool_alloc = ::core::mem::transmute::<
        Option::<
            unsafe extern "C" fn(*mut mln_alloc_t, mln_size_t) -> *mut libc::c_void,
        >,
        rbtree_pool_alloc_handler,
    >(
        Some(
            mln_alloc_m
                as unsafe extern "C" fn(
                    *mut mln_alloc_t,
                    mln_size_t,
                ) -> *mut libc::c_void,
        ),
    );
    rbattr
        .pool_free = ::core::mem::transmute::<
        Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
        rbtree_pool_free_handler,
    >(Some(mln_alloc_free as unsafe extern "C" fn(*mut libc::c_void) -> ()));
    rbattr
        .cmp = Some(
        mln_lang_var_name_cmp
            as unsafe extern "C" fn(
                *const libc::c_void,
                *const libc::c_void,
            ) -> libc::c_int,
    );
    rbattr
        .data_free = Some(
        mln_lang_var_free as unsafe extern "C" fn(*mut libc::c_void) -> (),
    );
    (*lcd).members = mln_rbtree_new(&mut rbattr);
    if ((*lcd).members).is_null() {
        mln_alloc_free(lcd as *mut libc::c_void);
        return 0 as *mut mln_lang_set_detail_t;
    }
    (*lcd).ref_0 = 0 as libc::c_int as mln_u64_t;
    return lcd;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_set_detail_free(mut c: *mut mln_lang_set_detail_t) {
    if c.is_null() {
        return;
    }
    let fresh17 = (*c).ref_0;
    (*c).ref_0 = ((*c).ref_0).wrapping_sub(1);
    if fresh17 > 1 as libc::c_int as libc::c_ulong {
        return;
    }
    if !((*c).name).is_null() {
        let mut __s: *mut mln_string_t = (*c).name;
        if !__s.is_null() {
            let ref mut fresh18 = (*__s).ref_0();
            let fresh19 = *fresh18;
            *fresh18 = (*fresh18).wrapping_sub(1);
            if fresh19 <= 1 as libc::c_int as libc::c_ulong {
                if (*__s).data_ref() == 0 && !((*__s).data).is_null() {
                    if (*__s).pool() != 0 {
                        mln_alloc_free((*__s).data as *mut libc::c_void);
                    } else {
                        free((*__s).data as *mut libc::c_void);
                    }
                }
                if (*__s).pool() != 0 {
                    mln_alloc_free(__s as *mut libc::c_void);
                } else {
                    free(__s as *mut libc::c_void);
                }
            }
        }
    }
    if !((*c).members).is_null() {
        mln_rbtree_free((*c).members);
    }
    mln_alloc_free(c as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_set_detail_self_free(
    mut c: *mut mln_lang_set_detail_t,
) {
    if c.is_null() {
        return;
    }
    if !((*c).members).is_null() {
        mln_rbtree_free((*c).members);
        (*c).members = 0 as *mut mln_rbtree_t;
    }
    let fresh20 = (*c).ref_0;
    (*c).ref_0 = ((*c).ref_0).wrapping_sub(1);
    if fresh20 > 1 as libc::c_int as libc::c_ulong {
        return;
    }
    if !((*c).name).is_null() {
        let mut __s: *mut mln_string_t = (*c).name;
        if !__s.is_null() {
            let ref mut fresh21 = (*__s).ref_0();
            let fresh22 = *fresh21;
            *fresh21 = (*fresh21).wrapping_sub(1);
            if fresh22 <= 1 as libc::c_int as libc::c_ulong {
                if (*__s).data_ref() == 0 && !((*__s).data).is_null() {
                    if (*__s).pool() != 0 {
                        mln_alloc_free((*__s).data as *mut libc::c_void);
                    } else {
                        free((*__s).data as *mut libc::c_void);
                    }
                }
                if (*__s).pool() != 0 {
                    mln_alloc_free(__s as *mut libc::c_void);
                } else {
                    free(__s as *mut libc::c_void);
                }
            }
        }
    }
    mln_alloc_free(c as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_set_member_add(
    mut pool: *mut mln_alloc_t,
    mut members: *mut mln_rbtree_t,
    mut var: *mut mln_lang_var_t,
) -> libc::c_int {
    let mut rn: *mut mln_rbtree_node_t = 0 as *mut mln_rbtree_node_t;
    rn = mln_rbtree_search(members, var as *mut libc::c_void);
    if !(rn == &mut (*members).nil as *mut mln_rbtree_node_t) {
        let mut tmp: *mut mln_lang_var_t = (*rn).data as *mut mln_lang_var_t;
        __mln_lang_var_assign(tmp, (*var).val);
        __mln_lang_var_free(var as *mut libc::c_void);
        return 0 as libc::c_int;
    }
    rn = mln_rbtree_node_new(members, var as *mut libc::c_void);
    if rn.is_null() {
        return -(1 as libc::c_int);
    }
    mln_rbtree_insert(members, rn);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_set_member_search(
    mut members: *mut mln_rbtree_t,
    mut name: *mut mln_string_t,
) -> *mut mln_lang_var_t {
    return __mln_lang_set_member_search(members, name);
}
#[inline]
unsafe extern "C" fn __mln_lang_set_member_search(
    mut members: *mut mln_rbtree_t,
    mut name: *mut mln_string_t,
) -> *mut mln_lang_var_t {
    let mut rn: *mut mln_rbtree_node_t = 0 as *mut mln_rbtree_node_t;
    let mut var: mln_lang_var_t = mln_lang_var_t {
        type_0: M_LANG_VAR_NORMAL,
        name: 0 as *mut mln_string_t,
        val: 0 as *mut mln_lang_val_t,
        in_set: 0 as *mut mln_lang_set_detail_t,
        prev: 0 as *mut mln_lang_var_t,
        next: 0 as *mut mln_lang_var_t,
        ref_0: 0,
    };
    var.name = name;
    rn = mln_rbtree_search(
        members,
        &mut var as *mut mln_lang_var_t as *mut libc::c_void,
    );
    if rn == &mut (*members).nil as *mut mln_rbtree_node_t {
        return 0 as *mut mln_lang_var_t;
    }
    return (*rn).data as *mut mln_lang_var_t;
}
unsafe extern "C" fn mln_lang_set_member_iterate_handler(
    mut node: *mut mln_rbtree_node_t,
    mut udata: *mut libc::c_void,
) -> libc::c_int {
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut lv: *mut mln_lang_var_t = (*node).data as *mut mln_lang_var_t;
    let mut ls: *mut mln_lang_scan_s = udata as *mut mln_lang_scan_s;
    let mut tree: *mut mln_rbtree_t = (*ls).tree;
    let mut rn: *mut mln_rbtree_node_t = 0 as *mut mln_rbtree_node_t;
    rn = mln_rbtree_search(tree, lv as *mut libc::c_void);
    !(rn == &mut (*tree).nil as *mut mln_rbtree_node_t);
    var = __mln_lang_var_dup((*ls).ctx, lv);
    if var.is_null() {
        return -(1 as libc::c_int);
    }
    if mln_lang_set_member_add((*(*ls).ctx).pool, tree, var) < 0 as libc::c_int {
        __mln_lang_var_free(var as *mut libc::c_void);
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_object_add_member(
    mut ctx: *mut mln_lang_ctx_t,
    mut obj: *mut mln_lang_object_t,
    mut var: *mut mln_lang_var_t,
) -> libc::c_int {
    let mut dup: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut rn: *mut mln_rbtree_node_t = 0 as *mut mln_rbtree_node_t;
    rn = mln_rbtree_search((*obj).members, var as *mut libc::c_void);
    if !(rn == &mut (*(*obj).members).nil as *mut mln_rbtree_node_t) {
        return -(1 as libc::c_int);
    }
    dup = __mln_lang_var_dup(ctx, var);
    if dup.is_null() {
        return -(1 as libc::c_int);
    }
    if mln_lang_set_member_add((*ctx).pool, (*obj).members, dup) < 0 as libc::c_int {
        __mln_lang_var_free(dup as *mut libc::c_void);
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_var_new(
    mut ctx: *mut mln_lang_ctx_t,
    mut name: *mut mln_string_t,
    mut type_0: mln_lang_var_type_t,
    mut val: *mut mln_lang_val_t,
    mut in_set: *mut mln_lang_set_detail_t,
) -> *mut mln_lang_var_t {
    return __mln_lang_var_new(ctx, name, type_0, val, in_set);
}
#[inline]
unsafe extern "C" fn __mln_lang_var_new(
    mut ctx: *mut mln_lang_ctx_t,
    mut name: *mut mln_string_t,
    mut type_0: mln_lang_var_type_t,
    mut val: *mut mln_lang_val_t,
    mut in_set: *mut mln_lang_set_detail_t,
) -> *mut mln_lang_var_t {
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    var = mln_alloc_m(
        (*ctx).pool,
        ::core::mem::size_of::<mln_lang_var_t>() as libc::c_ulong,
    ) as *mut mln_lang_var_t;
    if var.is_null() {
        return 0 as *mut mln_lang_var_t;
    }
    (*var).type_0 = type_0;
    if !name.is_null() {
        (*var).name = mln_string_pool_dup((*ctx).pool, name);
        if ((*var).name).is_null() {
            mln_alloc_free(var as *mut libc::c_void);
            return 0 as *mut mln_lang_var_t;
        }
    } else {
        (*var).name = 0 as *mut mln_string_t;
    }
    (*var).val = val;
    if !val.is_null() {
        (*val).ref_0 = ((*val).ref_0).wrapping_add(1);
        (*val).ref_0;
    }
    (*var).in_set = in_set;
    if !in_set.is_null() {
        (*in_set).ref_0 = ((*in_set).ref_0).wrapping_add(1);
        (*in_set).ref_0;
    }
    (*var).next = 0 as *mut mln_lang_var_t;
    (*var).prev = (*var).next;
    (*var).ref_0 = 0 as libc::c_int as mln_uauto_t;
    return var;
}
#[inline]
unsafe extern "C" fn __mln_lang_var_new_ref_string(
    mut ctx: *mut mln_lang_ctx_t,
    mut name: *mut mln_string_t,
    mut type_0: mln_lang_var_type_t,
    mut val: *mut mln_lang_val_t,
    mut in_set: *mut mln_lang_set_detail_t,
) -> *mut mln_lang_var_t {
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    var = mln_alloc_m(
        (*ctx).pool,
        ::core::mem::size_of::<mln_lang_var_t>() as libc::c_ulong,
    ) as *mut mln_lang_var_t;
    if var.is_null() {
        return 0 as *mut mln_lang_var_t;
    }
    (*var).type_0 = type_0;
    if !name.is_null() {
        (*var)
            .name = ({
            let mut __s: *mut mln_string_t = name;
            (*__s).set_ref_0((*__s).ref_0() + 1);
            (*__s).ref_0();
            __s
        });
    } else {
        (*var).name = 0 as *mut mln_string_t;
    }
    (*var).val = val;
    if !val.is_null() {
        (*val).ref_0 = ((*val).ref_0).wrapping_add(1);
        (*val).ref_0;
    }
    (*var).in_set = in_set;
    if !in_set.is_null() {
        (*in_set).ref_0 = ((*in_set).ref_0).wrapping_add(1);
        (*in_set).ref_0;
    }
    (*var).next = 0 as *mut mln_lang_var_t;
    (*var).prev = (*var).next;
    (*var).ref_0 = 0 as libc::c_int as mln_uauto_t;
    return var;
}
#[inline]
unsafe extern "C" fn mln_lang_var_transform(
    mut ctx: *mut mln_lang_ctx_t,
    mut realvar: *mut mln_lang_var_t,
    mut defvar: *mut mln_lang_var_t,
) -> *mut mln_lang_var_t {
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    var = mln_alloc_m(
        (*ctx).pool,
        ::core::mem::size_of::<mln_lang_var_t>() as libc::c_ulong,
    ) as *mut mln_lang_var_t;
    if var.is_null() {
        return 0 as *mut mln_lang_var_t;
    }
    (*var).type_0 = (*defvar).type_0;
    (*var)
        .name = ({
        let mut __s: *mut mln_string_t = (*defvar).name;
        (*__s).set_ref_0((*__s).ref_0() + 1);
        (*__s).ref_0();
        __s
    });
    if (*var).type_0 as libc::c_uint == M_LANG_VAR_NORMAL as libc::c_int as libc::c_uint
    {
        (*var).val = mln_lang_val_dup(ctx, (*realvar).val);
        if ((*var).val).is_null() {
            let mut __s: *mut mln_string_t = (*var).name;
            if !__s.is_null() {
                let ref mut fresh23 = (*__s).ref_0();
                let fresh24 = *fresh23;
                *fresh23 = (*fresh23).wrapping_sub(1);
                if fresh24 <= 1 as libc::c_int as libc::c_ulong {
                    if (*__s).data_ref() == 0 && !((*__s).data).is_null() {
                        if (*__s).pool() != 0 {
                            mln_alloc_free((*__s).data as *mut libc::c_void);
                        } else {
                            free((*__s).data as *mut libc::c_void);
                        }
                    }
                    if (*__s).pool() != 0 {
                        mln_alloc_free(__s as *mut libc::c_void);
                    } else {
                        free(__s as *mut libc::c_void);
                    }
                }
            }
            mln_alloc_free(var as *mut libc::c_void);
            return 0 as *mut mln_lang_var_t;
        }
    } else {
        (*var).val = (*realvar).val;
    }
    (*(*var).val).ref_0 = ((*(*var).val).ref_0).wrapping_add(1);
    (*(*var).val).ref_0;
    (*var).in_set = (*defvar).in_set;
    if !((*var).in_set).is_null() {
        (*(*var).in_set).ref_0 = ((*(*var).in_set).ref_0).wrapping_add(1);
        (*(*var).in_set).ref_0;
    }
    (*var).next = 0 as *mut mln_lang_var_t;
    (*var).prev = (*var).next;
    (*var).ref_0 = 0 as libc::c_int as mln_uauto_t;
    return var;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_var_free(mut data: *mut libc::c_void) {
    __mln_lang_var_free(data);
}
unsafe extern "C" fn mln_lang_var_pfree(mut v: *mut *mut mln_lang_var_t) {
    __mln_lang_var_free(*v as *mut libc::c_void);
}
#[inline]
unsafe extern "C" fn __mln_lang_var_free(mut data: *mut libc::c_void) {
    if data.is_null() {
        return;
    }
    let mut var: *mut mln_lang_var_t = data as *mut mln_lang_var_t;
    let fresh25 = (*var).ref_0;
    (*var).ref_0 = ((*var).ref_0).wrapping_sub(1);
    if fresh25 > 0 as libc::c_int as libc::c_ulong {
        return;
    }
    if !((*var).name).is_null() {
        let mut __s: *mut mln_string_t = (*var).name;
        if !__s.is_null() {
            let ref mut fresh26 = (*__s).ref_0();
            let fresh27 = *fresh26;
            *fresh26 = (*fresh26).wrapping_sub(1);
            if fresh27 <= 1 as libc::c_int as libc::c_ulong {
                if (*__s).data_ref() == 0 && !((*__s).data).is_null() {
                    if (*__s).pool() != 0 {
                        mln_alloc_free((*__s).data as *mut libc::c_void);
                    } else {
                        free((*__s).data as *mut libc::c_void);
                    }
                }
                if (*__s).pool() != 0 {
                    mln_alloc_free(__s as *mut libc::c_void);
                } else {
                    free(__s as *mut libc::c_void);
                }
            }
        }
        (*var).name = 0 as *mut mln_string_t;
    }
    if !((*var).val).is_null() {
        __mln_lang_val_free((*var).val as *mut libc::c_void);
        (*var).val = 0 as *mut mln_lang_val_t;
    }
    if !((*var).in_set).is_null() {
        mln_lang_set_detail_free((*var).in_set);
        (*var).in_set = 0 as *mut mln_lang_set_detail_t;
    }
    mln_alloc_free(var as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_var_dup(
    mut ctx: *mut mln_lang_ctx_t,
    mut var: *mut mln_lang_var_t,
) -> *mut mln_lang_var_t {
    return __mln_lang_var_dup(ctx, var);
}
#[inline]
unsafe extern "C" fn __mln_lang_var_dup(
    mut ctx: *mut mln_lang_ctx_t,
    mut var: *mut mln_lang_var_t,
) -> *mut mln_lang_var_t {
    let mut ret: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut val: *mut mln_lang_val_t = (*var).val;
    if (*var).type_0 as libc::c_uint == M_LANG_VAR_NORMAL as libc::c_int as libc::c_uint
        && !((*var).val).is_null()
    {
        val = mln_lang_val_dup(ctx, (*var).val);
        if val.is_null() {
            return 0 as *mut mln_lang_var_t;
        }
    }
    ret = __mln_lang_var_new_ref_string(
        ctx,
        (*var).name,
        (*var).type_0,
        val,
        (*var).in_set,
    );
    if ret.is_null() {
        if (*var).type_0 as libc::c_uint
            == M_LANG_VAR_NORMAL as libc::c_int as libc::c_uint
            && !((*var).val).is_null()
        {
            __mln_lang_val_free(val as *mut libc::c_void);
        }
        return 0 as *mut mln_lang_var_t;
    }
    return ret;
}
#[inline]
unsafe extern "C" fn mln_lang_var_dup_with_val(
    mut ctx: *mut mln_lang_ctx_t,
    mut var: *mut mln_lang_var_t,
) -> *mut mln_lang_var_t {
    let mut ret: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut val: *mut mln_lang_val_t = 0 as *mut mln_lang_val_t;
    val = mln_lang_val_dup(ctx, (*var).val);
    if val.is_null() {
        return 0 as *mut mln_lang_var_t;
    }
    ret = __mln_lang_var_new(ctx, (*var).name, M_LANG_VAR_NORMAL, val, (*var).in_set);
    if ret.is_null() {
        __mln_lang_val_free(val as *mut libc::c_void);
        return 0 as *mut mln_lang_var_t;
    }
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_var_cmp(
    mut data1: *const libc::c_void,
    mut data2: *const libc::c_void,
) -> libc::c_int {
    let mut v1: *mut mln_lang_var_t = data1 as *mut mln_lang_var_t;
    let mut v2: *mut mln_lang_var_t = data2 as *mut mln_lang_var_t;
    if v1.is_null() && !v2.is_null() {
        return -(1 as libc::c_int)
    } else if !v1.is_null() && v2.is_null() {
        return 1 as libc::c_int
    }
    if ((*v1).val).is_null() && !((*v2).val).is_null() {
        return -(1 as libc::c_int)
    } else if !((*v1).val).is_null() && ((*v2).val).is_null() {
        return 1 as libc::c_int
    }
    return mln_lang_val_cmp(
        (*v1).val as *const libc::c_void,
        (*v2).val as *const libc::c_void,
    );
}
unsafe extern "C" fn mln_lang_var_name_cmp(
    mut data1: *const libc::c_void,
    mut data2: *const libc::c_void,
) -> libc::c_int {
    let mut v1: *mut mln_lang_var_t = data1 as *mut mln_lang_var_t;
    let mut v2: *mut mln_lang_var_t = data2 as *mut mln_lang_var_t;
    return mln_string_strcmp((*v1).name, (*v2).name);
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_var_assign(
    mut var: *mut mln_lang_var_t,
    mut val: *mut mln_lang_val_t,
) {
    __mln_lang_var_assign(var, val);
}
#[inline]
unsafe extern "C" fn __mln_lang_var_assign(
    mut var: *mut mln_lang_var_t,
    mut val: *mut mln_lang_val_t,
) {
    if !val.is_null() {
        (*val).ref_0 = ((*val).ref_0).wrapping_add(1);
        (*val).ref_0;
    }
    if !((*var).val).is_null() {
        __mln_lang_val_free((*var).val as *mut libc::c_void);
    }
    (*var).val = val;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_var_value_set(
    mut ctx: *mut mln_lang_ctx_t,
    mut dest: *mut mln_lang_var_t,
    mut src: *mut mln_lang_var_t,
) -> libc::c_int {
    return __mln_lang_var_value_set(ctx, dest, src);
}
#[inline]
unsafe extern "C" fn __mln_lang_var_value_set(
    mut ctx: *mut mln_lang_ctx_t,
    mut dest: *mut mln_lang_var_t,
    mut src: *mut mln_lang_var_t,
) -> libc::c_int {
    let mut val1: *mut mln_lang_val_t = (*dest).val;
    let mut val2: *mut mln_lang_val_t = (*src).val;
    mln_lang_val_data_free(val1);
    match (*val2).type_0 {
        0 => {
            (*val1).type_0 = 0 as libc::c_int;
            (*val1).data.s = 0 as *mut mln_string_t;
        }
        1 => {
            (*val1).type_0 = 1 as libc::c_int;
            (*val1).data.i = (*val2).data.i;
        }
        2 => {
            (*val1).type_0 = 2 as libc::c_int;
            (*val1).data.b = (*val2).data.b;
        }
        3 => {
            (*val1).type_0 = 3 as libc::c_int;
            (*val1).data.f = (*val2).data.f;
        }
        4 => {
            (*val1).type_0 = 4 as libc::c_int;
            (*val1).data.s = mln_string_pool_dup((*ctx).pool, (*val2).data.s);
            if ((*val1).data.s).is_null() {
                return -(1 as libc::c_int);
            }
        }
        5 => {
            (*val1).type_0 = 5 as libc::c_int;
            (*val1).data.obj = (*val2).data.obj;
            (*(*val1).data.obj).ref_0 = ((*(*val1).data.obj).ref_0).wrapping_add(1);
            (*(*val1).data.obj).ref_0;
        }
        6 => {
            (*val1).type_0 = 6 as libc::c_int;
            (*val1).data.func = mln_lang_func_detail_dup(ctx, (*val2).data.func);
            if ((*val1).data.func).is_null() {
                return -(1 as libc::c_int);
            }
        }
        7 => {
            (*val1).type_0 = 7 as libc::c_int;
            (*val1).data.array = (*val2).data.array;
            (*(*val1).data.array).ref_0 = ((*(*val1).data.array).ref_0).wrapping_add(1);
            (*(*val1).data.array).ref_0;
        }
        _ => return -(1 as libc::c_int),
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_var_value_set_string_ref(
    mut ctx: *mut mln_lang_ctx_t,
    mut dest: *mut mln_lang_var_t,
    mut src: *mut mln_lang_var_t,
) -> libc::c_int {
    let mut val1: *mut mln_lang_val_t = (*dest).val;
    let mut val2: *mut mln_lang_val_t = (*src).val;
    mln_lang_val_data_free(val1);
    match (*val2).type_0 {
        0 => {
            (*val1).type_0 = 0 as libc::c_int;
            (*val1).data.s = 0 as *mut mln_string_t;
        }
        1 => {
            (*val1).type_0 = 1 as libc::c_int;
            (*val1).data.i = (*val2).data.i;
        }
        2 => {
            (*val1).type_0 = 2 as libc::c_int;
            (*val1).data.b = (*val2).data.b;
        }
        3 => {
            (*val1).type_0 = 3 as libc::c_int;
            (*val1).data.f = (*val2).data.f;
        }
        4 => {
            (*val1).type_0 = 4 as libc::c_int;
            (*val1)
                .data
                .s = ({
                let mut __s: *mut mln_string_t = (*val2).data.s;
                (*__s).set_ref_0((*__s).ref_0() + 1);
                (*__s).ref_0();
                __s
            });
        }
        5 => {
            (*val1).type_0 = 5 as libc::c_int;
            (*val1).data.obj = (*val2).data.obj;
            (*(*val1).data.obj).ref_0 = ((*(*val1).data.obj).ref_0).wrapping_add(1);
            (*(*val1).data.obj).ref_0;
        }
        6 => {
            (*val1).type_0 = 6 as libc::c_int;
            (*val1).data.func = mln_lang_func_detail_dup(ctx, (*val2).data.func);
            if ((*val1).data.func).is_null() {
                return -(1 as libc::c_int);
            }
        }
        7 => {
            (*val1).type_0 = 7 as libc::c_int;
            (*val1).data.array = (*val2).data.array;
            (*(*val1).data.array).ref_0 = ((*(*val1).data.array).ref_0).wrapping_add(1);
            (*(*val1).data.array).ref_0;
        }
        _ => return -(1 as libc::c_int),
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_var_set_int(
    mut var: *mut mln_lang_var_t,
    mut i: mln_s64_t,
) {
    let mut val: *mut mln_lang_val_t = (*var).val;
    mln_lang_val_data_free(val);
    (*val).type_0 = 1 as libc::c_int;
    (*val).data.i = i;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_var_set_real(
    mut var: *mut mln_lang_var_t,
    mut r: libc::c_double,
) {
    let mut val: *mut mln_lang_val_t = (*var).val;
    mln_lang_val_data_free(val);
    (*val).type_0 = 3 as libc::c_int;
    (*val).data.f = r;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_var_set_string(
    mut var: *mut mln_lang_var_t,
    mut s: *mut mln_string_t,
) {
    let mut val: *mut mln_lang_val_t = (*var).val;
    mln_lang_val_data_free(val);
    (*val).type_0 = 4 as libc::c_int;
    (*val).data.s = s;
}
#[inline]
unsafe extern "C" fn mln_lang_funcdef_args_get(
    mut ctx: *mut mln_lang_ctx_t,
    mut exp: *mut mln_lang_exp_t,
    mut arr: *mut mln_array_t,
    mut is_closure: libc::c_int,
) -> libc::c_int {
    let mut scan: *mut mln_lang_exp_t = 0 as *mut mln_lang_exp_t;
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut v: *mut *mut mln_lang_var_t = 0 as *mut *mut mln_lang_var_t;
    let mut factor: *mut mln_lang_factor_t = 0 as *mut mln_lang_factor_t;
    let mut spec: *mut mln_lang_spec_t = 0 as *mut mln_lang_spec_t;
    let mut sym: *mut mln_lang_symbol_node_t = 0 as *mut mln_lang_symbol_node_t;
    let mut type_0: mln_lang_var_type_t = M_LANG_VAR_NORMAL;
    scan = exp;
    while !scan.is_null() {
        if ((*scan).jump).is_null() {
            mln_lang_generate_jump_ptr(scan as *mut libc::c_void, M_LSNT_EXP);
        }
        if (*scan).type_0 == M_LSNT_SPEC as libc::c_int {
            spec = (*scan).jump as *mut mln_lang_spec_t;
            if (*spec).op as libc::c_uint == M_SPEC_REFER as libc::c_int as libc::c_uint
            {
                spec = (*spec).data.spec;
                type_0 = M_LANG_VAR_REFER;
            }
            if (*spec).op as libc::c_uint != M_SPEC_FACTOR as libc::c_int as libc::c_uint
            {
                return -(1 as libc::c_int);
            }
            factor = (*spec).data.factor;
        } else if (*scan).type_0 == M_LSNT_FACTOR as libc::c_int {
            factor = (*scan).jump as *mut mln_lang_factor_t;
        } else {
            return -(1 as libc::c_int)
        }
        if (*factor).type_0 as libc::c_uint != M_FACTOR_ID as libc::c_int as libc::c_uint
        {
            return -(1 as libc::c_int);
        }
        v = mln_array_push(arr) as *mut *mut mln_lang_var_t;
        if v.is_null() {
            return -(1 as libc::c_int);
        }
        *v = __mln_lang_var_new(
            ctx,
            (*factor).data.s_id,
            type_0,
            0 as *mut mln_lang_val_t,
            0 as *mut mln_lang_set_detail_t,
        );
        if (*v).is_null() {
            return -(1 as libc::c_int);
        }
        if is_closure != 0 {
            sym = mln_lang_symbol_node_id_search(ctx, (*factor).data.s_id);
            if !sym.is_null() {
                if (*sym).type_0 as libc::c_uint
                    != M_LANG_SYMBOL_VAR as libc::c_int as libc::c_uint
                {
                    return -(1 as libc::c_int);
                }
                var = mln_lang_var_transform(ctx, (*sym).data.var, *v);
                if var.is_null() {
                    return -(1 as libc::c_int);
                }
                __mln_lang_var_free(*v as *mut libc::c_void);
                *v = var;
            }
        }
        scan = (*scan).next;
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_func_detail_new(
    mut ctx: *mut mln_lang_ctx_t,
    mut type_0: mln_lang_func_type_t,
    mut data: *mut libc::c_void,
    mut exp: *mut mln_lang_exp_t,
    mut closure: *mut mln_lang_exp_t,
) -> *mut mln_lang_func_detail_t {
    return __mln_lang_func_detail_new(ctx, type_0, data, exp, closure);
}
#[inline]
unsafe extern "C" fn __mln_lang_func_detail_new(
    mut ctx: *mut mln_lang_ctx_t,
    mut type_0: mln_lang_func_type_t,
    mut data: *mut libc::c_void,
    mut exp: *mut mln_lang_exp_t,
    mut closure: *mut mln_lang_exp_t,
) -> *mut mln_lang_func_detail_t {
    let mut lfd: *mut mln_lang_func_detail_t = 0 as *mut mln_lang_func_detail_t;
    lfd = mln_alloc_m(
        (*ctx).pool,
        ::core::mem::size_of::<mln_lang_func_detail_t>() as libc::c_ulong,
    ) as *mut mln_lang_func_detail_t;
    if lfd.is_null() {
        return 0 as *mut mln_lang_func_detail_t;
    }
    (*lfd).exp = exp;
    if mln_array_pool_init(
        &mut (*lfd).args,
        ::core::mem::transmute::<
            Option::<unsafe extern "C" fn(*mut *mut mln_lang_var_t) -> ()>,
            array_free,
        >(
            Some(
                mln_lang_var_pfree
                    as unsafe extern "C" fn(*mut *mut mln_lang_var_t) -> (),
            ),
        ),
        ::core::mem::size_of::<*mut mln_lang_var_t>() as libc::c_ulong,
        32 as libc::c_int as mln_size_t,
        (*ctx).pool as *mut libc::c_void,
        ::core::mem::transmute::<
            Option::<
                unsafe extern "C" fn(*mut mln_alloc_t, mln_size_t) -> *mut libc::c_void,
            >,
            array_pool_alloc_handler,
        >(
            Some(
                mln_alloc_m
                    as unsafe extern "C" fn(
                        *mut mln_alloc_t,
                        mln_size_t,
                    ) -> *mut libc::c_void,
            ),
        ),
        ::core::mem::transmute::<
            Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
            array_pool_free_handler,
        >(Some(mln_alloc_free as unsafe extern "C" fn(*mut libc::c_void) -> ())),
    ) < 0 as libc::c_int
    {
        mln_alloc_free(lfd as *mut libc::c_void);
        return 0 as *mut mln_lang_func_detail_t;
    }
    if mln_array_pool_init(
        &mut (*lfd).closure,
        ::core::mem::transmute::<
            Option::<unsafe extern "C" fn(*mut *mut mln_lang_var_t) -> ()>,
            array_free,
        >(
            Some(
                mln_lang_var_pfree
                    as unsafe extern "C" fn(*mut *mut mln_lang_var_t) -> (),
            ),
        ),
        ::core::mem::size_of::<*mut mln_lang_var_t>() as libc::c_ulong,
        32 as libc::c_int as mln_size_t,
        (*ctx).pool as *mut libc::c_void,
        ::core::mem::transmute::<
            Option::<
                unsafe extern "C" fn(*mut mln_alloc_t, mln_size_t) -> *mut libc::c_void,
            >,
            array_pool_alloc_handler,
        >(
            Some(
                mln_alloc_m
                    as unsafe extern "C" fn(
                        *mut mln_alloc_t,
                        mln_size_t,
                    ) -> *mut libc::c_void,
            ),
        ),
        ::core::mem::transmute::<
            Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
            array_pool_free_handler,
        >(Some(mln_alloc_free as unsafe extern "C" fn(*mut libc::c_void) -> ())),
    ) < 0 as libc::c_int
    {
        mln_array_destroy(&mut (*lfd).args);
        mln_alloc_free(lfd as *mut libc::c_void);
        return 0 as *mut mln_lang_func_detail_t;
    }
    (*lfd).type_0 = type_0;
    match type_0 as libc::c_uint {
        0 => {
            (*lfd)
                .data
                .process = ::core::mem::transmute::<
                *mut libc::c_void,
                mln_lang_internal,
            >(data);
        }
        _ => {
            (*lfd).data.stm = data as *mut mln_lang_stm_t;
        }
    }
    if !exp.is_null() {
        if mln_lang_funcdef_args_get(ctx, exp, &mut (*lfd).args, 0 as libc::c_int)
            < 0 as libc::c_int
        {
            __mln_lang_func_detail_free(lfd);
            return 0 as *mut mln_lang_func_detail_t;
        }
    }
    if !closure.is_null() {
        if mln_lang_funcdef_args_get(ctx, closure, &mut (*lfd).closure, 1 as libc::c_int)
            < 0 as libc::c_int
        {
            __mln_lang_func_detail_free(lfd);
            return 0 as *mut mln_lang_func_detail_t;
        }
    }
    return lfd;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_func_detail_free(
    mut lfd: *mut mln_lang_func_detail_t,
) {
    __mln_lang_func_detail_free(lfd);
}
#[inline]
unsafe extern "C" fn __mln_lang_func_detail_free(mut lfd: *mut mln_lang_func_detail_t) {
    if lfd.is_null() {
        return;
    }
    mln_array_destroy(&mut (*lfd).args);
    mln_array_destroy(&mut (*lfd).closure);
    mln_alloc_free(lfd as *mut libc::c_void);
}
#[inline]
unsafe extern "C" fn mln_lang_func_detail_dup(
    mut ctx: *mut mln_lang_ctx_t,
    mut func: *mut mln_lang_func_detail_t,
) -> *mut mln_lang_func_detail_t {
    let mut ret: *mut mln_lang_func_detail_t = 0 as *mut mln_lang_func_detail_t;
    let mut var: *mut *mut mln_lang_var_t = 0 as *mut *mut mln_lang_var_t;
    let mut v: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut data: mln_u8ptr_t = 0 as *mut libc::c_uchar;
    let mut i: mln_size_t = 0;
    match (*func).type_0 as libc::c_uint {
        0 => {
            data = ::core::mem::transmute::<
                mln_lang_internal,
                mln_u8ptr_t,
            >((*func).data.process);
        }
        _ => {
            data = (*func).data.stm as mln_u8ptr_t;
        }
    }
    ret = __mln_lang_func_detail_new(
        ctx,
        (*func).type_0,
        data as *mut libc::c_void,
        0 as *mut mln_lang_exp_t,
        0 as *mut mln_lang_exp_t,
    );
    if ret.is_null() {
        return 0 as *mut mln_lang_func_detail_t;
    }
    i = 0 as libc::c_int as mln_size_t;
    while i < (*func).args.nelts {
        var = mln_array_push(&mut (*ret).args) as *mut *mut mln_lang_var_t;
        if var.is_null() {
            __mln_lang_func_detail_free(ret);
            return 0 as *mut mln_lang_func_detail_t;
        }
        v = *((*func).args.elts as *mut *mut mln_lang_var_t).offset(i as isize);
        *var = __mln_lang_var_dup(ctx, v);
        if (*var).is_null() {
            __mln_lang_func_detail_free(ret);
            return 0 as *mut mln_lang_func_detail_t;
        }
        i = i.wrapping_add(1);
        i;
    }
    i = 0 as libc::c_int as mln_size_t;
    while i < (*func).closure.nelts {
        var = mln_array_push(&mut (*ret).closure) as *mut *mut mln_lang_var_t;
        if var.is_null() {
            __mln_lang_func_detail_free(ret);
            return 0 as *mut mln_lang_func_detail_t;
        }
        v = *((*func).closure.elts as *mut *mut mln_lang_var_t).offset(i as isize);
        *var = __mln_lang_var_dup(ctx, v);
        if (*var).is_null() {
            __mln_lang_func_detail_free(ret);
            return 0 as *mut mln_lang_func_detail_t;
        }
        i = i.wrapping_add(1);
        i;
    }
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_func_detail_arg_append(
    mut func: *mut mln_lang_func_detail_t,
    mut var: *mut mln_lang_var_t,
) -> libc::c_int {
    let mut v: *mut *mut mln_lang_var_t = 0 as *mut *mut mln_lang_var_t;
    v = mln_array_push(&mut (*func).args) as *mut *mut mln_lang_var_t;
    if v.is_null() {
        return -(1 as libc::c_int);
    }
    *v = var;
    return 0 as libc::c_int;
}
#[inline]
unsafe extern "C" fn mln_lang_object_new(
    mut ctx: *mut mln_lang_ctx_t,
    mut in_set: *mut mln_lang_set_detail_t,
) -> *mut mln_lang_object_t {
    let mut rbattr: mln_rbtree_attr = mln_rbtree_attr {
        pool: 0 as *mut libc::c_void,
        pool_alloc: None,
        pool_free: None,
        cmp: None,
        data_free: None,
    };
    let mut obj: *mut mln_lang_object_t = 0 as *mut mln_lang_object_t;
    obj = mln_alloc_m(
        (*ctx).pool,
        ::core::mem::size_of::<mln_lang_object_t>() as libc::c_ulong,
    ) as *mut mln_lang_object_t;
    if obj.is_null() {
        return 0 as *mut mln_lang_object_t;
    }
    (*obj).in_set = in_set;
    if !in_set.is_null() {
        (*in_set).ref_0 = ((*in_set).ref_0).wrapping_add(1);
        (*in_set).ref_0;
    }
    rbattr.pool = (*ctx).pool as *mut libc::c_void;
    rbattr
        .pool_alloc = ::core::mem::transmute::<
        Option::<
            unsafe extern "C" fn(*mut mln_alloc_t, mln_size_t) -> *mut libc::c_void,
        >,
        rbtree_pool_alloc_handler,
    >(
        Some(
            mln_alloc_m
                as unsafe extern "C" fn(
                    *mut mln_alloc_t,
                    mln_size_t,
                ) -> *mut libc::c_void,
        ),
    );
    rbattr
        .pool_free = ::core::mem::transmute::<
        Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
        rbtree_pool_free_handler,
    >(Some(mln_alloc_free as unsafe extern "C" fn(*mut libc::c_void) -> ()));
    rbattr
        .cmp = Some(
        mln_lang_var_name_cmp
            as unsafe extern "C" fn(
                *const libc::c_void,
                *const libc::c_void,
            ) -> libc::c_int,
    );
    rbattr
        .data_free = Some(
        mln_lang_var_free as unsafe extern "C" fn(*mut libc::c_void) -> (),
    );
    (*obj).members = mln_rbtree_new(&mut rbattr);
    if ((*obj).members).is_null() {
        mln_alloc_free(obj as *mut libc::c_void);
        return 0 as *mut mln_lang_object_t;
    }
    (*obj).ref_0 = 0 as libc::c_int as mln_u64_t;
    if !in_set.is_null() {
        let mut ls: mln_lang_scan_s = mln_lang_scan_s {
            cnt: 0 as *mut libc::c_int,
            tree: 0 as *mut mln_rbtree_t,
            tree2: 0 as *mut mln_rbtree_t,
            ctx: 0 as *mut mln_lang_ctx_t,
        };
        ls.cnt = 0 as *mut libc::c_int;
        ls.tree = (*obj).members;
        ls.tree2 = 0 as *mut mln_rbtree_t;
        ls.ctx = ctx;
        if mln_rbtree_iterate(
            (*in_set).members,
            Some(
                mln_lang_set_member_iterate_handler
                    as unsafe extern "C" fn(
                        *mut mln_rbtree_node_t,
                        *mut libc::c_void,
                    ) -> libc::c_int,
            ),
            &mut ls as *mut mln_lang_scan_s as *mut libc::c_void,
        ) < 0 as libc::c_int
        {
            mln_lang_object_free(obj);
            return 0 as *mut mln_lang_object_t;
        }
    }
    (*obj).gc_item = 0 as *mut mln_lang_gc_item_t;
    (*obj).ctx = ctx;
    if mln_lang_gc_item_new((*ctx).pool, (*ctx).gc, M_GC_OBJ, obj as *mut libc::c_void)
        < 0 as libc::c_int
    {
        mln_lang_object_free(obj);
        obj = 0 as *mut mln_lang_object_t;
    }
    return obj;
}
#[inline]
unsafe extern "C" fn mln_lang_object_free(mut obj: *mut mln_lang_object_t) {
    if obj.is_null() {
        return;
    }
    if (*obj).ref_0 > 1 as libc::c_int as libc::c_ulong {
        if !((*(*obj).gc_item).gc).is_null() {
            mln_gc_suspect((*(*obj).gc_item).gc, (*obj).gc_item as *mut libc::c_void);
        }
        (*obj).ref_0 = ((*obj).ref_0).wrapping_sub(1);
        (*obj).ref_0;
        return;
    }
    if !((*obj).members).is_null() {
        mln_rbtree_free((*obj).members);
    }
    if !((*obj).in_set).is_null() {
        mln_lang_set_detail_free((*obj).in_set);
    }
    if !((*obj).gc_item).is_null() {
        if !((*(*obj).gc_item).gc).is_null() {
            mln_gc_remove(
                (*(*obj).gc_item).gc,
                (*obj).gc_item as *mut libc::c_void,
                (*(*obj).ctx).gc,
            );
        }
        mln_lang_gc_item_free_immediatly((*obj).gc_item);
    }
    mln_alloc_free(obj as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_val_new(
    mut ctx: *mut mln_lang_ctx_t,
    mut type_0: mln_s32_t,
    mut data: *mut libc::c_void,
) -> *mut mln_lang_val_t {
    return __mln_lang_val_new(ctx, type_0, data);
}
#[inline]
unsafe extern "C" fn __mln_lang_val_new(
    mut ctx: *mut mln_lang_ctx_t,
    mut type_0: mln_s32_t,
    mut data: *mut libc::c_void,
) -> *mut mln_lang_val_t {
    let mut val: *mut mln_lang_val_t = 0 as *mut mln_lang_val_t;
    val = mln_alloc_m(
        (*ctx).pool,
        ::core::mem::size_of::<mln_lang_val_t>() as libc::c_ulong,
    ) as *mut mln_lang_val_t;
    if val.is_null() {
        return 0 as *mut mln_lang_val_t;
    }
    (*val).next = 0 as *mut mln_lang_val_s;
    (*val).prev = (*val).next;
    match type_0 {
        0 => {}
        1 => {
            (*val).data.i = *(data as *mut mln_s64_t);
        }
        2 => {
            (*val).data.b = *(data as mln_u8ptr_t);
        }
        3 => {
            (*val).data.f = *(data as *mut libc::c_double);
        }
        4 => {
            (*val).data.s = data as *mut mln_string_t;
        }
        5 => {
            (*val).data.obj = data as *mut mln_lang_object_t;
            (*(*val).data.obj).ref_0 = ((*(*val).data.obj).ref_0).wrapping_add(1);
            (*(*val).data.obj).ref_0;
        }
        6 => {
            (*val).data.func = data as *mut mln_lang_func_detail_t;
        }
        7 => {
            (*val).data.array = data as *mut mln_lang_array_t;
            (*(*val).data.array).ref_0 = ((*(*val).data.array).ref_0).wrapping_add(1);
            (*(*val).data.array).ref_0;
        }
        8 => {
            (*val).data.call = data as *mut mln_lang_funccall_val_t;
        }
        _ => {
            mln_alloc_free(val as *mut libc::c_void);
            return 0 as *mut mln_lang_val_t;
        }
    }
    (*val).type_0 = type_0;
    (*val).ref_0 = 0 as libc::c_int as mln_u32_t;
    (*val).udata = 0 as *mut mln_lang_val_t;
    (*val).func = 0 as *mut mln_lang_func_detail_t;
    (*val).set_not_modify(0 as libc::c_int as mln_u32_t);
    return val;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_val_free(mut val: *mut mln_lang_val_t) {
    __mln_lang_val_free(val as *mut libc::c_void);
}
#[inline]
unsafe extern "C" fn __mln_lang_val_free(mut data: *mut libc::c_void) {
    if data.is_null() {
        return;
    }
    let mut val: *mut mln_lang_val_t = data as *mut mln_lang_val_t;
    let fresh28 = (*val).ref_0;
    (*val).ref_0 = ((*val).ref_0).wrapping_sub(1);
    if fresh28 > 1 as libc::c_int as libc::c_uint {
        return;
    }
    if !((*val).udata).is_null() && (*val).udata != val {
        mln_lang_val_free((*val).udata);
        (*val).udata = 0 as *mut mln_lang_val_t;
    }
    if !((*val).func).is_null() {
        __mln_lang_func_detail_free((*val).func);
        (*val).func = 0 as *mut mln_lang_func_detail_t;
    }
    mln_lang_val_data_free(val);
    mln_alloc_free(val as *mut libc::c_void);
}
#[inline]
unsafe extern "C" fn mln_lang_val_data_free(mut val: *mut mln_lang_val_t) {
    match (*val).type_0 {
        5 => {
            if !((*val).data.obj).is_null() {
                mln_lang_object_free((*val).data.obj);
                (*val).data.obj = 0 as *mut mln_lang_object_t;
            }
        }
        6 => {
            if !((*val).data.func).is_null() {
                __mln_lang_func_detail_free((*val).data.func);
                (*val).data.func = 0 as *mut mln_lang_func_detail_t;
            }
        }
        7 => {
            if !((*val).data.array).is_null() {
                __mln_lang_array_free((*val).data.array);
                (*val).data.array = 0 as *mut mln_lang_array_t;
            }
        }
        4 => {
            if !((*val).data.s).is_null() {
                let mut __s: *mut mln_string_t = (*val).data.s;
                if !__s.is_null() {
                    let ref mut fresh29 = (*__s).ref_0();
                    let fresh30 = *fresh29;
                    *fresh29 = (*fresh29).wrapping_sub(1);
                    if fresh30 <= 1 as libc::c_int as libc::c_ulong {
                        if (*__s).data_ref() == 0 && !((*__s).data).is_null() {
                            if (*__s).pool() != 0 {
                                mln_alloc_free((*__s).data as *mut libc::c_void);
                            } else {
                                free((*__s).data as *mut libc::c_void);
                            }
                        }
                        if (*__s).pool() != 0 {
                            mln_alloc_free(__s as *mut libc::c_void);
                        } else {
                            free(__s as *mut libc::c_void);
                        }
                    }
                }
                (*val).data.s = 0 as *mut mln_string_t;
            }
        }
        8 => {
            if !((*val).data.call).is_null() {
                __mln_lang_funccall_val_free((*val).data.call);
                (*val).data.call = 0 as *mut mln_lang_funccall_val_t;
            }
        }
        _ => {
            (*val).data.i = 0 as libc::c_int as mln_s64_t;
        }
    }
    (*val).type_0 = 0 as libc::c_int;
}
#[inline]
unsafe extern "C" fn mln_lang_val_dup(
    mut ctx: *mut mln_lang_ctx_t,
    mut val: *mut mln_lang_val_t,
) -> *mut mln_lang_val_t {
    let mut data: mln_u8ptr_t = 0 as *mut libc::c_uchar;
    let mut type_0: mln_u32_t = (*val).type_0 as mln_u32_t;
    match type_0 {
        0 => {
            data = 0 as mln_u8ptr_t;
        }
        1 => {
            data = &mut (*val).data.i as *mut mln_s64_t as mln_u8ptr_t;
        }
        2 => {
            data = &mut (*val).data.b as *mut mln_u8_t as mln_u8ptr_t;
        }
        3 => {
            data = &mut (*val).data.f as *mut libc::c_double as mln_u8ptr_t;
        }
        4 => {
            data = ({
                let mut __s: *mut mln_string_t = (*val).data.s;
                (*__s).set_ref_0((*__s).ref_0() + 1);
                (*__s).ref_0();
                __s
            }) as mln_u8ptr_t;
        }
        5 => {
            data = (*val).data.obj as mln_u8ptr_t;
        }
        6 => {
            data = mln_lang_func_detail_dup(ctx, (*val).data.func) as mln_u8ptr_t;
            if data.is_null() {
                return 0 as *mut mln_lang_val_t;
            }
        }
        7 => {
            data = (*val).data.array as mln_u8ptr_t;
        }
        _ => return 0 as *mut mln_lang_val_t,
    }
    let mut ret: *mut mln_lang_val_t = __mln_lang_val_new(
        ctx,
        type_0 as mln_s32_t,
        data as *mut libc::c_void,
    );
    if ret.is_null() {
        match type_0 {
            4 => {
                let mut __s: *mut mln_string_t = data as *mut mln_string_t;
                if !__s.is_null() {
                    let ref mut fresh31 = (*__s).ref_0();
                    let fresh32 = *fresh31;
                    *fresh31 = (*fresh31).wrapping_sub(1);
                    if fresh32 <= 1 as libc::c_int as libc::c_ulong {
                        if (*__s).data_ref() == 0 && !((*__s).data).is_null() {
                            if (*__s).pool() != 0 {
                                mln_alloc_free((*__s).data as *mut libc::c_void);
                            } else {
                                free((*__s).data as *mut libc::c_void);
                            }
                        }
                        if (*__s).pool() != 0 {
                            mln_alloc_free(__s as *mut libc::c_void);
                        } else {
                            free(__s as *mut libc::c_void);
                        }
                    }
                }
            }
            6 => {
                __mln_lang_func_detail_free(data as *mut mln_lang_func_detail_t);
            }
            _ => {}
        }
    }
    return ret;
}
unsafe extern "C" fn mln_lang_val_cmp(
    mut data1: *const libc::c_void,
    mut data2: *const libc::c_void,
) -> libc::c_int {
    let mut ret: libc::c_int = 0;
    let mut val1: *mut mln_lang_val_t = data1 as *mut mln_lang_val_t;
    let mut val2: *mut mln_lang_val_t = data2 as *mut mln_lang_val_t;
    if (*val1).type_0 != (*val2).type_0 {
        return (*val1).type_0 - (*val2).type_0;
    }
    match (*val1).type_0 {
        0 => {
            ret = 0 as libc::c_int;
        }
        1 => {
            if (*val1).data.i > (*val2).data.i {
                ret = 1 as libc::c_int;
            } else if (*val1).data.i < (*val2).data.i {
                ret = -(1 as libc::c_int);
            } else {
                ret = 0 as libc::c_int;
            }
        }
        2 => {
            ret = (*val1).data.b as libc::c_int - (*val2).data.b as libc::c_int;
        }
        3 => {
            if (*val1).data.f > (*val2).data.f {
                ret = 1 as libc::c_int;
            } else if (*val1).data.f < (*val2).data.f {
                ret = -(1 as libc::c_int);
            } else {
                ret = 0 as libc::c_int;
            }
        }
        4 => {
            ret = mln_string_strcmp((*val1).data.s, (*val2).data.s);
        }
        5 => {
            if (*val1).data.obj > (*val2).data.obj {
                ret = 1 as libc::c_int;
            } else if (*val1).data.obj < (*val2).data.obj {
                ret = -(1 as libc::c_int);
            } else {
                ret = 0 as libc::c_int;
            }
        }
        6 => {
            if (*(*val1).data.func).type_0 as libc::c_uint
                > (*(*val2).data.func).type_0 as libc::c_uint
            {
                ret = 1 as libc::c_int;
            } else if ((*(*val1).data.func).type_0 as libc::c_uint)
                < (*(*val2).data.func).type_0 as libc::c_uint
            {
                ret = -(1 as libc::c_int);
            } else {
                let mut type_0: mln_lang_func_type_t = (*(*val1).data.func).type_0;
                let mut f1: *mut mln_lang_func_detail_t = (*val1).data.func;
                let mut f2: *mut mln_lang_func_detail_t = (*val2).data.func;
                match type_0 as libc::c_uint {
                    0 => {
                        if ::core::mem::transmute::<
                            mln_lang_internal,
                            mln_uptr_t,
                        >((*f1).data.process)
                            > ::core::mem::transmute::<
                                mln_lang_internal,
                                mln_uptr_t,
                            >((*f2).data.process)
                        {
                            ret = 1 as libc::c_int;
                        } else if ::core::mem::transmute::<
                            mln_lang_internal,
                            mln_uptr_t,
                        >((*f1).data.process)
                            < ::core::mem::transmute::<
                                mln_lang_internal,
                                mln_uptr_t,
                            >((*f2).data.process)
                        {
                            ret = -(1 as libc::c_int);
                        } else {
                            ret = 0 as libc::c_int;
                        }
                    }
                    _ => {
                        if (*f1).data.stm > (*f2).data.stm {
                            ret = 1 as libc::c_int;
                        } else if (*f1).data.stm < (*f2).data.stm {
                            ret = -(1 as libc::c_int);
                        } else {
                            ret = 0 as libc::c_int;
                        }
                    }
                }
            }
        }
        7 => {
            if (*val1).data.array > (*val2).data.array {
                ret = 1 as libc::c_int;
            } else if (*val1).data.array < (*val2).data.array {
                ret = -(1 as libc::c_int);
            } else {
                ret = 0 as libc::c_int;
            }
        }
        _ => {
            _mln_sys_log(
                error,
                b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<
                    &[u8; 17],
                    &[libc::c_char; 17],
                >(b"mln_lang_val_cmp\0"))
                    .as_ptr(),
                2743 as libc::c_int,
                b"No such type %x\n\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                (*val1).type_0,
            );
            abort();
        }
    }
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_array_new(
    mut ctx: *mut mln_lang_ctx_t,
) -> *mut mln_lang_array_t {
    return __mln_lang_array_new(ctx);
}
#[inline]
unsafe extern "C" fn __mln_lang_array_new(
    mut ctx: *mut mln_lang_ctx_t,
) -> *mut mln_lang_array_t {
    let mut la: *mut mln_lang_array_t = 0 as *mut mln_lang_array_t;
    let mut rbattr: mln_rbtree_attr = mln_rbtree_attr {
        pool: 0 as *mut libc::c_void,
        pool_alloc: None,
        pool_free: None,
        cmp: None,
        data_free: None,
    };
    la = mln_alloc_m(
        (*ctx).pool,
        ::core::mem::size_of::<mln_lang_array_t>() as libc::c_ulong,
    ) as *mut mln_lang_array_t;
    if la.is_null() {
        return 0 as *mut mln_lang_array_t;
    }
    rbattr.pool = (*ctx).pool as *mut libc::c_void;
    rbattr
        .pool_alloc = ::core::mem::transmute::<
        Option::<
            unsafe extern "C" fn(*mut mln_alloc_t, mln_size_t) -> *mut libc::c_void,
        >,
        rbtree_pool_alloc_handler,
    >(
        Some(
            mln_alloc_m
                as unsafe extern "C" fn(
                    *mut mln_alloc_t,
                    mln_size_t,
                ) -> *mut libc::c_void,
        ),
    );
    rbattr
        .pool_free = ::core::mem::transmute::<
        Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
        rbtree_pool_free_handler,
    >(Some(mln_alloc_free as unsafe extern "C" fn(*mut libc::c_void) -> ()));
    rbattr
        .cmp = Some(
        mln_lang_array_elem_index_cmp
            as unsafe extern "C" fn(
                *const libc::c_void,
                *const libc::c_void,
            ) -> libc::c_int,
    );
    rbattr
        .data_free = Some(
        mln_lang_array_elem_free as unsafe extern "C" fn(*mut libc::c_void) -> (),
    );
    (*la).elems_index = mln_rbtree_new(&mut rbattr);
    if ((*la).elems_index).is_null() {
        mln_alloc_free(la as *mut libc::c_void);
        return 0 as *mut mln_lang_array_t;
    }
    rbattr
        .cmp = Some(
        mln_lang_array_elem_key_cmp
            as unsafe extern "C" fn(
                *const libc::c_void,
                *const libc::c_void,
            ) -> libc::c_int,
    );
    rbattr.data_free = None;
    (*la).elems_key = mln_rbtree_new(&mut rbattr);
    if ((*la).elems_key).is_null() {
        mln_rbtree_free((*la).elems_index);
        mln_alloc_free(la as *mut libc::c_void);
        return 0 as *mut mln_lang_array_t;
    }
    (*la).index = 0 as libc::c_int as mln_u64_t;
    (*la).ref_0 = 0 as libc::c_int as mln_u64_t;
    (*la).gc_item = 0 as *mut mln_lang_gc_item_t;
    (*la).ctx = ctx;
    if mln_lang_gc_item_new((*ctx).pool, (*ctx).gc, M_GC_ARRAY, la as *mut libc::c_void)
        < 0 as libc::c_int
    {
        __mln_lang_array_free(la);
        la = 0 as *mut mln_lang_array_t;
    }
    return la;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_array_free(mut array: *mut mln_lang_array_t) {
    __mln_lang_array_free(array);
}
#[inline]
unsafe extern "C" fn __mln_lang_array_free(mut array: *mut mln_lang_array_t) {
    if array.is_null() {
        return;
    }
    if (*array).ref_0 > 1 as libc::c_int as libc::c_ulong {
        if !((*(*array).gc_item).gc).is_null() {
            mln_gc_suspect(
                (*(*array).gc_item).gc,
                (*array).gc_item as *mut libc::c_void,
            );
        }
        (*array).ref_0 = ((*array).ref_0).wrapping_sub(1);
        (*array).ref_0;
        return;
    }
    if !((*array).elems_key).is_null() {
        mln_rbtree_free((*array).elems_key);
    }
    if !((*array).elems_index).is_null() {
        mln_rbtree_free((*array).elems_index);
    }
    if !((*array).gc_item).is_null() {
        if !((*(*array).gc_item).gc).is_null() {
            mln_gc_remove(
                (*(*array).gc_item).gc,
                (*array).gc_item as *mut libc::c_void,
                (*(*array).ctx).gc,
            );
        }
        mln_lang_gc_item_free_immediatly((*array).gc_item);
    }
    mln_alloc_free(array as *mut libc::c_void);
}
unsafe extern "C" fn mln_lang_array_elem_index_cmp(
    mut data1: *const libc::c_void,
    mut data2: *const libc::c_void,
) -> libc::c_int {
    let mut elem1: *mut mln_lang_array_elem_t = data1 as *mut mln_lang_array_elem_t;
    let mut elem2: *mut mln_lang_array_elem_t = data2 as *mut mln_lang_array_elem_t;
    if (*elem1).index > (*elem2).index {
        return 1 as libc::c_int;
    }
    if (*elem1).index < (*elem2).index {
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn mln_lang_array_elem_key_cmp(
    mut data1: *const libc::c_void,
    mut data2: *const libc::c_void,
) -> libc::c_int {
    let mut elem1: *mut mln_lang_array_elem_t = data1 as *mut mln_lang_array_elem_t;
    let mut elem2: *mut mln_lang_array_elem_t = data2 as *mut mln_lang_array_elem_t;
    return mln_lang_var_cmp(
        (*elem1).key as *const libc::c_void,
        (*elem2).key as *const libc::c_void,
    );
}
#[inline]
unsafe extern "C" fn mln_lang_array_elem_new(
    mut pool: *mut mln_alloc_t,
    mut key: *mut mln_lang_var_t,
    mut val: *mut mln_lang_var_t,
    mut index: mln_u64_t,
) -> *mut mln_lang_array_elem_t {
    let mut elem: *mut mln_lang_array_elem_t = 0 as *mut mln_lang_array_elem_t;
    elem = mln_alloc_m(
        pool,
        ::core::mem::size_of::<mln_lang_array_elem_t>() as libc::c_ulong,
    ) as *mut mln_lang_array_elem_t;
    if elem.is_null() {
        return 0 as *mut mln_lang_array_elem_t;
    }
    (*elem).index = index;
    (*elem).key = key;
    (*elem).value = val;
    return elem;
}
#[inline]
unsafe extern "C" fn mln_lang_array_elem_free(mut data: *mut libc::c_void) {
    if data.is_null() {
        return;
    }
    let mut elem: *mut mln_lang_array_elem_t = data as *mut mln_lang_array_elem_t;
    if !((*elem).key).is_null() {
        __mln_lang_var_free((*elem).key as *mut libc::c_void);
    }
    if !((*elem).value).is_null() {
        __mln_lang_var_free((*elem).value as *mut libc::c_void);
    }
    mln_alloc_free(elem as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_array_get(
    mut ctx: *mut mln_lang_ctx_t,
    mut array: *mut mln_lang_array_t,
    mut key: *mut mln_lang_var_t,
) -> *mut mln_lang_var_t {
    return __mln_lang_array_get(ctx, array, key);
}
#[inline]
unsafe extern "C" fn __mln_lang_array_get(
    mut ctx: *mut mln_lang_ctx_t,
    mut array: *mut mln_lang_array_t,
    mut key: *mut mln_lang_var_t,
) -> *mut mln_lang_var_t {
    let mut type_0: mln_s32_t = 0;
    let mut ret: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    if !key.is_null()
        && {
            type_0 = (*(*key).val).type_0;
            type_0 != 0 as libc::c_int
        }
    {
        if type_0 == 1 as libc::c_int {
            ret = mln_lang_array_get_int(ctx, array, key);
            if ret.is_null() {
                return 0 as *mut mln_lang_var_t;
            }
        } else {
            ret = mln_lang_array_get_other(ctx, array, key);
            if ret.is_null() {
                return 0 as *mut mln_lang_var_t;
            }
        }
    } else {
        ret = mln_lang_array_get_nil(ctx, array);
        if ret.is_null() {
            return 0 as *mut mln_lang_var_t;
        }
    }
    return ret;
}
#[inline]
unsafe extern "C" fn mln_lang_array_get_int(
    mut ctx: *mut mln_lang_ctx_t,
    mut array: *mut mln_lang_array_t,
    mut key: *mut mln_lang_var_t,
) -> *mut mln_lang_var_t {
    let mut tree: *mut mln_rbtree_t = 0 as *mut mln_rbtree_t;
    let mut rn: *mut mln_rbtree_node_t = 0 as *mut mln_rbtree_node_t;
    let mut ret: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut nil: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut elem: *mut mln_lang_array_elem_t = 0 as *mut mln_lang_array_elem_t;
    nil = __mln_lang_var_create_nil(ctx, 0 as *mut mln_string_t);
    if nil.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        return 0 as *mut mln_lang_var_t;
    }
    elem = mln_lang_array_elem_new(
        (*ctx).pool,
        0 as *mut mln_lang_var_t,
        nil,
        (*(*key).val).data.i as mln_u64_t,
    );
    if elem.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        __mln_lang_var_free(nil as *mut libc::c_void);
        return 0 as *mut mln_lang_var_t;
    }
    tree = (*array).elems_index;
    rn = mln_rbtree_search(tree, elem as *mut libc::c_void);
    if !(rn == &mut (*tree).nil as *mut mln_rbtree_node_t) {
        mln_lang_array_elem_free(elem as *mut libc::c_void);
        ret = (*((*rn).data as *mut mln_lang_array_elem_t)).value;
    } else {
        rn = mln_rbtree_node_new(tree, elem as *mut libc::c_void);
        if rn.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            mln_lang_array_elem_free(elem as *mut libc::c_void);
            return 0 as *mut mln_lang_var_t;
        }
        mln_rbtree_insert(tree, rn);
        if (*array).index <= (*(*key).val).data.i as libc::c_ulong {
            (*array)
                .index = ((*(*key).val).data.i + 1 as libc::c_int as libc::c_long)
                as mln_u64_t;
        }
        ret = (*elem).value;
    }
    return ret;
}
#[inline]
unsafe extern "C" fn mln_lang_array_get_other(
    mut ctx: *mut mln_lang_ctx_t,
    mut array: *mut mln_lang_array_t,
    mut key: *mut mln_lang_var_t,
) -> *mut mln_lang_var_t {
    let mut tree: *mut mln_rbtree_t = 0 as *mut mln_rbtree_t;
    let mut rn: *mut mln_rbtree_node_t = 0 as *mut mln_rbtree_node_t;
    let mut ret: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut nil: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut k: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut elem: *mut mln_lang_array_elem_t = 0 as *mut mln_lang_array_elem_t;
    nil = __mln_lang_var_create_nil(ctx, 0 as *mut mln_string_t);
    if nil.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        return 0 as *mut mln_lang_var_t;
    }
    k = mln_lang_var_dup_with_val(ctx, key);
    if k.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        __mln_lang_var_free(nil as *mut libc::c_void);
        return 0 as *mut mln_lang_var_t;
    }
    elem = mln_lang_array_elem_new((*ctx).pool, k, nil, (*array).index);
    if elem.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        __mln_lang_var_free(k as *mut libc::c_void);
        __mln_lang_var_free(nil as *mut libc::c_void);
        return 0 as *mut mln_lang_var_t;
    }
    tree = (*array).elems_key;
    rn = mln_rbtree_search(tree, elem as *mut libc::c_void);
    if !(rn == &mut (*tree).nil as *mut mln_rbtree_node_t) {
        mln_lang_array_elem_free(elem as *mut libc::c_void);
        ret = (*((*rn).data as *mut mln_lang_array_elem_t)).value;
    } else {
        rn = mln_rbtree_node_new(tree, elem as *mut libc::c_void);
        if rn.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            mln_lang_array_elem_free(elem as *mut libc::c_void);
            return 0 as *mut mln_lang_var_t;
        }
        mln_rbtree_insert(tree, rn);
        tree = (*array).elems_index;
        rn = mln_rbtree_node_new(tree, elem as *mut libc::c_void);
        if rn.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            mln_lang_array_elem_free(elem as *mut libc::c_void);
            return 0 as *mut mln_lang_var_t;
        }
        mln_rbtree_insert(tree, rn);
        (*array).index = ((*array).index).wrapping_add(1);
        (*array).index;
        ret = (*elem).value;
    }
    return ret;
}
#[inline]
unsafe extern "C" fn mln_lang_array_get_nil(
    mut ctx: *mut mln_lang_ctx_t,
    mut array: *mut mln_lang_array_t,
) -> *mut mln_lang_var_t {
    let mut rn: *mut mln_rbtree_node_t = 0 as *mut mln_rbtree_node_t;
    let mut nil: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut elem: *mut mln_lang_array_elem_t = 0 as *mut mln_lang_array_elem_t;
    nil = __mln_lang_var_create_nil(ctx, 0 as *mut mln_string_t);
    if nil.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        return 0 as *mut mln_lang_var_t;
    }
    elem = mln_lang_array_elem_new(
        (*ctx).pool,
        0 as *mut mln_lang_var_t,
        nil,
        (*array).index,
    );
    if elem.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        __mln_lang_var_free(nil as *mut libc::c_void);
        return 0 as *mut mln_lang_var_t;
    }
    rn = mln_rbtree_node_new((*array).elems_index, elem as *mut libc::c_void);
    if rn.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        mln_lang_array_elem_free(elem as *mut libc::c_void);
        return 0 as *mut mln_lang_var_t;
    }
    mln_rbtree_insert((*array).elems_index, rn);
    (*array).index = ((*array).index).wrapping_add(1);
    (*array).index;
    return (*elem).value;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_array_elem_exist(
    mut array: *mut mln_lang_array_t,
    mut key: *mut mln_lang_var_t,
) -> libc::c_int {
    let mut tree: *mut mln_rbtree_t = 0 as *mut mln_rbtree_t;
    let mut rn: *mut mln_rbtree_node_t = 0 as *mut mln_rbtree_node_t;
    let mut nil: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut k: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut elem: *mut mln_lang_array_elem_t = 0 as *mut mln_lang_array_elem_t;
    let mut ctx: *mut mln_lang_ctx_t = (*array).ctx;
    nil = __mln_lang_var_create_nil(ctx, 0 as *mut mln_string_t);
    if nil.is_null() {
        return 0 as libc::c_int;
    }
    if (*(*key).val).type_0 == 1 as libc::c_int {
        elem = mln_lang_array_elem_new(
            (*ctx).pool,
            0 as *mut mln_lang_var_t,
            nil,
            (*(*key).val).data.i as mln_u64_t,
        );
        if elem.is_null() {
            __mln_lang_var_free(nil as *mut libc::c_void);
            return 0 as libc::c_int;
        }
        tree = (*array).elems_index;
        rn = mln_rbtree_search(tree, elem as *mut libc::c_void);
        mln_lang_array_elem_free(elem as *mut libc::c_void);
        if rn == &mut (*tree).nil as *mut mln_rbtree_node_t {
            return 0 as libc::c_int;
        }
        return 1 as libc::c_int;
    }
    k = mln_lang_var_dup_with_val(ctx, key);
    if k.is_null() {
        __mln_lang_var_free(nil as *mut libc::c_void);
        return 0 as libc::c_int;
    }
    elem = mln_lang_array_elem_new((*ctx).pool, k, nil, (*array).index);
    if elem.is_null() {
        __mln_lang_var_free(k as *mut libc::c_void);
        __mln_lang_var_free(nil as *mut libc::c_void);
        return 0 as libc::c_int;
    }
    tree = (*array).elems_key;
    rn = mln_rbtree_search(tree, elem as *mut libc::c_void);
    mln_lang_array_elem_free(elem as *mut libc::c_void);
    if rn == &mut (*tree).nil as *mut mln_rbtree_node_t {
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
#[inline]
unsafe extern "C" fn __mln_lang_funccall_val_new(
    mut pool: *mut mln_alloc_t,
    mut name: *mut mln_string_t,
) -> *mut mln_lang_funccall_val_t {
    let mut func: *mut mln_lang_funccall_val_t = 0 as *mut mln_lang_funccall_val_t;
    func = mln_alloc_m(
        pool,
        ::core::mem::size_of::<mln_lang_funccall_val_t>() as libc::c_ulong,
    ) as *mut mln_lang_funccall_val_t;
    if func.is_null() {
        return 0 as *mut mln_lang_funccall_val_t;
    }
    if !name.is_null() {
        (*func)
            .name = ({
            let mut __s: *mut mln_string_t = name;
            (*__s).set_ref_0((*__s).ref_0() + 1);
            (*__s).ref_0();
            __s
        });
    } else {
        (*func).name = 0 as *mut mln_string_t;
    }
    (*func).prototype = 0 as *mut mln_lang_func_detail_t;
    (*func).object = 0 as *mut mln_lang_val_t;
    if mln_array_pool_init(
        &mut (*func).args,
        ::core::mem::transmute::<
            Option::<unsafe extern "C" fn(*mut *mut mln_lang_var_t) -> ()>,
            array_free,
        >(
            Some(
                mln_lang_var_pfree
                    as unsafe extern "C" fn(*mut *mut mln_lang_var_t) -> (),
            ),
        ),
        ::core::mem::size_of::<*mut mln_lang_var_t>() as libc::c_ulong,
        32 as libc::c_int as mln_size_t,
        pool as *mut libc::c_void,
        ::core::mem::transmute::<
            Option::<
                unsafe extern "C" fn(*mut mln_alloc_t, mln_size_t) -> *mut libc::c_void,
            >,
            array_pool_alloc_handler,
        >(
            Some(
                mln_alloc_m
                    as unsafe extern "C" fn(
                        *mut mln_alloc_t,
                        mln_size_t,
                    ) -> *mut libc::c_void,
            ),
        ),
        ::core::mem::transmute::<
            Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
            array_pool_free_handler,
        >(Some(mln_alloc_free as unsafe extern "C" fn(*mut libc::c_void) -> ())),
    ) < 0 as libc::c_int
    {
        mln_alloc_free(func as *mut libc::c_void);
        return 0 as *mut mln_lang_funccall_val_t;
    }
    return func;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_funccall_val_new(
    mut pool: *mut mln_alloc_t,
    mut name: *mut mln_string_t,
) -> *mut mln_lang_funccall_val_t {
    return __mln_lang_funccall_val_new(pool, name);
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_funccall_val_free(
    mut func: *mut mln_lang_funccall_val_t,
) {
    __mln_lang_funccall_val_free(func);
}
#[inline]
unsafe extern "C" fn __mln_lang_funccall_val_free(
    mut func: *mut mln_lang_funccall_val_t,
) {
    if func.is_null() {
        return;
    }
    if !((*func).name).is_null() {
        let mut __s: *mut mln_string_t = (*func).name;
        if !__s.is_null() {
            let ref mut fresh33 = (*__s).ref_0();
            let fresh34 = *fresh33;
            *fresh33 = (*fresh33).wrapping_sub(1);
            if fresh34 <= 1 as libc::c_int as libc::c_ulong {
                if (*__s).data_ref() == 0 && !((*__s).data).is_null() {
                    if (*__s).pool() != 0 {
                        mln_alloc_free((*__s).data as *mut libc::c_void);
                    } else {
                        free((*__s).data as *mut libc::c_void);
                    }
                }
                if (*__s).pool() != 0 {
                    mln_alloc_free(__s as *mut libc::c_void);
                } else {
                    free(__s as *mut libc::c_void);
                }
            }
        }
    }
    mln_array_destroy(&mut (*func).args);
    if !((*func).object).is_null() {
        __mln_lang_val_free((*func).object as *mut libc::c_void);
    }
    mln_alloc_free(func as *mut libc::c_void);
}
#[no_mangle]
#[inline]
#[linkage = "external"]
pub unsafe extern "C" fn mln_lang_funccall_val_add_arg(
    mut func: *mut mln_lang_funccall_val_t,
    mut var: *mut mln_lang_var_t,
) -> libc::c_int {
    let mut v: *mut *mut mln_lang_var_t = 0 as *mut *mut mln_lang_var_t;
    v = mln_array_push(&mut (*func).args) as *mut *mut mln_lang_var_t;
    if v.is_null() {
        return -(1 as libc::c_int);
    }
    *v = var;
    return 0 as libc::c_int;
}
#[no_mangle]
#[inline]
#[linkage = "external"]
pub unsafe extern "C" fn mln_lang_funccall_val_object_add(
    mut func: *mut mln_lang_funccall_val_t,
    mut obj_val: *mut mln_lang_val_t,
) {
    (*obj_val).ref_0 = ((*obj_val).ref_0).wrapping_add(1);
    (*obj_val).ref_0;
    (*func).object = obj_val;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_funccall_val_operator(
    mut ctx: *mut mln_lang_ctx_t,
    mut name: *mut mln_string_t,
    mut ret: *mut *mut mln_lang_var_t,
    mut op1: *mut mln_lang_var_t,
    mut op2: *mut mln_lang_var_t,
) -> libc::c_int {
    let mut sym: *mut mln_lang_symbol_node_t = 0 as *mut mln_lang_symbol_node_t;
    if mln_lang_funccall_val_operator_overload_test(ctx, name) != 0 {
        return 0 as libc::c_int;
    }
    sym = __mln_lang_symbol_node_search(ctx, name, 0 as libc::c_int);
    if !sym.is_null()
        && (*sym).type_0 as libc::c_uint
            == M_LANG_SYMBOL_VAR as libc::c_int as libc::c_uint
        && (*(*(*sym).data.var).val).type_0 == 6 as libc::c_int
    {
        let mut call: *mut mln_lang_funccall_val_t = __mln_lang_funccall_val_new(
            (*ctx).pool,
            name,
        );
        if call.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            return -(1 as libc::c_int);
        }
        *ret = mln_lang_var_create_call(ctx, call);
        if (*ret).is_null() {
            __mln_lang_errmsg(
                ctx,
                b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            __mln_lang_funccall_val_free(call);
            return -(1 as libc::c_int);
        }
        (*op1).ref_0 = ((*op1).ref_0).wrapping_add(1);
        (*op1).ref_0;
        mln_lang_funccall_val_add_arg(call, op1);
        if !op2.is_null() {
            (*op2).ref_0 = ((*op2).ref_0).wrapping_add(1);
            (*op2).ref_0;
            mln_lang_funccall_val_add_arg(call, op2);
        }
        (*call).prototype = (*(*(*sym).data.var).val).data.func;
        return 1 as libc::c_int;
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_funccall_val_obj_operator(
    mut ctx: *mut mln_lang_ctx_t,
    mut obj: *mut mln_lang_var_t,
    mut name: *mut mln_string_t,
    mut ret: *mut *mut mln_lang_var_t,
    mut op1: *mut mln_lang_var_t,
    mut op2: *mut mln_lang_var_t,
) -> libc::c_int {
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut sym: *mut mln_lang_symbol_node_t = 0 as *mut mln_lang_symbol_node_t;
    if mln_lang_funccall_val_operator_overload_test(ctx, name) != 0 {
        return 0 as libc::c_int;
    }
    var = __mln_lang_set_member_search((*(*(*obj).val).data.obj).members, name);
    if !var.is_null() && (*(*var).val).type_0 == 6 as libc::c_int {
        let mut call: *mut mln_lang_funccall_val_t = __mln_lang_funccall_val_new(
            (*ctx).pool,
            name,
        );
        if call.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            return -(1 as libc::c_int);
        }
        *ret = mln_lang_var_create_call(ctx, call);
        if (*ret).is_null() {
            __mln_lang_errmsg(
                ctx,
                b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            __mln_lang_funccall_val_free(call);
            return -(1 as libc::c_int);
        }
        (*op1).ref_0 = ((*op1).ref_0).wrapping_add(1);
        (*op1).ref_0;
        mln_lang_funccall_val_add_arg(call, op1);
        if !op2.is_null() {
            (*op2).ref_0 = ((*op2).ref_0).wrapping_add(1);
            (*op2).ref_0;
            mln_lang_funccall_val_add_arg(call, op2);
        }
        (*call).prototype = (*(*var).val).data.func;
        mln_lang_funccall_val_object_add(call, (*obj).val);
        return 1 as libc::c_int;
    }
    sym = __mln_lang_symbol_node_search(ctx, name, 0 as libc::c_int);
    if !sym.is_null()
        && (*sym).type_0 as libc::c_uint
            == M_LANG_SYMBOL_VAR as libc::c_int as libc::c_uint
        && (*(*(*sym).data.var).val).type_0 == 6 as libc::c_int
    {
        let mut call_0: *mut mln_lang_funccall_val_t = __mln_lang_funccall_val_new(
            (*ctx).pool,
            name,
        );
        if call_0.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            return -(1 as libc::c_int);
        }
        *ret = mln_lang_var_create_call(ctx, call_0);
        if (*ret).is_null() {
            __mln_lang_errmsg(
                ctx,
                b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            __mln_lang_funccall_val_free(call_0);
            return -(1 as libc::c_int);
        }
        (*op1).ref_0 = ((*op1).ref_0).wrapping_add(1);
        (*op1).ref_0;
        mln_lang_funccall_val_add_arg(call_0, op1);
        if !op2.is_null() {
            (*op2).ref_0 = ((*op2).ref_0).wrapping_add(1);
            (*op2).ref_0;
            mln_lang_funccall_val_add_arg(call_0, op2);
        }
        (*call_0).prototype = (*(*(*sym).data.var).val).data.func;
        return 1 as libc::c_int;
    }
    return 0 as libc::c_int;
}
#[inline]
unsafe extern "C" fn mln_lang_funccall_val_operator_overload_test(
    mut ctx: *mut mln_lang_ctx_t,
    mut name: *mut mln_string_t,
) -> libc::c_int {
    let mut scope: *mut mln_lang_scope_t = (*ctx).scope_top;
    while ({
        let mut in_0: libc::c_int = 0 as libc::c_int;
        let mut s: *mut mln_lang_scope_t = scope;
        if !s.is_null()
            && s.offset_from(((*ctx).scopes).as_mut_ptr()) as libc::c_long
                <= 1024 as libc::c_int as libc::c_long
        {
            in_0 = 1 as libc::c_int;
        }
        in_0
    }) != 0
    {
        if !((*scope).name).is_null() && mln_string_strcmp((*scope).name, name) == 0 {
            return 1 as libc::c_int;
        }
        scope = scope.offset(-1);
        scope;
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_errmsg(
    mut ctx: *mut mln_lang_ctx_t,
    mut msg: *mut libc::c_char,
) {
    __mln_lang_errmsg(ctx, msg);
}
unsafe extern "C" fn __mln_lang_errmsg(
    mut ctx: *mut mln_lang_ctx_t,
    mut msg: *mut libc::c_char,
) {
    let mut line: mln_u64_t = 0 as libc::c_int as mln_u64_t;
    let mut filename: *mut mln_string_t = 0 as *mut mln_string_t;
    let mut nilname: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b" \0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    let mut node: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
    node = (*ctx).run_stack_top;
    if !node.is_null() {
        match (*node).type_0 as libc::c_uint {
            0 => {
                filename = (*(*node).data.stm).file;
                line = (*(*node).data.stm).line;
            }
            1 => {
                filename = (*(*node).data.funcdef).file;
                line = (*(*node).data.funcdef).line;
            }
            2 => {
                filename = (*(*node).data.set).file;
                line = (*(*node).data.set).line;
            }
            3 => {
                filename = (*(*node).data.set_stm).file;
                line = (*(*node).data.set_stm).line;
            }
            4 => {
                filename = (*(*node).data.block).file;
                line = (*(*node).data.block).line;
            }
            5 => {
                filename = (*(*node).data.w).file;
                line = (*(*node).data.w).line;
            }
            6 => {
                filename = (*(*node).data.sw).file;
                line = (*(*node).data.sw).line;
            }
            7 => {
                filename = (*(*node).data.sw_stm).file;
                line = (*(*node).data.sw_stm).line;
            }
            8 => {
                filename = (*(*node).data.f).file;
                line = (*(*node).data.f).line;
            }
            9 => {
                filename = (*(*node).data.i).file;
                line = (*(*node).data.i).line;
            }
            10 => {
                filename = (*(*node).data.exp).file;
                line = (*(*node).data.exp).line;
            }
            11 => {
                filename = (*(*node).data.assign).file;
                line = (*(*node).data.assign).line;
            }
            12 => {
                filename = (*(*node).data.logiclow).file;
                line = (*(*node).data.logiclow).line;
            }
            13 => {
                filename = (*(*node).data.logichigh).file;
                line = (*(*node).data.logichigh).line;
            }
            14 => {
                filename = (*(*node).data.relativelow).file;
                line = (*(*node).data.relativelow).line;
            }
            15 => {
                filename = (*(*node).data.relativehigh).file;
                line = (*(*node).data.relativehigh).line;
            }
            16 => {
                filename = (*(*node).data.move_0).file;
                line = (*(*node).data.move_0).line;
            }
            17 => {
                filename = (*(*node).data.addsub).file;
                line = (*(*node).data.addsub).line;
            }
            18 => {
                filename = (*(*node).data.muldiv).file;
                line = (*(*node).data.muldiv).line;
            }
            19 => {
                filename = (*(*node).data.not).file;
                line = (*(*node).data.not).line;
            }
            20 => {
                filename = (*(*node).data.suffix).file;
                line = (*(*node).data.suffix).line;
            }
            21 => {
                filename = (*(*node).data.locate).file;
                line = (*(*node).data.locate).line;
            }
            22 => {
                filename = (*(*node).data.spec).file;
                line = (*(*node).data.spec).line;
            }
            23 => {
                filename = (*(*node).data.factor).file;
                line = (*(*node).data.factor).line;
            }
            _ => {
                filename = (*(*node).data.elemlist).file;
                line = (*(*node).data.elemlist).line;
            }
        }
    }
    if filename.is_null() {
        filename = if ((*ctx).filename).is_null() {
            &mut nilname
        } else {
            (*ctx).filename
        };
    }
    _mln_sys_log(
        none,
        b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
        (*::core::mem::transmute::<
            &[u8; 18],
            &[libc::c_char; 18],
        >(b"__mln_lang_errmsg\0"))
            .as_ptr(),
        3325 as libc::c_int,
        b"%S:%I: %s\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        filename,
        line,
        msg,
    );
}
unsafe extern "C" fn mln_lang_stack_handler_stm(mut ctx: *mut mln_lang_ctx_t) {
    let mut node: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
    let mut stm: *mut mln_lang_stm_t = (*node).data.stm;
    let mut current_block_15: u64;
    if (*node).step() as libc::c_int == 0 as libc::c_int {
        (*node).set_step((*node).step() + 1);
        (*node).step();
        current_block_15 = 12291426027194908247;
    } else {
        current_block_15 = 1385619597949699777;
    }
    loop {
        match current_block_15 {
            12291426027194908247 => {
                if (*stm).type_0 as libc::c_uint
                    == M_STM_LABEL as libc::c_int as libc::c_uint
                {
                    current_block_15 = 1385619597949699777;
                    continue;
                }
                if ((*stm).jump).is_null() {
                    mln_lang_generate_jump_ptr(stm as *mut libc::c_void, M_LSNT_STM);
                }
                node = ({
                    let mut n: *mut mln_lang_stack_node_t = 0
                        as *mut mln_lang_stack_node_t;
                    if ((*ctx).run_stack_top).is_null() {
                        (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                        n = (*ctx).run_stack_top;
                    } else if (((*ctx).run_stack_top)
                        .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                        < 1024 as libc::c_int as libc::c_long
                    {
                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                        n = (*ctx).run_stack_top;
                    }
                    if !n.is_null() {
                        (*n).type_0 = (*stm).jump_type as mln_lang_stack_node_type_t;
                        (*n).pos = 0 as *mut libc::c_void;
                        (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                        (*n).ret_var = (*n).ret_var2;
                        (*n).set_step(0 as libc::c_int as mln_u32_t);
                        (*n).set_call(0 as libc::c_int as mln_u32_t);
                        match (*stm).jump_type as mln_lang_stack_node_type_t
                            as libc::c_uint
                        {
                            0 => {
                                (*n).data.stm = (*stm).jump as *mut mln_lang_stm_t;
                            }
                            1 => {
                                (*n).data.funcdef = (*stm).jump as *mut mln_lang_funcdef_t;
                            }
                            2 => {
                                (*n).data.set = (*stm).jump as *mut mln_lang_set_t;
                            }
                            3 => {
                                (*n).data.set_stm = (*stm).jump as *mut mln_lang_setstm_t;
                            }
                            4 => {
                                (*n).data.block = (*stm).jump as *mut mln_lang_block_t;
                            }
                            5 => {
                                (*n).data.w = (*stm).jump as *mut mln_lang_while_t;
                            }
                            6 => {
                                (*n).data.sw = (*stm).jump as *mut mln_lang_switch_t;
                            }
                            7 => {
                                (*n).data.sw_stm = (*stm).jump as *mut mln_lang_switchstm_t;
                            }
                            8 => {
                                (*n).data.f = (*stm).jump as *mut mln_lang_for_t;
                            }
                            9 => {
                                (*n).data.i = (*stm).jump as *mut mln_lang_if_t;
                            }
                            10 => {
                                (*n).data.exp = (*stm).jump as *mut mln_lang_exp_t;
                            }
                            11 => {
                                (*n).data.assign = (*stm).jump as *mut mln_lang_assign_t;
                            }
                            12 => {
                                (*n)
                                    .data
                                    .logiclow = (*stm).jump as *mut mln_lang_logiclow_t;
                            }
                            13 => {
                                (*n)
                                    .data
                                    .logichigh = (*stm).jump as *mut mln_lang_logichigh_t;
                                (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                            }
                            14 => {
                                (*n)
                                    .data
                                    .relativelow = (*stm).jump as *mut mln_lang_relativelow_t;
                                (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                            }
                            15 => {
                                (*n)
                                    .data
                                    .relativehigh = (*stm).jump as *mut mln_lang_relativehigh_t;
                                (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                            }
                            16 => {
                                (*n).data.move_0 = (*stm).jump as *mut mln_lang_move_t;
                                (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                            }
                            17 => {
                                (*n).data.addsub = (*stm).jump as *mut mln_lang_addsub_t;
                                (*n).pos = (*n).data.addsub as *mut libc::c_void;
                            }
                            18 => {
                                (*n).data.muldiv = (*stm).jump as *mut mln_lang_muldiv_t;
                                (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                            }
                            19 => {
                                (*n).data.not = (*stm).jump as *mut mln_lang_not_t;
                                (*n).pos = (*n).data.not as *mut libc::c_void;
                            }
                            20 => {
                                (*n).data.suffix = (*stm).jump as *mut mln_lang_suffix_t;
                            }
                            21 => {
                                (*n).data.locate = (*stm).jump as *mut mln_lang_locate_t;
                            }
                            22 => {
                                (*n).data.spec = (*stm).jump as *mut mln_lang_spec_t;
                            }
                            23 => {
                                (*n).data.factor = (*stm).jump as *mut mln_lang_factor_t;
                            }
                            _ => {
                                (*n)
                                    .data
                                    .elemlist = (*stm).jump as *mut mln_lang_elemlist_t;
                            }
                        }
                    }
                    n
                });
                if node.is_null() {
                    __mln_lang_errmsg(
                        ctx,
                        b"Stack is full.\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                    );
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                (mln_lang_stack_map[(*node).type_0 as usize])
                    .expect("non-null function pointer")(ctx);
                return;
            }
            _ => {
                if (*ctx).ret_flag() == 0 && !((*stm).next).is_null() {
                    stm = (*stm).next;
                    (*node).data.stm = stm;
                    current_block_15 = 12291426027194908247;
                } else {
                    if (*ctx).ret_flag() != 0 {
                        (*ctx).set_ret_flag(0 as libc::c_int as mln_u32_t);
                    } else {
                        mln_lang_ctx_reset_ret_var(ctx);
                    }
                    let mut n: *mut mln_lang_stack_node_t = ({
                        let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                        if !n_0.is_null()
                            && {
                                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                                (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                            }
                        {
                            (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                        }
                        n_0
                    });
                    if !n.is_null() {
                        if !((*n).ret_var).is_null() {
                            __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                            (*n).ret_var = 0 as *mut mln_lang_var_t;
                        }
                        if !((*n).ret_var2).is_null() {
                            __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                            (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                        }
                    }
                    return;
                }
            }
        }
    };
}
unsafe extern "C" fn mln_lang_stack_handler_funcdef(mut ctx: *mut mln_lang_ctx_t) {
    let mut node: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
    let mut funcdef: *mut mln_lang_funcdef_t = (*node).data.funcdef;
    let mut val: *mut mln_lang_val_t = 0 as *mut mln_lang_val_t;
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut func: *mut mln_lang_func_detail_t = 0 as *mut mln_lang_func_detail_t;
    let mut in_set: *mut mln_lang_set_detail_t = mln_lang_ctx_get_class(ctx);
    func = __mln_lang_func_detail_new(
        ctx,
        M_FUNC_EXTERNAL,
        (*funcdef).stm as *mut libc::c_void,
        (*funcdef).args,
        (*funcdef).closure,
    );
    if func.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"Parse function definition failed.\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
        return;
    }
    val = __mln_lang_val_new(ctx, 6 as libc::c_int, func as *mut libc::c_void);
    if val.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        __mln_lang_func_detail_free(func);
        (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
        return;
    }
    if (*(*funcdef).name).len > 18 as libc::c_int as libc::c_ulong
        && *((*(*funcdef).name).data).offset(0 as libc::c_int as isize) as libc::c_int
            == '_' as i32
        && *((*(*funcdef).name).data).offset(1 as libc::c_int as isize) as libc::c_int
            == '_' as i32
    {
        match *((*(*funcdef).name).data).offset(2 as libc::c_int as isize) as libc::c_int
        {
            97 => {
                (*ctx).set_op_array_flag(1 as libc::c_int as mln_u32_t);
            }
            98 => {
                (*ctx).set_op_bool_flag(1 as libc::c_int as mln_u32_t);
            }
            102 => {
                (*ctx).set_op_func_flag(1 as libc::c_int as mln_u32_t);
            }
            105 => {
                (*ctx).set_op_int_flag(1 as libc::c_int as mln_u32_t);
            }
            110 => {
                (*ctx).set_op_nil_flag(1 as libc::c_int as mln_u32_t);
            }
            111 => {
                (*ctx).set_op_obj_flag(1 as libc::c_int as mln_u32_t);
            }
            114 => {
                (*ctx).set_op_real_flag(1 as libc::c_int as mln_u32_t);
            }
            115 => {
                (*ctx).set_op_str_flag(1 as libc::c_int as mln_u32_t);
            }
            _ => {}
        }
    }
    var = __mln_lang_var_new(ctx, (*funcdef).name, M_LANG_VAR_NORMAL, val, in_set);
    if var.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        __mln_lang_val_free(val as *mut libc::c_void);
        (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
        return;
    }
    if !in_set.is_null() {
        if mln_lang_set_member_add((*ctx).pool, (*in_set).members, var)
            < 0 as libc::c_int
        {
            __mln_lang_errmsg(
                ctx,
                b"Add member failed. No memory.\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
            __mln_lang_var_free(var as *mut libc::c_void);
            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
            return;
        }
    } else if __mln_lang_symbol_node_join(
        ctx,
        M_LANG_SYMBOL_VAR,
        var as *mut libc::c_void,
    ) < 0 as libc::c_int
    {
        __mln_lang_var_free(var as *mut libc::c_void);
        (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
        return;
    }
    let mut n: *mut mln_lang_stack_node_t = ({
        let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
        if !n_0.is_null()
            && {
                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
            }
        {
            (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
        }
        n_0
    });
    if !n.is_null() {
        if !((*n).ret_var).is_null() {
            __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
            (*n).ret_var = 0 as *mut mln_lang_var_t;
        }
        if !((*n).ret_var2).is_null() {
            __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
            (*n).ret_var2 = 0 as *mut mln_lang_var_t;
        }
    }
}
unsafe extern "C" fn mln_lang_stack_handler_set(mut ctx: *mut mln_lang_ctx_t) {
    let mut node: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
    let mut set: *mut mln_lang_set_t = (*node).data.set;
    let mut s_detail: *mut mln_lang_set_detail_t = 0 as *mut mln_lang_set_detail_t;
    let mut scope: *mut mln_lang_scope_t = 0 as *mut mln_lang_scope_t;
    if (*node).step() as libc::c_int == 0 as libc::c_int {
        s_detail = mln_lang_set_detail_new((*ctx).pool, (*set).name);
        if s_detail.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
            return;
        }
        (*s_detail).ref_0 = ((*s_detail).ref_0).wrapping_add(1);
        (*s_detail).ref_0;
        if __mln_lang_symbol_node_join(
            ctx,
            M_LANG_SYMBOL_SET,
            s_detail as *mut libc::c_void,
        ) < 0 as libc::c_int
        {
            mln_lang_set_detail_self_free(s_detail);
            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
            return;
        }
        if !((*set).stm).is_null() {
            (*node).set_step(1 as libc::c_int as mln_u32_t);
            scope = ({
                let mut s: *mut mln_lang_scope_t = 0 as *mut mln_lang_scope_t;
                let mut last: *mut mln_lang_scope_t = 0 as *mut mln_lang_scope_t;
                last = (*ctx).scope_top;
                if last.is_null() {
                    (*ctx).scope_top = ((*ctx).scopes).as_mut_ptr();
                    s = (*ctx).scope_top;
                } else if (last.offset_from(((*ctx).scopes).as_mut_ptr())
                    as libc::c_long) < 1024 as libc::c_int as libc::c_long
                {
                    (*ctx).scope_top = ((*ctx).scope_top).offset(1);
                    s = (*ctx).scope_top;
                }
                if !s.is_null() {
                    (*s).ctx = ctx;
                    (*s).type_0 = M_LANG_SCOPE_TYPE_SET;
                    if !((*s_detail).name).is_null() {
                        (*s)
                            .name = ({
                            let mut __s: *mut mln_string_t = (*s_detail).name;
                            (*__s).set_ref_0((*__s).ref_0() + 1);
                            (*__s).ref_0();
                            __s
                        });
                    } else {
                        (*s).name = 0 as *mut mln_string_t;
                    }
                    (*s).cur_stack = 0 as *mut mln_lang_stack_node_t;
                    (*s).entry = 0 as *mut mln_lang_stm_t;
                    (*s)
                        .layer = if last.is_null() {
                        1 as libc::c_int as libc::c_ulong
                    } else {
                        ((*last).layer).wrapping_add(1 as libc::c_int as libc::c_ulong)
                    };
                    (*s).sym_tail = 0 as *mut mln_lang_symbol_node_t;
                    (*s).sym_head = (*s).sym_tail;
                }
                s
            });
            if scope.is_null() {
                __mln_lang_errmsg(
                    ctx,
                    b"Scope stack is full.\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                );
                (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                return;
            }
            node = ({
                let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
                if ((*ctx).run_stack_top).is_null() {
                    (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                    n = (*ctx).run_stack_top;
                } else if (((*ctx).run_stack_top)
                    .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                    < 1024 as libc::c_int as libc::c_long
                {
                    (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                    n = (*ctx).run_stack_top;
                }
                if !n.is_null() {
                    (*n).type_0 = M_LSNT_SETSTM;
                    (*n).pos = 0 as *mut libc::c_void;
                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    (*n).ret_var = (*n).ret_var2;
                    (*n).set_step(0 as libc::c_int as mln_u32_t);
                    (*n).set_call(0 as libc::c_int as mln_u32_t);
                    match M_LSNT_SETSTM as libc::c_int {
                        0 => {
                            (*n).data.stm = (*set).stm as *mut mln_lang_stm_t;
                        }
                        1 => {
                            (*n).data.funcdef = (*set).stm as *mut mln_lang_funcdef_t;
                        }
                        2 => {
                            (*n).data.set = (*set).stm as *mut mln_lang_set_t;
                        }
                        3 => {
                            (*n).data.set_stm = (*set).stm;
                        }
                        4 => {
                            (*n).data.block = (*set).stm as *mut mln_lang_block_t;
                        }
                        5 => {
                            (*n).data.w = (*set).stm as *mut mln_lang_while_t;
                        }
                        6 => {
                            (*n).data.sw = (*set).stm as *mut mln_lang_switch_t;
                        }
                        7 => {
                            (*n).data.sw_stm = (*set).stm as *mut mln_lang_switchstm_t;
                        }
                        8 => {
                            (*n).data.f = (*set).stm as *mut mln_lang_for_t;
                        }
                        9 => {
                            (*n).data.i = (*set).stm as *mut mln_lang_if_t;
                        }
                        10 => {
                            (*n).data.exp = (*set).stm as *mut mln_lang_exp_t;
                        }
                        11 => {
                            (*n).data.assign = (*set).stm as *mut mln_lang_assign_t;
                        }
                        12 => {
                            (*n).data.logiclow = (*set).stm as *mut mln_lang_logiclow_t;
                        }
                        13 => {
                            (*n)
                                .data
                                .logichigh = (*set).stm as *mut mln_lang_logichigh_t;
                            (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                        }
                        14 => {
                            (*n)
                                .data
                                .relativelow = (*set).stm as *mut mln_lang_relativelow_t;
                            (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                        }
                        15 => {
                            (*n)
                                .data
                                .relativehigh = (*set).stm as *mut mln_lang_relativehigh_t;
                            (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                        }
                        16 => {
                            (*n).data.move_0 = (*set).stm as *mut mln_lang_move_t;
                            (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                        }
                        17 => {
                            (*n).data.addsub = (*set).stm as *mut mln_lang_addsub_t;
                            (*n).pos = (*n).data.addsub as *mut libc::c_void;
                        }
                        18 => {
                            (*n).data.muldiv = (*set).stm as *mut mln_lang_muldiv_t;
                            (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                        }
                        19 => {
                            (*n).data.not = (*set).stm as *mut mln_lang_not_t;
                            (*n).pos = (*n).data.not as *mut libc::c_void;
                        }
                        20 => {
                            (*n).data.suffix = (*set).stm as *mut mln_lang_suffix_t;
                        }
                        21 => {
                            (*n).data.locate = (*set).stm as *mut mln_lang_locate_t;
                        }
                        22 => {
                            (*n).data.spec = (*set).stm as *mut mln_lang_spec_t;
                        }
                        23 => {
                            (*n).data.factor = (*set).stm as *mut mln_lang_factor_t;
                        }
                        _ => {
                            (*n).data.elemlist = (*set).stm as *mut mln_lang_elemlist_t;
                        }
                    }
                }
                n
            });
            if node.is_null() {
                __mln_lang_errmsg(
                    ctx,
                    b"Stack is full.\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                );
                (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                return;
            }
            (mln_lang_stack_map[(*node).type_0 as usize])
                .expect("non-null function pointer")(ctx);
            return;
        } else {
            let mut n: *mut mln_lang_stack_node_t = ({
                let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                if !n_0.is_null()
                    && {
                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                        (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                    }
                {
                    (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                }
                n_0
            });
            if !n.is_null() {
                if !((*n).ret_var).is_null() {
                    __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                    (*n).ret_var = 0 as *mut mln_lang_var_t;
                }
                if !((*n).ret_var2).is_null() {
                    __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                }
            }
        }
    } else {
        let mut s: *mut mln_lang_scope_t = (*ctx).scope_top;
        let mut sym: *mut mln_lang_symbol_node_t = 0 as *mut mln_lang_symbol_node_t;
        if !s.is_null() {
            if !((*s).name).is_null() {
                let mut __s: *mut mln_string_t = (*s).name;
                if !__s.is_null() {
                    let ref mut fresh35 = (*__s).ref_0();
                    let fresh36 = *fresh35;
                    *fresh35 = (*fresh35).wrapping_sub(1);
                    if fresh36 <= 1 as libc::c_int as libc::c_ulong {
                        if (*__s).data_ref() == 0 && !((*__s).data).is_null() {
                            if (*__s).pool() != 0 {
                                mln_alloc_free((*__s).data as *mut libc::c_void);
                            } else {
                                free((*__s).data as *mut libc::c_void);
                            }
                        }
                        if (*__s).pool() != 0 {
                            mln_alloc_free(__s as *mut libc::c_void);
                        } else {
                            free(__s as *mut libc::c_void);
                        }
                    }
                }
            }
            loop {
                sym = (*s).sym_head;
                if sym.is_null() {
                    break;
                }
                mln_lang_sym_scope_chain_del(
                    &mut (*s).sym_head,
                    &mut (*s).sym_tail,
                    sym,
                );
                mln_lang_sym_chain_del(
                    &mut (*(*sym).bucket).head,
                    &mut (*(*sym).bucket).tail,
                    sym,
                );
                mln_lang_symbol_node_free(sym as *mut libc::c_void);
            }
            (*ctx).scope_top = ((*ctx).scope_top).offset(-1);
            if (*ctx).scope_top < ((*ctx).scopes).as_mut_ptr() {
                (*ctx).scope_top = 0 as *mut mln_lang_scope_t;
            }
        }
        let mut n: *mut mln_lang_stack_node_t = ({
            let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
            if !n_0.is_null()
                && {
                    (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                    (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                }
            {
                (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
            }
            n_0
        });
        if !n.is_null() {
            if !((*n).ret_var).is_null() {
                __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                (*n).ret_var = 0 as *mut mln_lang_var_t;
            }
            if !((*n).ret_var2).is_null() {
                __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
            }
        }
    };
}
unsafe extern "C" fn mln_lang_stack_handler_setstm(mut ctx: *mut mln_lang_ctx_t) {
    let mut node: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
    let mut ls: *mut mln_lang_setstm_t = (*node).data.set_stm;
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut val: *mut mln_lang_val_t = 0 as *mut mln_lang_val_t;
    let mut in_set: *mut mln_lang_set_detail_t = 0 as *mut mln_lang_set_detail_t;
    let mut current_block_38: u64;
    if (*node).step() as libc::c_int == 0 as libc::c_int {
        (*node).set_step(1 as libc::c_int as mln_u32_t);
        current_block_38 = 2263235492569521022;
    } else {
        current_block_38 = 17141897603773905982;
    }
    loop {
        match current_block_38 {
            2263235492569521022 => {
                if (*ls).type_0 as libc::c_uint
                    == M_SETSTM_VAR as libc::c_int as libc::c_uint
                {
                    in_set = mln_lang_ctx_get_class(ctx);
                    val = __mln_lang_val_new(
                        ctx,
                        0 as libc::c_int,
                        0 as *mut libc::c_void,
                    );
                    if val.is_null() {
                        __mln_lang_errmsg(
                            ctx,
                            b"No memory.\0" as *const u8 as *const libc::c_char
                                as *mut libc::c_char,
                        );
                        (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                        return;
                    }
                    var = __mln_lang_var_new(
                        ctx,
                        (*ls).data.var,
                        M_LANG_VAR_NORMAL,
                        val,
                        in_set,
                    );
                    if var.is_null() {
                        __mln_lang_errmsg(
                            ctx,
                            b"No memory.\0" as *const u8 as *const libc::c_char
                                as *mut libc::c_char,
                        );
                        __mln_lang_val_free(val as *mut libc::c_void);
                        (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                        return;
                    }
                    if in_set.is_null() {
                        if __mln_lang_symbol_node_join(
                            ctx,
                            M_LANG_SYMBOL_VAR,
                            var as *mut libc::c_void,
                        ) < 0 as libc::c_int
                        {
                            __mln_lang_errmsg(
                                ctx,
                                b"No memory.\0" as *const u8 as *const libc::c_char
                                    as *mut libc::c_char,
                            );
                            __mln_lang_var_free(var as *mut libc::c_void);
                            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                            return;
                        }
                    } else if mln_lang_set_member_add(
                        (*ctx).pool,
                        (*in_set).members,
                        var,
                    ) < 0 as libc::c_int
                    {
                        __mln_lang_errmsg(
                            ctx,
                            b"No memory.\0" as *const u8 as *const libc::c_char
                                as *mut libc::c_char,
                        );
                        __mln_lang_var_free(var as *mut libc::c_void);
                        (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                        return;
                    }
                    current_block_38 = 17141897603773905982;
                } else {
                    node = ({
                        let mut n: *mut mln_lang_stack_node_t = 0
                            as *mut mln_lang_stack_node_t;
                        if ((*ctx).run_stack_top).is_null() {
                            (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                            n = (*ctx).run_stack_top;
                        } else if (((*ctx).run_stack_top)
                            .offset_from(((*ctx).run_stack).as_mut_ptr())
                            as libc::c_long) < 1024 as libc::c_int as libc::c_long
                        {
                            (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                            n = (*ctx).run_stack_top;
                        }
                        if !n.is_null() {
                            (*n).type_0 = M_LSNT_FUNCDEF;
                            (*n).pos = 0 as *mut libc::c_void;
                            (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                            (*n).ret_var = (*n).ret_var2;
                            (*n).set_step(0 as libc::c_int as mln_u32_t);
                            (*n).set_call(0 as libc::c_int as mln_u32_t);
                            match M_LSNT_FUNCDEF as libc::c_int {
                                0 => {
                                    (*n).data.stm = (*ls).data.func as *mut mln_lang_stm_t;
                                }
                                1 => {
                                    (*n).data.funcdef = (*ls).data.func;
                                }
                                2 => {
                                    (*n).data.set = (*ls).data.func as *mut mln_lang_set_t;
                                }
                                3 => {
                                    (*n)
                                        .data
                                        .set_stm = (*ls).data.func as *mut mln_lang_setstm_t;
                                }
                                4 => {
                                    (*n).data.block = (*ls).data.func as *mut mln_lang_block_t;
                                }
                                5 => {
                                    (*n).data.w = (*ls).data.func as *mut mln_lang_while_t;
                                }
                                6 => {
                                    (*n).data.sw = (*ls).data.func as *mut mln_lang_switch_t;
                                }
                                7 => {
                                    (*n)
                                        .data
                                        .sw_stm = (*ls).data.func as *mut mln_lang_switchstm_t;
                                }
                                8 => {
                                    (*n).data.f = (*ls).data.func as *mut mln_lang_for_t;
                                }
                                9 => {
                                    (*n).data.i = (*ls).data.func as *mut mln_lang_if_t;
                                }
                                10 => {
                                    (*n).data.exp = (*ls).data.func as *mut mln_lang_exp_t;
                                }
                                11 => {
                                    (*n)
                                        .data
                                        .assign = (*ls).data.func as *mut mln_lang_assign_t;
                                }
                                12 => {
                                    (*n)
                                        .data
                                        .logiclow = (*ls).data.func as *mut mln_lang_logiclow_t;
                                }
                                13 => {
                                    (*n)
                                        .data
                                        .logichigh = (*ls).data.func as *mut mln_lang_logichigh_t;
                                    (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                                }
                                14 => {
                                    (*n)
                                        .data
                                        .relativelow = (*ls).data.func
                                        as *mut mln_lang_relativelow_t;
                                    (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                                }
                                15 => {
                                    (*n)
                                        .data
                                        .relativehigh = (*ls).data.func
                                        as *mut mln_lang_relativehigh_t;
                                    (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                                }
                                16 => {
                                    (*n).data.move_0 = (*ls).data.func as *mut mln_lang_move_t;
                                    (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                                }
                                17 => {
                                    (*n)
                                        .data
                                        .addsub = (*ls).data.func as *mut mln_lang_addsub_t;
                                    (*n).pos = (*n).data.addsub as *mut libc::c_void;
                                }
                                18 => {
                                    (*n)
                                        .data
                                        .muldiv = (*ls).data.func as *mut mln_lang_muldiv_t;
                                    (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                                }
                                19 => {
                                    (*n).data.not = (*ls).data.func as *mut mln_lang_not_t;
                                    (*n).pos = (*n).data.not as *mut libc::c_void;
                                }
                                20 => {
                                    (*n)
                                        .data
                                        .suffix = (*ls).data.func as *mut mln_lang_suffix_t;
                                }
                                21 => {
                                    (*n)
                                        .data
                                        .locate = (*ls).data.func as *mut mln_lang_locate_t;
                                }
                                22 => {
                                    (*n).data.spec = (*ls).data.func as *mut mln_lang_spec_t;
                                }
                                23 => {
                                    (*n)
                                        .data
                                        .factor = (*ls).data.func as *mut mln_lang_factor_t;
                                }
                                _ => {
                                    (*n)
                                        .data
                                        .elemlist = (*ls).data.func as *mut mln_lang_elemlist_t;
                                }
                            }
                        }
                        n
                    });
                    if node.is_null() {
                        __mln_lang_errmsg(
                            ctx,
                            b"Stack is full.\0" as *const u8 as *const libc::c_char
                                as *mut libc::c_char,
                        );
                        (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                        return;
                    }
                    (mln_lang_stack_map[(*node).type_0 as usize])
                        .expect("non-null function pointer")(ctx);
                    return;
                }
            }
            _ => {
                if !((*ls).next).is_null() {
                    ls = (*ls).next;
                    (*node).data.set_stm = ls;
                    current_block_38 = 2263235492569521022;
                } else {
                    let mut n: *mut mln_lang_stack_node_t = ({
                        let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                        if !n_0.is_null()
                            && {
                                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                                (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                            }
                        {
                            (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                        }
                        n_0
                    });
                    if !n.is_null() {
                        if !((*n).ret_var).is_null() {
                            __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                            (*n).ret_var = 0 as *mut mln_lang_var_t;
                        }
                        if !((*n).ret_var2).is_null() {
                            __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                            (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                        }
                    }
                    return;
                }
            }
        }
    };
}
unsafe extern "C" fn mln_lang_stack_handler_block(mut ctx: *mut mln_lang_ctx_t) {
    let mut current_block: u64;
    let mut node: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
    let mut block: *mut mln_lang_block_t = (*node).data.block;
    if (*node).step() as libc::c_int == 0 as libc::c_int {
        mln_lang_ctx_reset_ret_var(ctx);
        (*node)
            .set_step(
                (if (*block).type_0 as libc::c_uint
                    != M_BLOCK_RETURN as libc::c_int as libc::c_uint
                {
                    -(1 as libc::c_int)
                } else {
                    1 as libc::c_int
                }) as mln_u32_t,
            );
        match (*block).type_0 as libc::c_uint {
            0 => {
                if ((*block).data.exp).is_null() {
                    current_block = 15646661307045529281;
                } else {
                    if mln_lang_stack_handler_block_exp(ctx, block) < 0 as libc::c_int {
                        (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                        return;
                    }
                    return;
                }
            }
            1 => {
                if ((*block).data.stm).is_null() {
                    current_block = 15646661307045529281;
                } else {
                    if mln_lang_stack_handler_block_stm(ctx, block) < 0 as libc::c_int {
                        (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                        return;
                    }
                    return;
                }
            }
            2 => {
                if mln_lang_stack_handler_block_continue(ctx, block) < 0 as libc::c_int {
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                current_block = 7746103178988627676;
            }
            3 => {
                if mln_lang_stack_handler_block_break(ctx, block) < 0 as libc::c_int {
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                current_block = 7746103178988627676;
            }
            4 => {
                if mln_lang_stack_handler_block_return(ctx, block) < 0 as libc::c_int {
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                return;
            }
            5 => {
                if mln_lang_stack_handler_block_goto(ctx, block) < 0 as libc::c_int {
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                return;
            }
            _ => {
                if mln_lang_stack_handler_block_if(ctx, block) < 0 as libc::c_int {
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                return;
            }
        }
    } else {
        current_block = 15646661307045529281;
    }
    match current_block {
        15646661307045529281 => {
            if (*block).type_0 as libc::c_uint
                != M_BLOCK_RETURN as libc::c_int as libc::c_uint
            {
                mln_lang_ctx_reset_ret_var(ctx);
                let mut n: *mut mln_lang_stack_node_t = ({
                    let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                    if !n_0.is_null()
                        && {
                            (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                            (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                        }
                    {
                        (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                    }
                    n_0
                });
                if !n.is_null() {
                    if !((*n).ret_var).is_null() {
                        __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                        (*n).ret_var = 0 as *mut mln_lang_var_t;
                    }
                    if !((*n).ret_var2).is_null() {
                        __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                        (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    }
                }
            } else if mln_lang_met_return(ctx) < 0 as libc::c_int {
                (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                return;
            }
        }
        _ => {}
    };
}
#[inline]
unsafe extern "C" fn mln_lang_met_return(mut ctx: *mut mln_lang_ctx_t) -> libc::c_int {
    let mut node: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
    let mut last: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
    let mut scope: *mut mln_lang_scope_t = (*ctx).scope_top;
    last = ({
        let mut n: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
        if !n.is_null()
            && {
                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
            }
        {
            (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
        }
        n
    });
    loop {
        node = (*ctx).run_stack_top;
        if node.is_null() || (*scope).cur_stack == node {
            if ((*ctx).run_stack_top).is_null() {
                (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
            } else if (((*ctx).run_stack_top)
                .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                < 1024 as libc::c_int as libc::c_long
            {
                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                (*ctx).run_stack_top;
            }
            (*last).set_step(1 as libc::c_int as mln_u32_t);
            break;
        } else {
            let mut n: *mut mln_lang_stack_node_t = last;
            if !n.is_null() {
                if !((*n).ret_var).is_null() {
                    __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                    (*n).ret_var = 0 as *mut mln_lang_var_t;
                }
                if !((*n).ret_var2).is_null() {
                    __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                }
            }
            last = ({
                let mut n: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                if !n.is_null()
                    && {
                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                        (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                    }
                {
                    (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                }
                n
            });
        }
    }
    if ((*ctx).ret_var).is_null() {
        let mut ret_var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
        ret_var = __mln_lang_var_create_nil(ctx, 0 as *mut mln_string_t);
        if ret_var.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            return -(1 as libc::c_int);
        }
        __mln_lang_ctx_set_ret_var(ctx, ret_var);
    }
    (*ctx).set_ret_flag(1 as libc::c_int as mln_u32_t);
    return 0 as libc::c_int;
}
#[inline]
unsafe extern "C" fn mln_lang_stack_handler_block_exp(
    mut ctx: *mut mln_lang_ctx_t,
    mut block: *mut mln_lang_block_t,
) -> libc::c_int {
    let mut node: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
    if ((*block).jump).is_null() {
        mln_lang_generate_jump_ptr(block as *mut libc::c_void, M_LSNT_BLOCK);
    }
    node = ({
        let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
        if ((*ctx).run_stack_top).is_null() {
            (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
            n = (*ctx).run_stack_top;
        } else if (((*ctx).run_stack_top).offset_from(((*ctx).run_stack).as_mut_ptr())
            as libc::c_long) < 1024 as libc::c_int as libc::c_long
        {
            (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
            n = (*ctx).run_stack_top;
        }
        if !n.is_null() {
            (*n).type_0 = (*block).jump_type as mln_lang_stack_node_type_t;
            (*n).pos = 0 as *mut libc::c_void;
            (*n).ret_var2 = 0 as *mut mln_lang_var_t;
            (*n).ret_var = (*n).ret_var2;
            (*n).set_step(0 as libc::c_int as mln_u32_t);
            (*n).set_call(0 as libc::c_int as mln_u32_t);
            match (*block).jump_type as mln_lang_stack_node_type_t as libc::c_uint {
                0 => {
                    (*n).data.stm = (*block).jump as *mut mln_lang_stm_t;
                }
                1 => {
                    (*n).data.funcdef = (*block).jump as *mut mln_lang_funcdef_t;
                }
                2 => {
                    (*n).data.set = (*block).jump as *mut mln_lang_set_t;
                }
                3 => {
                    (*n).data.set_stm = (*block).jump as *mut mln_lang_setstm_t;
                }
                4 => {
                    (*n).data.block = (*block).jump as *mut mln_lang_block_t;
                }
                5 => {
                    (*n).data.w = (*block).jump as *mut mln_lang_while_t;
                }
                6 => {
                    (*n).data.sw = (*block).jump as *mut mln_lang_switch_t;
                }
                7 => {
                    (*n).data.sw_stm = (*block).jump as *mut mln_lang_switchstm_t;
                }
                8 => {
                    (*n).data.f = (*block).jump as *mut mln_lang_for_t;
                }
                9 => {
                    (*n).data.i = (*block).jump as *mut mln_lang_if_t;
                }
                10 => {
                    (*n).data.exp = (*block).jump as *mut mln_lang_exp_t;
                }
                11 => {
                    (*n).data.assign = (*block).jump as *mut mln_lang_assign_t;
                }
                12 => {
                    (*n).data.logiclow = (*block).jump as *mut mln_lang_logiclow_t;
                }
                13 => {
                    (*n).data.logichigh = (*block).jump as *mut mln_lang_logichigh_t;
                    (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                }
                14 => {
                    (*n).data.relativelow = (*block).jump as *mut mln_lang_relativelow_t;
                    (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                }
                15 => {
                    (*n)
                        .data
                        .relativehigh = (*block).jump as *mut mln_lang_relativehigh_t;
                    (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                }
                16 => {
                    (*n).data.move_0 = (*block).jump as *mut mln_lang_move_t;
                    (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                }
                17 => {
                    (*n).data.addsub = (*block).jump as *mut mln_lang_addsub_t;
                    (*n).pos = (*n).data.addsub as *mut libc::c_void;
                }
                18 => {
                    (*n).data.muldiv = (*block).jump as *mut mln_lang_muldiv_t;
                    (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                }
                19 => {
                    (*n).data.not = (*block).jump as *mut mln_lang_not_t;
                    (*n).pos = (*n).data.not as *mut libc::c_void;
                }
                20 => {
                    (*n).data.suffix = (*block).jump as *mut mln_lang_suffix_t;
                }
                21 => {
                    (*n).data.locate = (*block).jump as *mut mln_lang_locate_t;
                }
                22 => {
                    (*n).data.spec = (*block).jump as *mut mln_lang_spec_t;
                }
                23 => {
                    (*n).data.factor = (*block).jump as *mut mln_lang_factor_t;
                }
                _ => {
                    (*n).data.elemlist = (*block).jump as *mut mln_lang_elemlist_t;
                }
            }
        }
        n
    });
    if node.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"Stack is full.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    (mln_lang_stack_map[(*node).type_0 as usize])
        .expect("non-null function pointer")(ctx);
    return 0 as libc::c_int;
}
#[inline]
unsafe extern "C" fn mln_lang_stack_handler_block_stm(
    mut ctx: *mut mln_lang_ctx_t,
    mut block: *mut mln_lang_block_t,
) -> libc::c_int {
    let mut node: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
    node = ({
        let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
        if ((*ctx).run_stack_top).is_null() {
            (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
            n = (*ctx).run_stack_top;
        } else if (((*ctx).run_stack_top).offset_from(((*ctx).run_stack).as_mut_ptr())
            as libc::c_long) < 1024 as libc::c_int as libc::c_long
        {
            (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
            n = (*ctx).run_stack_top;
        }
        if !n.is_null() {
            (*n).type_0 = M_LSNT_STM;
            (*n).pos = 0 as *mut libc::c_void;
            (*n).ret_var2 = 0 as *mut mln_lang_var_t;
            (*n).ret_var = (*n).ret_var2;
            (*n).set_step(0 as libc::c_int as mln_u32_t);
            (*n).set_call(0 as libc::c_int as mln_u32_t);
            match M_LSNT_STM as libc::c_int {
                0 => {
                    (*n).data.stm = (*block).data.stm;
                }
                1 => {
                    (*n).data.funcdef = (*block).data.stm as *mut mln_lang_funcdef_t;
                }
                2 => {
                    (*n).data.set = (*block).data.stm as *mut mln_lang_set_t;
                }
                3 => {
                    (*n).data.set_stm = (*block).data.stm as *mut mln_lang_setstm_t;
                }
                4 => {
                    (*n).data.block = (*block).data.stm as *mut mln_lang_block_t;
                }
                5 => {
                    (*n).data.w = (*block).data.stm as *mut mln_lang_while_t;
                }
                6 => {
                    (*n).data.sw = (*block).data.stm as *mut mln_lang_switch_t;
                }
                7 => {
                    (*n).data.sw_stm = (*block).data.stm as *mut mln_lang_switchstm_t;
                }
                8 => {
                    (*n).data.f = (*block).data.stm as *mut mln_lang_for_t;
                }
                9 => {
                    (*n).data.i = (*block).data.stm as *mut mln_lang_if_t;
                }
                10 => {
                    (*n).data.exp = (*block).data.stm as *mut mln_lang_exp_t;
                }
                11 => {
                    (*n).data.assign = (*block).data.stm as *mut mln_lang_assign_t;
                }
                12 => {
                    (*n).data.logiclow = (*block).data.stm as *mut mln_lang_logiclow_t;
                }
                13 => {
                    (*n).data.logichigh = (*block).data.stm as *mut mln_lang_logichigh_t;
                    (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                }
                14 => {
                    (*n)
                        .data
                        .relativelow = (*block).data.stm as *mut mln_lang_relativelow_t;
                    (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                }
                15 => {
                    (*n)
                        .data
                        .relativehigh = (*block).data.stm
                        as *mut mln_lang_relativehigh_t;
                    (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                }
                16 => {
                    (*n).data.move_0 = (*block).data.stm as *mut mln_lang_move_t;
                    (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                }
                17 => {
                    (*n).data.addsub = (*block).data.stm as *mut mln_lang_addsub_t;
                    (*n).pos = (*n).data.addsub as *mut libc::c_void;
                }
                18 => {
                    (*n).data.muldiv = (*block).data.stm as *mut mln_lang_muldiv_t;
                    (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                }
                19 => {
                    (*n).data.not = (*block).data.stm as *mut mln_lang_not_t;
                    (*n).pos = (*n).data.not as *mut libc::c_void;
                }
                20 => {
                    (*n).data.suffix = (*block).data.stm as *mut mln_lang_suffix_t;
                }
                21 => {
                    (*n).data.locate = (*block).data.stm as *mut mln_lang_locate_t;
                }
                22 => {
                    (*n).data.spec = (*block).data.stm as *mut mln_lang_spec_t;
                }
                23 => {
                    (*n).data.factor = (*block).data.stm as *mut mln_lang_factor_t;
                }
                _ => {
                    (*n).data.elemlist = (*block).data.stm as *mut mln_lang_elemlist_t;
                }
            }
        }
        n
    });
    if node.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"Stack is full.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    (mln_lang_stack_map[(*node).type_0 as usize])
        .expect("non-null function pointer")(ctx);
    return 0 as libc::c_int;
}
#[inline]
unsafe extern "C" fn mln_lang_stack_handler_block_continue(
    mut ctx: *mut mln_lang_ctx_t,
    mut block: *mut mln_lang_block_t,
) -> libc::c_int {
    let mut node: *mut mln_lang_stack_node_t = mln_lang_withdraw_to_loop(ctx);
    if node.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"Invalid 'continue' usage.\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
#[inline]
unsafe extern "C" fn mln_lang_stack_handler_block_break(
    mut ctx: *mut mln_lang_ctx_t,
    mut block: *mut mln_lang_block_t,
) -> libc::c_int {
    let mut node: *mut mln_lang_stack_node_t = mln_lang_withdraw_break_loop(ctx);
    if node.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"Invalid 'break' usage.\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    (*node).set_step(1 as libc::c_int as mln_u32_t);
    return 0 as libc::c_int;
}
#[inline]
unsafe extern "C" fn mln_lang_stack_handler_block_return(
    mut ctx: *mut mln_lang_ctx_t,
    mut block: *mut mln_lang_block_t,
) -> libc::c_int {
    mln_lang_ctx_reset_ret_var(ctx);
    if ((*block).data.exp).is_null() {
        let mut ret_var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
        ret_var = mln_lang_var_create_nil(ctx, 0 as *mut mln_string_t);
        if ret_var.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            return -(1 as libc::c_int);
        }
        __mln_lang_ctx_set_ret_var(ctx, ret_var);
        return 0 as libc::c_int;
    }
    let mut node: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
    node = ({
        let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
        if ((*ctx).run_stack_top).is_null() {
            (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
            n = (*ctx).run_stack_top;
        } else if (((*ctx).run_stack_top).offset_from(((*ctx).run_stack).as_mut_ptr())
            as libc::c_long) < 1024 as libc::c_int as libc::c_long
        {
            (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
            n = (*ctx).run_stack_top;
        }
        if !n.is_null() {
            (*n).type_0 = M_LSNT_EXP;
            (*n).pos = 0 as *mut libc::c_void;
            (*n).ret_var2 = 0 as *mut mln_lang_var_t;
            (*n).ret_var = (*n).ret_var2;
            (*n).set_step(0 as libc::c_int as mln_u32_t);
            (*n).set_call(0 as libc::c_int as mln_u32_t);
            match M_LSNT_EXP as libc::c_int {
                0 => {
                    (*n).data.stm = (*block).data.exp as *mut mln_lang_stm_t;
                }
                1 => {
                    (*n).data.funcdef = (*block).data.exp as *mut mln_lang_funcdef_t;
                }
                2 => {
                    (*n).data.set = (*block).data.exp as *mut mln_lang_set_t;
                }
                3 => {
                    (*n).data.set_stm = (*block).data.exp as *mut mln_lang_setstm_t;
                }
                4 => {
                    (*n).data.block = (*block).data.exp as *mut mln_lang_block_t;
                }
                5 => {
                    (*n).data.w = (*block).data.exp as *mut mln_lang_while_t;
                }
                6 => {
                    (*n).data.sw = (*block).data.exp as *mut mln_lang_switch_t;
                }
                7 => {
                    (*n).data.sw_stm = (*block).data.exp as *mut mln_lang_switchstm_t;
                }
                8 => {
                    (*n).data.f = (*block).data.exp as *mut mln_lang_for_t;
                }
                9 => {
                    (*n).data.i = (*block).data.exp as *mut mln_lang_if_t;
                }
                10 => {
                    (*n).data.exp = (*block).data.exp;
                }
                11 => {
                    (*n).data.assign = (*block).data.exp as *mut mln_lang_assign_t;
                }
                12 => {
                    (*n).data.logiclow = (*block).data.exp as *mut mln_lang_logiclow_t;
                }
                13 => {
                    (*n).data.logichigh = (*block).data.exp as *mut mln_lang_logichigh_t;
                    (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                }
                14 => {
                    (*n)
                        .data
                        .relativelow = (*block).data.exp as *mut mln_lang_relativelow_t;
                    (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                }
                15 => {
                    (*n)
                        .data
                        .relativehigh = (*block).data.exp
                        as *mut mln_lang_relativehigh_t;
                    (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                }
                16 => {
                    (*n).data.move_0 = (*block).data.exp as *mut mln_lang_move_t;
                    (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                }
                17 => {
                    (*n).data.addsub = (*block).data.exp as *mut mln_lang_addsub_t;
                    (*n).pos = (*n).data.addsub as *mut libc::c_void;
                }
                18 => {
                    (*n).data.muldiv = (*block).data.exp as *mut mln_lang_muldiv_t;
                    (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                }
                19 => {
                    (*n).data.not = (*block).data.exp as *mut mln_lang_not_t;
                    (*n).pos = (*n).data.not as *mut libc::c_void;
                }
                20 => {
                    (*n).data.suffix = (*block).data.exp as *mut mln_lang_suffix_t;
                }
                21 => {
                    (*n).data.locate = (*block).data.exp as *mut mln_lang_locate_t;
                }
                22 => {
                    (*n).data.spec = (*block).data.exp as *mut mln_lang_spec_t;
                }
                23 => {
                    (*n).data.factor = (*block).data.exp as *mut mln_lang_factor_t;
                }
                _ => {
                    (*n).data.elemlist = (*block).data.exp as *mut mln_lang_elemlist_t;
                }
            }
        }
        n
    });
    if node.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"Stack is full.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    (mln_lang_stack_map[(*node).type_0 as usize])
        .expect("non-null function pointer")(ctx);
    return 0 as libc::c_int;
}
#[inline]
unsafe extern "C" fn mln_lang_stack_handler_block_goto(
    mut ctx: *mut mln_lang_ctx_t,
    mut block: *mut mln_lang_block_t,
) -> libc::c_int {
    let mut pos: *mut mln_string_t = (*block).data.pos;
    let mut node: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
    let mut stm: *mut mln_lang_stm_t = 0 as *mut mln_lang_stm_t;
    mln_lang_ctx_reset_ret_var(ctx);
    stm = (*(*ctx).scope_top).entry;
    while !stm.is_null() {
        if (*stm).type_0 as libc::c_uint == M_STM_LABEL as libc::c_int as libc::c_uint
            && mln_string_strcmp((*stm).data.pos, pos) == 0
        {
            stm = (*stm).next;
            break;
        } else {
            stm = (*stm).next;
        }
    }
    if stm.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"Invalid label.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    loop {
        node = (*ctx).run_stack_top;
        if node == (*(*ctx).scope_top).cur_stack {
            break;
        }
        let mut n: *mut mln_lang_stack_node_t = ({
            let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
            if !n_0.is_null()
                && {
                    (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                    (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                }
            {
                (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
            }
            n_0
        });
        if !n.is_null() {
            if !((*n).ret_var).is_null() {
                __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                (*n).ret_var = 0 as *mut mln_lang_var_t;
            }
            if !((*n).ret_var2).is_null() {
                __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
            }
        }
    }
    node = ({
        let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
        if ((*ctx).run_stack_top).is_null() {
            (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
            n = (*ctx).run_stack_top;
        } else if (((*ctx).run_stack_top).offset_from(((*ctx).run_stack).as_mut_ptr())
            as libc::c_long) < 1024 as libc::c_int as libc::c_long
        {
            (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
            n = (*ctx).run_stack_top;
        }
        if !n.is_null() {
            (*n).type_0 = M_LSNT_STM;
            (*n).pos = 0 as *mut libc::c_void;
            (*n).ret_var2 = 0 as *mut mln_lang_var_t;
            (*n).ret_var = (*n).ret_var2;
            (*n).set_step(0 as libc::c_int as mln_u32_t);
            (*n).set_call(0 as libc::c_int as mln_u32_t);
            match M_LSNT_STM as libc::c_int {
                0 => {
                    (*n).data.stm = stm;
                }
                1 => {
                    (*n).data.funcdef = stm as *mut mln_lang_funcdef_t;
                }
                2 => {
                    (*n).data.set = stm as *mut mln_lang_set_t;
                }
                3 => {
                    (*n).data.set_stm = stm as *mut mln_lang_setstm_t;
                }
                4 => {
                    (*n).data.block = stm as *mut mln_lang_block_t;
                }
                5 => {
                    (*n).data.w = stm as *mut mln_lang_while_t;
                }
                6 => {
                    (*n).data.sw = stm as *mut mln_lang_switch_t;
                }
                7 => {
                    (*n).data.sw_stm = stm as *mut mln_lang_switchstm_t;
                }
                8 => {
                    (*n).data.f = stm as *mut mln_lang_for_t;
                }
                9 => {
                    (*n).data.i = stm as *mut mln_lang_if_t;
                }
                10 => {
                    (*n).data.exp = stm as *mut mln_lang_exp_t;
                }
                11 => {
                    (*n).data.assign = stm as *mut mln_lang_assign_t;
                }
                12 => {
                    (*n).data.logiclow = stm as *mut mln_lang_logiclow_t;
                }
                13 => {
                    (*n).data.logichigh = stm as *mut mln_lang_logichigh_t;
                    (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                }
                14 => {
                    (*n).data.relativelow = stm as *mut mln_lang_relativelow_t;
                    (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                }
                15 => {
                    (*n).data.relativehigh = stm as *mut mln_lang_relativehigh_t;
                    (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                }
                16 => {
                    (*n).data.move_0 = stm as *mut mln_lang_move_t;
                    (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                }
                17 => {
                    (*n).data.addsub = stm as *mut mln_lang_addsub_t;
                    (*n).pos = (*n).data.addsub as *mut libc::c_void;
                }
                18 => {
                    (*n).data.muldiv = stm as *mut mln_lang_muldiv_t;
                    (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                }
                19 => {
                    (*n).data.not = stm as *mut mln_lang_not_t;
                    (*n).pos = (*n).data.not as *mut libc::c_void;
                }
                20 => {
                    (*n).data.suffix = stm as *mut mln_lang_suffix_t;
                }
                21 => {
                    (*n).data.locate = stm as *mut mln_lang_locate_t;
                }
                22 => {
                    (*n).data.spec = stm as *mut mln_lang_spec_t;
                }
                23 => {
                    (*n).data.factor = stm as *mut mln_lang_factor_t;
                }
                _ => {
                    (*n).data.elemlist = stm as *mut mln_lang_elemlist_t;
                }
            }
        }
        n
    });
    if node.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"Stack is full.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    (mln_lang_stack_map[(*node).type_0 as usize])
        .expect("non-null function pointer")(ctx);
    return 0 as libc::c_int;
}
#[inline]
unsafe extern "C" fn mln_lang_stack_handler_block_if(
    mut ctx: *mut mln_lang_ctx_t,
    mut block: *mut mln_lang_block_t,
) -> libc::c_int {
    let mut node: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
    node = ({
        let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
        if ((*ctx).run_stack_top).is_null() {
            (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
            n = (*ctx).run_stack_top;
        } else if (((*ctx).run_stack_top).offset_from(((*ctx).run_stack).as_mut_ptr())
            as libc::c_long) < 1024 as libc::c_int as libc::c_long
        {
            (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
            n = (*ctx).run_stack_top;
        }
        if !n.is_null() {
            (*n).type_0 = M_LSNT_IF;
            (*n).pos = 0 as *mut libc::c_void;
            (*n).ret_var2 = 0 as *mut mln_lang_var_t;
            (*n).ret_var = (*n).ret_var2;
            (*n).set_step(0 as libc::c_int as mln_u32_t);
            (*n).set_call(0 as libc::c_int as mln_u32_t);
            match M_LSNT_IF as libc::c_int {
                0 => {
                    (*n).data.stm = (*block).data.i as *mut mln_lang_stm_t;
                }
                1 => {
                    (*n).data.funcdef = (*block).data.i as *mut mln_lang_funcdef_t;
                }
                2 => {
                    (*n).data.set = (*block).data.i as *mut mln_lang_set_t;
                }
                3 => {
                    (*n).data.set_stm = (*block).data.i as *mut mln_lang_setstm_t;
                }
                4 => {
                    (*n).data.block = (*block).data.i as *mut mln_lang_block_t;
                }
                5 => {
                    (*n).data.w = (*block).data.i as *mut mln_lang_while_t;
                }
                6 => {
                    (*n).data.sw = (*block).data.i as *mut mln_lang_switch_t;
                }
                7 => {
                    (*n).data.sw_stm = (*block).data.i as *mut mln_lang_switchstm_t;
                }
                8 => {
                    (*n).data.f = (*block).data.i as *mut mln_lang_for_t;
                }
                9 => {
                    (*n).data.i = (*block).data.i;
                }
                10 => {
                    (*n).data.exp = (*block).data.i as *mut mln_lang_exp_t;
                }
                11 => {
                    (*n).data.assign = (*block).data.i as *mut mln_lang_assign_t;
                }
                12 => {
                    (*n).data.logiclow = (*block).data.i as *mut mln_lang_logiclow_t;
                }
                13 => {
                    (*n).data.logichigh = (*block).data.i as *mut mln_lang_logichigh_t;
                    (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                }
                14 => {
                    (*n)
                        .data
                        .relativelow = (*block).data.i as *mut mln_lang_relativelow_t;
                    (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                }
                15 => {
                    (*n)
                        .data
                        .relativehigh = (*block).data.i as *mut mln_lang_relativehigh_t;
                    (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                }
                16 => {
                    (*n).data.move_0 = (*block).data.i as *mut mln_lang_move_t;
                    (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                }
                17 => {
                    (*n).data.addsub = (*block).data.i as *mut mln_lang_addsub_t;
                    (*n).pos = (*n).data.addsub as *mut libc::c_void;
                }
                18 => {
                    (*n).data.muldiv = (*block).data.i as *mut mln_lang_muldiv_t;
                    (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                }
                19 => {
                    (*n).data.not = (*block).data.i as *mut mln_lang_not_t;
                    (*n).pos = (*n).data.not as *mut libc::c_void;
                }
                20 => {
                    (*n).data.suffix = (*block).data.i as *mut mln_lang_suffix_t;
                }
                21 => {
                    (*n).data.locate = (*block).data.i as *mut mln_lang_locate_t;
                }
                22 => {
                    (*n).data.spec = (*block).data.i as *mut mln_lang_spec_t;
                }
                23 => {
                    (*n).data.factor = (*block).data.i as *mut mln_lang_factor_t;
                }
                _ => {
                    (*n).data.elemlist = (*block).data.i as *mut mln_lang_elemlist_t;
                }
            }
        }
        n
    });
    if node.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"Stack is full.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    (mln_lang_stack_map[(*node).type_0 as usize])
        .expect("non-null function pointer")(ctx);
    return 0 as libc::c_int;
}
#[inline]
unsafe extern "C" fn mln_lang_withdraw_to_loop(
    mut ctx: *mut mln_lang_ctx_t,
) -> *mut mln_lang_stack_node_t {
    mln_lang_ctx_reset_ret_var(ctx);
    let mut node: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
    loop {
        node = (*ctx).run_stack_top;
        if node.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"break or continue not in loop statement.\0" as *const u8
                    as *const libc::c_char as *mut libc::c_char,
            );
            return 0 as *mut mln_lang_stack_node_t;
        }
        if (*node).type_0 as libc::c_uint == M_LSNT_WHILE as libc::c_int as libc::c_uint
            || (*node).type_0 as libc::c_uint
                == M_LSNT_SWITCH as libc::c_int as libc::c_uint
            || (*node).type_0 as libc::c_uint
                == M_LSNT_FOR as libc::c_int as libc::c_uint
        {
            break;
        }
        let mut n: *mut mln_lang_stack_node_t = ({
            let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
            if !n_0.is_null()
                && {
                    (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                    (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                }
            {
                (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
            }
            n_0
        });
        if !n.is_null() {
            if !((*n).ret_var).is_null() {
                __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                (*n).ret_var = 0 as *mut mln_lang_var_t;
            }
            if !((*n).ret_var2).is_null() {
                __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
            }
        }
    }
    return node;
}
#[inline]
unsafe extern "C" fn mln_lang_withdraw_break_loop(
    mut ctx: *mut mln_lang_ctx_t,
) -> *mut mln_lang_stack_node_t {
    mln_lang_ctx_reset_ret_var(ctx);
    let mut node: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
    let mut stm: *mut mln_lang_stm_t = 0 as *mut mln_lang_stm_t;
    loop {
        node = (*ctx).run_stack_top;
        if node.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"break or continue not in loop statement.\0" as *const u8
                    as *const libc::c_char as *mut libc::c_char,
            );
            return 0 as *mut mln_lang_stack_node_t;
        }
        if (*node).type_0 as libc::c_uint != M_LSNT_STM as libc::c_int as libc::c_uint {
            let mut n: *mut mln_lang_stack_node_t = ({
                let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                if !n_0.is_null()
                    && {
                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                        (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                    }
                {
                    (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                }
                n_0
            });
            if !n.is_null() {
                if !((*n).ret_var).is_null() {
                    __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                    (*n).ret_var = 0 as *mut mln_lang_var_t;
                }
                if !((*n).ret_var2).is_null() {
                    __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                }
            }
        } else {
            stm = (*node).data.stm;
            if !((*stm).type_0 as libc::c_uint
                != M_STM_SWITCH as libc::c_int as libc::c_uint
                && (*stm).type_0 as libc::c_uint
                    != M_STM_WHILE as libc::c_int as libc::c_uint
                && (*stm).type_0 as libc::c_uint
                    != M_STM_FOR as libc::c_int as libc::c_uint)
            {
                break;
            }
            let mut n: *mut mln_lang_stack_node_t = ({
                let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                if !n_0.is_null()
                    && {
                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                        (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                    }
                {
                    (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                }
                n_0
            });
            if !n.is_null() {
                if !((*n).ret_var).is_null() {
                    __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                    (*n).ret_var = 0 as *mut mln_lang_var_t;
                }
                if !((*n).ret_var2).is_null() {
                    __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                }
            }
        }
    }
    return node;
}
#[inline]
unsafe extern "C" fn mln_lang_withdraw_until_func(
    mut ctx: *mut mln_lang_ctx_t,
) -> libc::c_int {
    let mut node: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
    let mut scope: *mut mln_lang_scope_t = (*ctx).scope_top;
    loop {
        node = (*ctx).run_stack_top;
        if node.is_null() {
            break;
        }
        if (*scope).cur_stack == node {
            break;
        }
        let mut n: *mut mln_lang_stack_node_t = ({
            let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
            if !n_0.is_null()
                && {
                    (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                    (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                }
            {
                (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
            }
            n_0
        });
        if !n.is_null() {
            if !((*n).ret_var).is_null() {
                __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                (*n).ret_var = 0 as *mut mln_lang_var_t;
            }
            if !((*n).ret_var2).is_null() {
                __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
            }
        }
    }
    let mut s: *mut mln_lang_scope_t = (*ctx).scope_top;
    let mut sym: *mut mln_lang_symbol_node_t = 0 as *mut mln_lang_symbol_node_t;
    if !s.is_null() {
        if !((*s).name).is_null() {
            let mut __s: *mut mln_string_t = (*s).name;
            if !__s.is_null() {
                let ref mut fresh37 = (*__s).ref_0();
                let fresh38 = *fresh37;
                *fresh37 = (*fresh37).wrapping_sub(1);
                if fresh38 <= 1 as libc::c_int as libc::c_ulong {
                    if (*__s).data_ref() == 0 && !((*__s).data).is_null() {
                        if (*__s).pool() != 0 {
                            mln_alloc_free((*__s).data as *mut libc::c_void);
                        } else {
                            free((*__s).data as *mut libc::c_void);
                        }
                    }
                    if (*__s).pool() != 0 {
                        mln_alloc_free(__s as *mut libc::c_void);
                    } else {
                        free(__s as *mut libc::c_void);
                    }
                }
            }
        }
        loop {
            sym = (*s).sym_head;
            if sym.is_null() {
                break;
            }
            mln_lang_sym_scope_chain_del(&mut (*s).sym_head, &mut (*s).sym_tail, sym);
            mln_lang_sym_chain_del(
                &mut (*(*sym).bucket).head,
                &mut (*(*sym).bucket).tail,
                sym,
            );
            mln_lang_symbol_node_free(sym as *mut libc::c_void);
        }
        (*ctx).scope_top = ((*ctx).scope_top).offset(-1);
        if (*ctx).scope_top < ((*ctx).scopes).as_mut_ptr() {
            (*ctx).scope_top = 0 as *mut mln_lang_scope_t;
        }
    }
    if ((*ctx).ret_var).is_null() {
        let mut ret_var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
        ret_var = __mln_lang_var_create_nil(ctx, 0 as *mut mln_string_t);
        if ret_var.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            return -(1 as libc::c_int);
        }
        __mln_lang_ctx_set_ret_var(ctx, ret_var);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn mln_lang_stack_handler_while(mut ctx: *mut mln_lang_ctx_t) {
    let mut node: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
    let mut w: *mut mln_lang_while_t = (*node).data.w;
    if (*node).step() as libc::c_int == 0 as libc::c_int {
        (*node).set_step(1 as libc::c_int as mln_u32_t);
        if ((*w).condition).is_null() {
            let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
            var = __mln_lang_var_create_true(ctx, 0 as *mut mln_string_t);
            if var.is_null() {
                __mln_lang_errmsg(
                    ctx,
                    b"No memory.\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                );
                (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                return;
            }
            __mln_lang_ctx_set_ret_var(ctx, var);
        } else {
            node = ({
                let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
                if ((*ctx).run_stack_top).is_null() {
                    (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                    n = (*ctx).run_stack_top;
                } else if (((*ctx).run_stack_top)
                    .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                    < 1024 as libc::c_int as libc::c_long
                {
                    (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                    n = (*ctx).run_stack_top;
                }
                if !n.is_null() {
                    (*n).type_0 = M_LSNT_EXP;
                    (*n).pos = 0 as *mut libc::c_void;
                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    (*n).ret_var = (*n).ret_var2;
                    (*n).set_step(0 as libc::c_int as mln_u32_t);
                    (*n).set_call(0 as libc::c_int as mln_u32_t);
                    match M_LSNT_EXP as libc::c_int {
                        0 => {
                            (*n).data.stm = (*w).condition as *mut mln_lang_stm_t;
                        }
                        1 => {
                            (*n)
                                .data
                                .funcdef = (*w).condition as *mut mln_lang_funcdef_t;
                        }
                        2 => {
                            (*n).data.set = (*w).condition as *mut mln_lang_set_t;
                        }
                        3 => {
                            (*n).data.set_stm = (*w).condition as *mut mln_lang_setstm_t;
                        }
                        4 => {
                            (*n).data.block = (*w).condition as *mut mln_lang_block_t;
                        }
                        5 => {
                            (*n).data.w = (*w).condition as *mut mln_lang_while_t;
                        }
                        6 => {
                            (*n).data.sw = (*w).condition as *mut mln_lang_switch_t;
                        }
                        7 => {
                            (*n)
                                .data
                                .sw_stm = (*w).condition as *mut mln_lang_switchstm_t;
                        }
                        8 => {
                            (*n).data.f = (*w).condition as *mut mln_lang_for_t;
                        }
                        9 => {
                            (*n).data.i = (*w).condition as *mut mln_lang_if_t;
                        }
                        10 => {
                            (*n).data.exp = (*w).condition;
                        }
                        11 => {
                            (*n).data.assign = (*w).condition as *mut mln_lang_assign_t;
                        }
                        12 => {
                            (*n)
                                .data
                                .logiclow = (*w).condition as *mut mln_lang_logiclow_t;
                        }
                        13 => {
                            (*n)
                                .data
                                .logichigh = (*w).condition as *mut mln_lang_logichigh_t;
                            (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                        }
                        14 => {
                            (*n)
                                .data
                                .relativelow = (*w).condition
                                as *mut mln_lang_relativelow_t;
                            (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                        }
                        15 => {
                            (*n)
                                .data
                                .relativehigh = (*w).condition
                                as *mut mln_lang_relativehigh_t;
                            (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                        }
                        16 => {
                            (*n).data.move_0 = (*w).condition as *mut mln_lang_move_t;
                            (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                        }
                        17 => {
                            (*n).data.addsub = (*w).condition as *mut mln_lang_addsub_t;
                            (*n).pos = (*n).data.addsub as *mut libc::c_void;
                        }
                        18 => {
                            (*n).data.muldiv = (*w).condition as *mut mln_lang_muldiv_t;
                            (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                        }
                        19 => {
                            (*n).data.not = (*w).condition as *mut mln_lang_not_t;
                            (*n).pos = (*n).data.not as *mut libc::c_void;
                        }
                        20 => {
                            (*n).data.suffix = (*w).condition as *mut mln_lang_suffix_t;
                        }
                        21 => {
                            (*n).data.locate = (*w).condition as *mut mln_lang_locate_t;
                        }
                        22 => {
                            (*n).data.spec = (*w).condition as *mut mln_lang_spec_t;
                        }
                        23 => {
                            (*n).data.factor = (*w).condition as *mut mln_lang_factor_t;
                        }
                        _ => {
                            (*n)
                                .data
                                .elemlist = (*w).condition as *mut mln_lang_elemlist_t;
                        }
                    }
                }
                n
            });
            if node.is_null() {
                __mln_lang_errmsg(
                    ctx,
                    b"Stack is full.\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                );
                (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                return;
            }
            (mln_lang_stack_map[(*node).type_0 as usize])
                .expect("non-null function pointer")(ctx);
            return;
        }
    }
    if __mln_lang_condition_is_true((*ctx).ret_var) != 0 {
        (*node).set_step(0 as libc::c_int as mln_u32_t);
        if !((*w).blockstm).is_null() {
            node = ({
                let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
                if ((*ctx).run_stack_top).is_null() {
                    (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                    n = (*ctx).run_stack_top;
                } else if (((*ctx).run_stack_top)
                    .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                    < 1024 as libc::c_int as libc::c_long
                {
                    (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                    n = (*ctx).run_stack_top;
                }
                if !n.is_null() {
                    (*n).type_0 = M_LSNT_BLOCK;
                    (*n).pos = 0 as *mut libc::c_void;
                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    (*n).ret_var = (*n).ret_var2;
                    (*n).set_step(0 as libc::c_int as mln_u32_t);
                    (*n).set_call(0 as libc::c_int as mln_u32_t);
                    match M_LSNT_BLOCK as libc::c_int {
                        0 => {
                            (*n).data.stm = (*w).blockstm as *mut mln_lang_stm_t;
                        }
                        1 => {
                            (*n).data.funcdef = (*w).blockstm as *mut mln_lang_funcdef_t;
                        }
                        2 => {
                            (*n).data.set = (*w).blockstm as *mut mln_lang_set_t;
                        }
                        3 => {
                            (*n).data.set_stm = (*w).blockstm as *mut mln_lang_setstm_t;
                        }
                        4 => {
                            (*n).data.block = (*w).blockstm;
                        }
                        5 => {
                            (*n).data.w = (*w).blockstm as *mut mln_lang_while_t;
                        }
                        6 => {
                            (*n).data.sw = (*w).blockstm as *mut mln_lang_switch_t;
                        }
                        7 => {
                            (*n)
                                .data
                                .sw_stm = (*w).blockstm as *mut mln_lang_switchstm_t;
                        }
                        8 => {
                            (*n).data.f = (*w).blockstm as *mut mln_lang_for_t;
                        }
                        9 => {
                            (*n).data.i = (*w).blockstm as *mut mln_lang_if_t;
                        }
                        10 => {
                            (*n).data.exp = (*w).blockstm as *mut mln_lang_exp_t;
                        }
                        11 => {
                            (*n).data.assign = (*w).blockstm as *mut mln_lang_assign_t;
                        }
                        12 => {
                            (*n)
                                .data
                                .logiclow = (*w).blockstm as *mut mln_lang_logiclow_t;
                        }
                        13 => {
                            (*n)
                                .data
                                .logichigh = (*w).blockstm as *mut mln_lang_logichigh_t;
                            (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                        }
                        14 => {
                            (*n)
                                .data
                                .relativelow = (*w).blockstm as *mut mln_lang_relativelow_t;
                            (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                        }
                        15 => {
                            (*n)
                                .data
                                .relativehigh = (*w).blockstm
                                as *mut mln_lang_relativehigh_t;
                            (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                        }
                        16 => {
                            (*n).data.move_0 = (*w).blockstm as *mut mln_lang_move_t;
                            (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                        }
                        17 => {
                            (*n).data.addsub = (*w).blockstm as *mut mln_lang_addsub_t;
                            (*n).pos = (*n).data.addsub as *mut libc::c_void;
                        }
                        18 => {
                            (*n).data.muldiv = (*w).blockstm as *mut mln_lang_muldiv_t;
                            (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                        }
                        19 => {
                            (*n).data.not = (*w).blockstm as *mut mln_lang_not_t;
                            (*n).pos = (*n).data.not as *mut libc::c_void;
                        }
                        20 => {
                            (*n).data.suffix = (*w).blockstm as *mut mln_lang_suffix_t;
                        }
                        21 => {
                            (*n).data.locate = (*w).blockstm as *mut mln_lang_locate_t;
                        }
                        22 => {
                            (*n).data.spec = (*w).blockstm as *mut mln_lang_spec_t;
                        }
                        23 => {
                            (*n).data.factor = (*w).blockstm as *mut mln_lang_factor_t;
                        }
                        _ => {
                            (*n)
                                .data
                                .elemlist = (*w).blockstm as *mut mln_lang_elemlist_t;
                        }
                    }
                }
                n
            });
            if node.is_null() {
                __mln_lang_errmsg(
                    ctx,
                    b"Stack is full.\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                );
                (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                return;
            }
            (mln_lang_stack_map[(*node).type_0 as usize])
                .expect("non-null function pointer")(ctx);
            return;
        }
    } else {
        mln_lang_ctx_reset_ret_var(ctx);
        let mut n: *mut mln_lang_stack_node_t = ({
            let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
            if !n_0.is_null()
                && {
                    (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                    (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                }
            {
                (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
            }
            n_0
        });
        if !n.is_null() {
            if !((*n).ret_var).is_null() {
                __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                (*n).ret_var = 0 as *mut mln_lang_var_t;
            }
            if !((*n).ret_var2).is_null() {
                __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
            }
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_condition_is_true(
    mut var: *mut mln_lang_var_t,
) -> libc::c_int {
    return __mln_lang_condition_is_true(var);
}
#[inline]
unsafe extern "C" fn __mln_lang_condition_is_true(
    mut var: *mut mln_lang_var_t,
) -> libc::c_int {
    let mut val: *mut mln_lang_val_t = 0 as *mut mln_lang_val_t;
    val = (*var).val;
    if val.is_null() {
        return 0 as libc::c_int;
    }
    match (*val).type_0 {
        0 => {}
        1 => {
            if (*val).data.i != 0 {
                return 1 as libc::c_int;
            }
        }
        2 => {
            if (*val).data.b != 0 {
                return 1 as libc::c_int;
            }
        }
        3 => {
            if (*val).data.f < -2.2204460492503131E-16f64
                || (*val).data.f > 2.2204460492503131E-16f64
            {
                return 1 as libc::c_int;
            }
        }
        4 => {
            if !((*val).data.s).is_null() && (*(*val).data.s).len != 0 {
                return 1 as libc::c_int;
            }
        }
        5 => {
            if !((*val).data.obj).is_null() {
                return 1 as libc::c_int;
            }
        }
        6 => {
            if !((*val).data.func).is_null() {
                return 1 as libc::c_int;
            }
        }
        7 => {
            if !((*val).data.array).is_null()
                && (*(*(*val).data.array).elems_index).nr_node
                    > 0 as libc::c_int as libc::c_ulong
            {
                return 1 as libc::c_int;
            }
        }
        _ => {
            _mln_sys_log(
                error,
                b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<
                    &[u8; 29],
                    &[libc::c_char; 29],
                >(b"__mln_lang_condition_is_true\0"))
                    .as_ptr(),
                3898 as libc::c_int,
                b"shouldn't be here. %X\n\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                (*val).type_0,
            );
            abort();
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn mln_lang_stack_handler_switch(mut ctx: *mut mln_lang_ctx_t) {
    let mut node: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
    let mut sw: *mut mln_lang_switch_t = (*node).data.sw;
    if (*node).step() as libc::c_int == 0 as libc::c_int {
        (*node)
            .set_step(
                (if ((*sw).switchstm).is_null() {
                    2 as libc::c_int
                } else {
                    1 as libc::c_int
                }) as mln_u32_t,
            );
        if ((*sw).condition).is_null() {
            __mln_lang_ctx_set_ret_var(ctx, 0 as *mut mln_lang_var_t);
        } else {
            node = ({
                let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
                if ((*ctx).run_stack_top).is_null() {
                    (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                    n = (*ctx).run_stack_top;
                } else if (((*ctx).run_stack_top)
                    .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                    < 1024 as libc::c_int as libc::c_long
                {
                    (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                    n = (*ctx).run_stack_top;
                }
                if !n.is_null() {
                    (*n).type_0 = M_LSNT_EXP;
                    (*n).pos = 0 as *mut libc::c_void;
                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    (*n).ret_var = (*n).ret_var2;
                    (*n).set_step(0 as libc::c_int as mln_u32_t);
                    (*n).set_call(0 as libc::c_int as mln_u32_t);
                    match M_LSNT_EXP as libc::c_int {
                        0 => {
                            (*n).data.stm = (*sw).condition as *mut mln_lang_stm_t;
                        }
                        1 => {
                            (*n)
                                .data
                                .funcdef = (*sw).condition as *mut mln_lang_funcdef_t;
                        }
                        2 => {
                            (*n).data.set = (*sw).condition as *mut mln_lang_set_t;
                        }
                        3 => {
                            (*n)
                                .data
                                .set_stm = (*sw).condition as *mut mln_lang_setstm_t;
                        }
                        4 => {
                            (*n).data.block = (*sw).condition as *mut mln_lang_block_t;
                        }
                        5 => {
                            (*n).data.w = (*sw).condition as *mut mln_lang_while_t;
                        }
                        6 => {
                            (*n).data.sw = (*sw).condition as *mut mln_lang_switch_t;
                        }
                        7 => {
                            (*n)
                                .data
                                .sw_stm = (*sw).condition as *mut mln_lang_switchstm_t;
                        }
                        8 => {
                            (*n).data.f = (*sw).condition as *mut mln_lang_for_t;
                        }
                        9 => {
                            (*n).data.i = (*sw).condition as *mut mln_lang_if_t;
                        }
                        10 => {
                            (*n).data.exp = (*sw).condition;
                        }
                        11 => {
                            (*n).data.assign = (*sw).condition as *mut mln_lang_assign_t;
                        }
                        12 => {
                            (*n)
                                .data
                                .logiclow = (*sw).condition as *mut mln_lang_logiclow_t;
                        }
                        13 => {
                            (*n)
                                .data
                                .logichigh = (*sw).condition as *mut mln_lang_logichigh_t;
                            (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                        }
                        14 => {
                            (*n)
                                .data
                                .relativelow = (*sw).condition
                                as *mut mln_lang_relativelow_t;
                            (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                        }
                        15 => {
                            (*n)
                                .data
                                .relativehigh = (*sw).condition
                                as *mut mln_lang_relativehigh_t;
                            (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                        }
                        16 => {
                            (*n).data.move_0 = (*sw).condition as *mut mln_lang_move_t;
                            (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                        }
                        17 => {
                            (*n).data.addsub = (*sw).condition as *mut mln_lang_addsub_t;
                            (*n).pos = (*n).data.addsub as *mut libc::c_void;
                        }
                        18 => {
                            (*n).data.muldiv = (*sw).condition as *mut mln_lang_muldiv_t;
                            (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                        }
                        19 => {
                            (*n).data.not = (*sw).condition as *mut mln_lang_not_t;
                            (*n).pos = (*n).data.not as *mut libc::c_void;
                        }
                        20 => {
                            (*n).data.suffix = (*sw).condition as *mut mln_lang_suffix_t;
                        }
                        21 => {
                            (*n).data.locate = (*sw).condition as *mut mln_lang_locate_t;
                        }
                        22 => {
                            (*n).data.spec = (*sw).condition as *mut mln_lang_spec_t;
                        }
                        23 => {
                            (*n).data.factor = (*sw).condition as *mut mln_lang_factor_t;
                        }
                        _ => {
                            (*n)
                                .data
                                .elemlist = (*sw).condition as *mut mln_lang_elemlist_t;
                        }
                    }
                }
                n
            });
            if node.is_null() {
                __mln_lang_errmsg(
                    ctx,
                    b"Stack is full.\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                );
                (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                return;
            }
            (mln_lang_stack_map[(*node).type_0 as usize])
                .expect("non-null function pointer")(ctx);
            return;
        }
    } else if (*node).step() as libc::c_int == 1 as libc::c_int {
        (*node).set_step(2 as libc::c_int as mln_u32_t);
        mln_lang_stack_node_get_ctx_ret_var(node, ctx);
        node = ({
            let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
            if ((*ctx).run_stack_top).is_null() {
                (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                n = (*ctx).run_stack_top;
            } else if (((*ctx).run_stack_top)
                .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                < 1024 as libc::c_int as libc::c_long
            {
                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                n = (*ctx).run_stack_top;
            }
            if !n.is_null() {
                (*n).type_0 = M_LSNT_SWITCHSTM;
                (*n).pos = 0 as *mut libc::c_void;
                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                (*n).ret_var = (*n).ret_var2;
                (*n).set_step(0 as libc::c_int as mln_u32_t);
                (*n).set_call(0 as libc::c_int as mln_u32_t);
                match M_LSNT_SWITCHSTM as libc::c_int {
                    0 => {
                        (*n).data.stm = (*sw).switchstm as *mut mln_lang_stm_t;
                    }
                    1 => {
                        (*n).data.funcdef = (*sw).switchstm as *mut mln_lang_funcdef_t;
                    }
                    2 => {
                        (*n).data.set = (*sw).switchstm as *mut mln_lang_set_t;
                    }
                    3 => {
                        (*n).data.set_stm = (*sw).switchstm as *mut mln_lang_setstm_t;
                    }
                    4 => {
                        (*n).data.block = (*sw).switchstm as *mut mln_lang_block_t;
                    }
                    5 => {
                        (*n).data.w = (*sw).switchstm as *mut mln_lang_while_t;
                    }
                    6 => {
                        (*n).data.sw = (*sw).switchstm as *mut mln_lang_switch_t;
                    }
                    7 => {
                        (*n).data.sw_stm = (*sw).switchstm;
                    }
                    8 => {
                        (*n).data.f = (*sw).switchstm as *mut mln_lang_for_t;
                    }
                    9 => {
                        (*n).data.i = (*sw).switchstm as *mut mln_lang_if_t;
                    }
                    10 => {
                        (*n).data.exp = (*sw).switchstm as *mut mln_lang_exp_t;
                    }
                    11 => {
                        (*n).data.assign = (*sw).switchstm as *mut mln_lang_assign_t;
                    }
                    12 => {
                        (*n).data.logiclow = (*sw).switchstm as *mut mln_lang_logiclow_t;
                    }
                    13 => {
                        (*n)
                            .data
                            .logichigh = (*sw).switchstm as *mut mln_lang_logichigh_t;
                        (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                    }
                    14 => {
                        (*n)
                            .data
                            .relativelow = (*sw).switchstm
                            as *mut mln_lang_relativelow_t;
                        (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                    }
                    15 => {
                        (*n)
                            .data
                            .relativehigh = (*sw).switchstm
                            as *mut mln_lang_relativehigh_t;
                        (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                    }
                    16 => {
                        (*n).data.move_0 = (*sw).switchstm as *mut mln_lang_move_t;
                        (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                    }
                    17 => {
                        (*n).data.addsub = (*sw).switchstm as *mut mln_lang_addsub_t;
                        (*n).pos = (*n).data.addsub as *mut libc::c_void;
                    }
                    18 => {
                        (*n).data.muldiv = (*sw).switchstm as *mut mln_lang_muldiv_t;
                        (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                    }
                    19 => {
                        (*n).data.not = (*sw).switchstm as *mut mln_lang_not_t;
                        (*n).pos = (*n).data.not as *mut libc::c_void;
                    }
                    20 => {
                        (*n).data.suffix = (*sw).switchstm as *mut mln_lang_suffix_t;
                    }
                    21 => {
                        (*n).data.locate = (*sw).switchstm as *mut mln_lang_locate_t;
                    }
                    22 => {
                        (*n).data.spec = (*sw).switchstm as *mut mln_lang_spec_t;
                    }
                    23 => {
                        (*n).data.factor = (*sw).switchstm as *mut mln_lang_factor_t;
                    }
                    _ => {
                        (*n).data.elemlist = (*sw).switchstm as *mut mln_lang_elemlist_t;
                    }
                }
            }
            n
        });
        if node.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"Stack is full.\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
            return;
        }
        (mln_lang_stack_map[(*node).type_0 as usize])
            .expect("non-null function pointer")(ctx);
        return;
    } else {
        let mut n: *mut mln_lang_stack_node_t = ({
            let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
            if !n_0.is_null()
                && {
                    (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                    (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                }
            {
                (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
            }
            n_0
        });
        if !n.is_null() {
            if !((*n).ret_var).is_null() {
                __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                (*n).ret_var = 0 as *mut mln_lang_var_t;
            }
            if !((*n).ret_var2).is_null() {
                __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
            }
        }
    };
}
unsafe extern "C" fn mln_lang_stack_handler_switchstm(mut ctx: *mut mln_lang_ctx_t) {
    let mut sw_node_0: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
    let mut handler: mln_lang_op = None;
    let mut method: *mut mln_lang_method_t = 0 as *mut mln_lang_method_t;
    let mut current_block: u64;
    let mut res: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut node: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
    let mut sw_stm: *mut mln_lang_switchstm_t = (*node).data.sw_stm;
    if (*node).step() as libc::c_int == 0 as libc::c_int {
        (*node).set_step(1 as libc::c_int as mln_u32_t);
        mln_lang_ctx_reset_ret_var(ctx);
        node = ({
            let mut n: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
            if !n.is_null()
                && {
                    (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                    (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                }
            {
                (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
            }
            n
        });
        let mut sw_node: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
        if ((*ctx).run_stack_top).is_null() {
            (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
        } else if (((*ctx).run_stack_top).offset_from(((*ctx).run_stack).as_mut_ptr())
            as libc::c_long) < 1024 as libc::c_int as libc::c_long
        {
            (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
            (*ctx).run_stack_top;
        }
        if !((*sw_node).ret_var).is_null() && !((*sw_stm).factor).is_null() {
            node = ({
                let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
                if ((*ctx).run_stack_top).is_null() {
                    (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                    n = (*ctx).run_stack_top;
                } else if (((*ctx).run_stack_top)
                    .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                    < 1024 as libc::c_int as libc::c_long
                {
                    (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                    n = (*ctx).run_stack_top;
                }
                if !n.is_null() {
                    (*n).type_0 = M_LSNT_FACTOR;
                    (*n).pos = 0 as *mut libc::c_void;
                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    (*n).ret_var = (*n).ret_var2;
                    (*n).set_step(0 as libc::c_int as mln_u32_t);
                    (*n).set_call(0 as libc::c_int as mln_u32_t);
                    match M_LSNT_FACTOR as libc::c_int {
                        0 => {
                            (*n).data.stm = (*sw_stm).factor as *mut mln_lang_stm_t;
                        }
                        1 => {
                            (*n)
                                .data
                                .funcdef = (*sw_stm).factor as *mut mln_lang_funcdef_t;
                        }
                        2 => {
                            (*n).data.set = (*sw_stm).factor as *mut mln_lang_set_t;
                        }
                        3 => {
                            (*n)
                                .data
                                .set_stm = (*sw_stm).factor as *mut mln_lang_setstm_t;
                        }
                        4 => {
                            (*n).data.block = (*sw_stm).factor as *mut mln_lang_block_t;
                        }
                        5 => {
                            (*n).data.w = (*sw_stm).factor as *mut mln_lang_while_t;
                        }
                        6 => {
                            (*n).data.sw = (*sw_stm).factor as *mut mln_lang_switch_t;
                        }
                        7 => {
                            (*n)
                                .data
                                .sw_stm = (*sw_stm).factor as *mut mln_lang_switchstm_t;
                        }
                        8 => {
                            (*n).data.f = (*sw_stm).factor as *mut mln_lang_for_t;
                        }
                        9 => {
                            (*n).data.i = (*sw_stm).factor as *mut mln_lang_if_t;
                        }
                        10 => {
                            (*n).data.exp = (*sw_stm).factor as *mut mln_lang_exp_t;
                        }
                        11 => {
                            (*n)
                                .data
                                .assign = (*sw_stm).factor as *mut mln_lang_assign_t;
                        }
                        12 => {
                            (*n)
                                .data
                                .logiclow = (*sw_stm).factor as *mut mln_lang_logiclow_t;
                        }
                        13 => {
                            (*n)
                                .data
                                .logichigh = (*sw_stm).factor as *mut mln_lang_logichigh_t;
                            (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                        }
                        14 => {
                            (*n)
                                .data
                                .relativelow = (*sw_stm).factor
                                as *mut mln_lang_relativelow_t;
                            (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                        }
                        15 => {
                            (*n)
                                .data
                                .relativehigh = (*sw_stm).factor
                                as *mut mln_lang_relativehigh_t;
                            (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                        }
                        16 => {
                            (*n).data.move_0 = (*sw_stm).factor as *mut mln_lang_move_t;
                            (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                        }
                        17 => {
                            (*n)
                                .data
                                .addsub = (*sw_stm).factor as *mut mln_lang_addsub_t;
                            (*n).pos = (*n).data.addsub as *mut libc::c_void;
                        }
                        18 => {
                            (*n)
                                .data
                                .muldiv = (*sw_stm).factor as *mut mln_lang_muldiv_t;
                            (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                        }
                        19 => {
                            (*n).data.not = (*sw_stm).factor as *mut mln_lang_not_t;
                            (*n).pos = (*n).data.not as *mut libc::c_void;
                        }
                        20 => {
                            (*n)
                                .data
                                .suffix = (*sw_stm).factor as *mut mln_lang_suffix_t;
                        }
                        21 => {
                            (*n)
                                .data
                                .locate = (*sw_stm).factor as *mut mln_lang_locate_t;
                        }
                        22 => {
                            (*n).data.spec = (*sw_stm).factor as *mut mln_lang_spec_t;
                        }
                        23 => {
                            (*n).data.factor = (*sw_stm).factor;
                        }
                        _ => {
                            (*n)
                                .data
                                .elemlist = (*sw_stm).factor as *mut mln_lang_elemlist_t;
                        }
                    }
                }
                n
            });
            if node.is_null() {
                __mln_lang_errmsg(
                    ctx,
                    b"Stack is full.\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                );
                (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                return;
            }
            (mln_lang_stack_map[(*node).type_0 as usize])
                .expect("non-null function pointer")(ctx);
            return;
        } else if ((*sw_stm).stm).is_null() {
            (*node).set_step(4 as libc::c_int as mln_u32_t);
            current_block = 6912921523688366185;
        } else {
            (*node).set_step(3 as libc::c_int as mln_u32_t);
            current_block = 13763002826403452995;
        }
    } else {
        if (*node).step() as libc::c_int == 1 as libc::c_int {
            node = ({
                let mut n: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                if !n.is_null()
                    && {
                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                        (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                    }
                {
                    (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                }
                n
            });
            sw_node_0 = (*ctx).run_stack_top;
            if ((*ctx).run_stack_top).is_null() {
                (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
            } else if (((*ctx).run_stack_top)
                .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                < 1024 as libc::c_int as libc::c_long
            {
                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                (*ctx).run_stack_top;
            }
            handler = None;
            method = 0 as *mut mln_lang_method_t;
            method = mln_lang_methods[(*(*(*sw_node_0).ret_var).val).type_0 as usize];
            if method.is_null() {
                __mln_lang_errmsg(
                    ctx,
                    b"Operation NOT support.\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                );
                (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                return;
            }
            handler = (*method).equal_handler;
            if handler.is_none() {
                __mln_lang_errmsg(
                    ctx,
                    b"Operation NOT support.\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                );
                (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                return;
            }
            if handler
                .expect(
                    "non-null function pointer",
                )(ctx, &mut res, (*sw_node_0).ret_var, (*ctx).ret_var) < 0 as libc::c_int
            {
                (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                return;
            }
            __mln_lang_ctx_set_ret_var(ctx, res);
            if (*(*res).val).type_0 == 8 as libc::c_int {
                (*node).set_call(1 as libc::c_int as mln_u32_t);
                current_block = 15339868638820364548;
            } else {
                (*node).set_step(2 as libc::c_int as mln_u32_t);
                current_block = 14427901109255499357;
            }
        } else if (*node).step() as libc::c_int == 2 as libc::c_int {
            current_block = 14427901109255499357;
        } else if (*node).step() as libc::c_int == 3 as libc::c_int {
            current_block = 13763002826403452995;
        } else {
            current_block = 6912921523688366185;
        }
        match current_block {
            13763002826403452995 => {}
            6912921523688366185 => {}
            _ => {
                match current_block {
                    14427901109255499357 => {
                        node = ({
                            let mut n: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                            if !n.is_null()
                                && {
                                    (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                                    (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                                }
                            {
                                (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                            }
                            n
                        });
                        let mut sw_node_1: *mut mln_lang_stack_node_t = (*ctx)
                            .run_stack_top;
                        if ((*ctx).run_stack_top).is_null() {
                            (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                        } else if (((*ctx).run_stack_top)
                            .offset_from(((*ctx).run_stack).as_mut_ptr())
                            as libc::c_long) < 1024 as libc::c_int as libc::c_long
                        {
                            (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                            (*ctx).run_stack_top;
                        }
                        if (*node).call() != 0 {
                            if mln_lang_withdraw_until_func(ctx) < 0 as libc::c_int {
                                (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                                return;
                            }
                            res = (*ctx).ret_var;
                            if (*(*(*ctx).ret_var).val).type_0 == 8 as libc::c_int {
                                current_block = 15339868638820364548;
                            } else {
                                current_block = 6174974146017752131;
                            }
                        } else {
                            current_block = 6174974146017752131;
                        }
                        match current_block {
                            15339868638820364548 => {}
                            _ => {
                                if __mln_lang_condition_is_true((*ctx).ret_var) != 0 {
                                    mln_lang_stack_node_reset_ret_val(sw_node_1);
                                    (*node).set_step(3 as libc::c_int as mln_u32_t);
                                    current_block = 13763002826403452995;
                                } else {
                                    (*node).set_step(4 as libc::c_int as mln_u32_t);
                                    current_block = 6912921523688366185;
                                }
                            }
                        }
                    }
                    _ => {}
                }
                match current_block {
                    13763002826403452995 => {}
                    6912921523688366185 => {}
                    _ => {
                        (*node).set_step(2 as libc::c_int as mln_u32_t);
                        if mln_lang_stack_handler_funccall_run(
                            ctx,
                            node,
                            (*(*res).val).data.call,
                        ) < 0 as libc::c_int
                        {
                            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                            return;
                        }
                        current_block = 12264624100856317061;
                    }
                }
            }
        }
    }
    match current_block {
        13763002826403452995 => {
            (*node).set_step(4 as libc::c_int as mln_u32_t);
            node = ({
                let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
                if ((*ctx).run_stack_top).is_null() {
                    (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                    n = (*ctx).run_stack_top;
                } else if (((*ctx).run_stack_top)
                    .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                    < 1024 as libc::c_int as libc::c_long
                {
                    (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                    n = (*ctx).run_stack_top;
                }
                if !n.is_null() {
                    (*n).type_0 = M_LSNT_STM;
                    (*n).pos = 0 as *mut libc::c_void;
                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    (*n).ret_var = (*n).ret_var2;
                    (*n).set_step(0 as libc::c_int as mln_u32_t);
                    (*n).set_call(0 as libc::c_int as mln_u32_t);
                    match M_LSNT_STM as libc::c_int {
                        0 => {
                            (*n).data.stm = (*sw_stm).stm;
                        }
                        1 => {
                            (*n).data.funcdef = (*sw_stm).stm as *mut mln_lang_funcdef_t;
                        }
                        2 => {
                            (*n).data.set = (*sw_stm).stm as *mut mln_lang_set_t;
                        }
                        3 => {
                            (*n).data.set_stm = (*sw_stm).stm as *mut mln_lang_setstm_t;
                        }
                        4 => {
                            (*n).data.block = (*sw_stm).stm as *mut mln_lang_block_t;
                        }
                        5 => {
                            (*n).data.w = (*sw_stm).stm as *mut mln_lang_while_t;
                        }
                        6 => {
                            (*n).data.sw = (*sw_stm).stm as *mut mln_lang_switch_t;
                        }
                        7 => {
                            (*n)
                                .data
                                .sw_stm = (*sw_stm).stm as *mut mln_lang_switchstm_t;
                        }
                        8 => {
                            (*n).data.f = (*sw_stm).stm as *mut mln_lang_for_t;
                        }
                        9 => {
                            (*n).data.i = (*sw_stm).stm as *mut mln_lang_if_t;
                        }
                        10 => {
                            (*n).data.exp = (*sw_stm).stm as *mut mln_lang_exp_t;
                        }
                        11 => {
                            (*n).data.assign = (*sw_stm).stm as *mut mln_lang_assign_t;
                        }
                        12 => {
                            (*n)
                                .data
                                .logiclow = (*sw_stm).stm as *mut mln_lang_logiclow_t;
                        }
                        13 => {
                            (*n)
                                .data
                                .logichigh = (*sw_stm).stm as *mut mln_lang_logichigh_t;
                            (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                        }
                        14 => {
                            (*n)
                                .data
                                .relativelow = (*sw_stm).stm as *mut mln_lang_relativelow_t;
                            (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                        }
                        15 => {
                            (*n)
                                .data
                                .relativehigh = (*sw_stm).stm
                                as *mut mln_lang_relativehigh_t;
                            (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                        }
                        16 => {
                            (*n).data.move_0 = (*sw_stm).stm as *mut mln_lang_move_t;
                            (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                        }
                        17 => {
                            (*n).data.addsub = (*sw_stm).stm as *mut mln_lang_addsub_t;
                            (*n).pos = (*n).data.addsub as *mut libc::c_void;
                        }
                        18 => {
                            (*n).data.muldiv = (*sw_stm).stm as *mut mln_lang_muldiv_t;
                            (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                        }
                        19 => {
                            (*n).data.not = (*sw_stm).stm as *mut mln_lang_not_t;
                            (*n).pos = (*n).data.not as *mut libc::c_void;
                        }
                        20 => {
                            (*n).data.suffix = (*sw_stm).stm as *mut mln_lang_suffix_t;
                        }
                        21 => {
                            (*n).data.locate = (*sw_stm).stm as *mut mln_lang_locate_t;
                        }
                        22 => {
                            (*n).data.spec = (*sw_stm).stm as *mut mln_lang_spec_t;
                        }
                        23 => {
                            (*n).data.factor = (*sw_stm).stm as *mut mln_lang_factor_t;
                        }
                        _ => {
                            (*n)
                                .data
                                .elemlist = (*sw_stm).stm as *mut mln_lang_elemlist_t;
                        }
                    }
                }
                n
            });
            if node.is_null() {
                __mln_lang_errmsg(
                    ctx,
                    b"Stack is full.\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                );
                (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                return;
            }
            (mln_lang_stack_map[(*node).type_0 as usize])
                .expect("non-null function pointer")(ctx);
            return;
        }
        6912921523688366185 => {
            let mut n: *mut mln_lang_stack_node_t = ({
                let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                if !n_0.is_null()
                    && {
                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                        (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                    }
                {
                    (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                }
                n_0
            });
            if !n.is_null() {
                if !((*n).ret_var).is_null() {
                    __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                    (*n).ret_var = 0 as *mut mln_lang_var_t;
                }
                if !((*n).ret_var2).is_null() {
                    __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                }
            }
            if !((*sw_stm).next).is_null() {
                node = ({
                    let mut n: *mut mln_lang_stack_node_t = 0
                        as *mut mln_lang_stack_node_t;
                    if ((*ctx).run_stack_top).is_null() {
                        (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                        n = (*ctx).run_stack_top;
                    } else if (((*ctx).run_stack_top)
                        .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                        < 1024 as libc::c_int as libc::c_long
                    {
                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                        n = (*ctx).run_stack_top;
                    }
                    if !n.is_null() {
                        (*n).type_0 = M_LSNT_SWITCHSTM;
                        (*n).pos = 0 as *mut libc::c_void;
                        (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                        (*n).ret_var = (*n).ret_var2;
                        (*n).set_step(0 as libc::c_int as mln_u32_t);
                        (*n).set_call(0 as libc::c_int as mln_u32_t);
                        match M_LSNT_SWITCHSTM as libc::c_int {
                            0 => {
                                (*n).data.stm = (*sw_stm).next as *mut mln_lang_stm_t;
                            }
                            1 => {
                                (*n)
                                    .data
                                    .funcdef = (*sw_stm).next as *mut mln_lang_funcdef_t;
                            }
                            2 => {
                                (*n).data.set = (*sw_stm).next as *mut mln_lang_set_t;
                            }
                            3 => {
                                (*n)
                                    .data
                                    .set_stm = (*sw_stm).next as *mut mln_lang_setstm_t;
                            }
                            4 => {
                                (*n).data.block = (*sw_stm).next as *mut mln_lang_block_t;
                            }
                            5 => {
                                (*n).data.w = (*sw_stm).next as *mut mln_lang_while_t;
                            }
                            6 => {
                                (*n).data.sw = (*sw_stm).next as *mut mln_lang_switch_t;
                            }
                            7 => {
                                (*n).data.sw_stm = (*sw_stm).next;
                            }
                            8 => {
                                (*n).data.f = (*sw_stm).next as *mut mln_lang_for_t;
                            }
                            9 => {
                                (*n).data.i = (*sw_stm).next as *mut mln_lang_if_t;
                            }
                            10 => {
                                (*n).data.exp = (*sw_stm).next as *mut mln_lang_exp_t;
                            }
                            11 => {
                                (*n).data.assign = (*sw_stm).next as *mut mln_lang_assign_t;
                            }
                            12 => {
                                (*n)
                                    .data
                                    .logiclow = (*sw_stm).next as *mut mln_lang_logiclow_t;
                            }
                            13 => {
                                (*n)
                                    .data
                                    .logichigh = (*sw_stm).next as *mut mln_lang_logichigh_t;
                                (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                            }
                            14 => {
                                (*n)
                                    .data
                                    .relativelow = (*sw_stm).next
                                    as *mut mln_lang_relativelow_t;
                                (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                            }
                            15 => {
                                (*n)
                                    .data
                                    .relativehigh = (*sw_stm).next
                                    as *mut mln_lang_relativehigh_t;
                                (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                            }
                            16 => {
                                (*n).data.move_0 = (*sw_stm).next as *mut mln_lang_move_t;
                                (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                            }
                            17 => {
                                (*n).data.addsub = (*sw_stm).next as *mut mln_lang_addsub_t;
                                (*n).pos = (*n).data.addsub as *mut libc::c_void;
                            }
                            18 => {
                                (*n).data.muldiv = (*sw_stm).next as *mut mln_lang_muldiv_t;
                                (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                            }
                            19 => {
                                (*n).data.not = (*sw_stm).next as *mut mln_lang_not_t;
                                (*n).pos = (*n).data.not as *mut libc::c_void;
                            }
                            20 => {
                                (*n).data.suffix = (*sw_stm).next as *mut mln_lang_suffix_t;
                            }
                            21 => {
                                (*n).data.locate = (*sw_stm).next as *mut mln_lang_locate_t;
                            }
                            22 => {
                                (*n).data.spec = (*sw_stm).next as *mut mln_lang_spec_t;
                            }
                            23 => {
                                (*n).data.factor = (*sw_stm).next as *mut mln_lang_factor_t;
                            }
                            _ => {
                                (*n)
                                    .data
                                    .elemlist = (*sw_stm).next as *mut mln_lang_elemlist_t;
                            }
                        }
                    }
                    n
                });
                if node.is_null() {
                    __mln_lang_errmsg(
                        ctx,
                        b"Stack is full.\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                    );
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                (mln_lang_stack_map[(*node).type_0 as usize])
                    .expect("non-null function pointer")(ctx);
                return;
            }
        }
        _ => {}
    };
}
unsafe extern "C" fn mln_lang_stack_handler_for(mut ctx: *mut mln_lang_ctx_t) {
    let mut current_block: u64;
    let mut node: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
    let mut f: *mut mln_lang_for_t = (*node).data.f;
    if (*node).step() as libc::c_int == 0 as libc::c_int {
        (*node).set_step(1 as libc::c_int as mln_u32_t);
        if !((*f).init_exp).is_null() {
            node = ({
                let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
                if ((*ctx).run_stack_top).is_null() {
                    (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                    n = (*ctx).run_stack_top;
                } else if (((*ctx).run_stack_top)
                    .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                    < 1024 as libc::c_int as libc::c_long
                {
                    (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                    n = (*ctx).run_stack_top;
                }
                if !n.is_null() {
                    (*n).type_0 = M_LSNT_EXP;
                    (*n).pos = 0 as *mut libc::c_void;
                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    (*n).ret_var = (*n).ret_var2;
                    (*n).set_step(0 as libc::c_int as mln_u32_t);
                    (*n).set_call(0 as libc::c_int as mln_u32_t);
                    match M_LSNT_EXP as libc::c_int {
                        0 => {
                            (*n).data.stm = (*f).init_exp as *mut mln_lang_stm_t;
                        }
                        1 => {
                            (*n).data.funcdef = (*f).init_exp as *mut mln_lang_funcdef_t;
                        }
                        2 => {
                            (*n).data.set = (*f).init_exp as *mut mln_lang_set_t;
                        }
                        3 => {
                            (*n).data.set_stm = (*f).init_exp as *mut mln_lang_setstm_t;
                        }
                        4 => {
                            (*n).data.block = (*f).init_exp as *mut mln_lang_block_t;
                        }
                        5 => {
                            (*n).data.w = (*f).init_exp as *mut mln_lang_while_t;
                        }
                        6 => {
                            (*n).data.sw = (*f).init_exp as *mut mln_lang_switch_t;
                        }
                        7 => {
                            (*n)
                                .data
                                .sw_stm = (*f).init_exp as *mut mln_lang_switchstm_t;
                        }
                        8 => {
                            (*n).data.f = (*f).init_exp as *mut mln_lang_for_t;
                        }
                        9 => {
                            (*n).data.i = (*f).init_exp as *mut mln_lang_if_t;
                        }
                        10 => {
                            (*n).data.exp = (*f).init_exp;
                        }
                        11 => {
                            (*n).data.assign = (*f).init_exp as *mut mln_lang_assign_t;
                        }
                        12 => {
                            (*n)
                                .data
                                .logiclow = (*f).init_exp as *mut mln_lang_logiclow_t;
                        }
                        13 => {
                            (*n)
                                .data
                                .logichigh = (*f).init_exp as *mut mln_lang_logichigh_t;
                            (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                        }
                        14 => {
                            (*n)
                                .data
                                .relativelow = (*f).init_exp as *mut mln_lang_relativelow_t;
                            (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                        }
                        15 => {
                            (*n)
                                .data
                                .relativehigh = (*f).init_exp
                                as *mut mln_lang_relativehigh_t;
                            (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                        }
                        16 => {
                            (*n).data.move_0 = (*f).init_exp as *mut mln_lang_move_t;
                            (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                        }
                        17 => {
                            (*n).data.addsub = (*f).init_exp as *mut mln_lang_addsub_t;
                            (*n).pos = (*n).data.addsub as *mut libc::c_void;
                        }
                        18 => {
                            (*n).data.muldiv = (*f).init_exp as *mut mln_lang_muldiv_t;
                            (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                        }
                        19 => {
                            (*n).data.not = (*f).init_exp as *mut mln_lang_not_t;
                            (*n).pos = (*n).data.not as *mut libc::c_void;
                        }
                        20 => {
                            (*n).data.suffix = (*f).init_exp as *mut mln_lang_suffix_t;
                        }
                        21 => {
                            (*n).data.locate = (*f).init_exp as *mut mln_lang_locate_t;
                        }
                        22 => {
                            (*n).data.spec = (*f).init_exp as *mut mln_lang_spec_t;
                        }
                        23 => {
                            (*n).data.factor = (*f).init_exp as *mut mln_lang_factor_t;
                        }
                        _ => {
                            (*n)
                                .data
                                .elemlist = (*f).init_exp as *mut mln_lang_elemlist_t;
                        }
                    }
                }
                n
            });
            if node.is_null() {
                __mln_lang_errmsg(
                    ctx,
                    b"Stack is full.\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                );
                (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                return;
            }
            (mln_lang_stack_map[(*node).type_0 as usize])
                .expect("non-null function pointer")(ctx);
            return;
        } else {
            current_block = 16293943185965708741;
        }
    } else if (*node).step() as libc::c_int == 1 as libc::c_int {
        current_block = 16293943185965708741;
    } else if (*node).step() as libc::c_int == 2 as libc::c_int {
        current_block = 6531363840630089302;
    } else {
        (*node).set_step(1 as libc::c_int as mln_u32_t);
        if !((*f).mod_exp).is_null() {
            node = ({
                let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
                if ((*ctx).run_stack_top).is_null() {
                    (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                    n = (*ctx).run_stack_top;
                } else if (((*ctx).run_stack_top)
                    .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                    < 1024 as libc::c_int as libc::c_long
                {
                    (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                    n = (*ctx).run_stack_top;
                }
                if !n.is_null() {
                    (*n).type_0 = M_LSNT_EXP;
                    (*n).pos = 0 as *mut libc::c_void;
                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    (*n).ret_var = (*n).ret_var2;
                    (*n).set_step(0 as libc::c_int as mln_u32_t);
                    (*n).set_call(0 as libc::c_int as mln_u32_t);
                    match M_LSNT_EXP as libc::c_int {
                        0 => {
                            (*n).data.stm = (*f).mod_exp as *mut mln_lang_stm_t;
                        }
                        1 => {
                            (*n).data.funcdef = (*f).mod_exp as *mut mln_lang_funcdef_t;
                        }
                        2 => {
                            (*n).data.set = (*f).mod_exp as *mut mln_lang_set_t;
                        }
                        3 => {
                            (*n).data.set_stm = (*f).mod_exp as *mut mln_lang_setstm_t;
                        }
                        4 => {
                            (*n).data.block = (*f).mod_exp as *mut mln_lang_block_t;
                        }
                        5 => {
                            (*n).data.w = (*f).mod_exp as *mut mln_lang_while_t;
                        }
                        6 => {
                            (*n).data.sw = (*f).mod_exp as *mut mln_lang_switch_t;
                        }
                        7 => {
                            (*n).data.sw_stm = (*f).mod_exp as *mut mln_lang_switchstm_t;
                        }
                        8 => {
                            (*n).data.f = (*f).mod_exp as *mut mln_lang_for_t;
                        }
                        9 => {
                            (*n).data.i = (*f).mod_exp as *mut mln_lang_if_t;
                        }
                        10 => {
                            (*n).data.exp = (*f).mod_exp;
                        }
                        11 => {
                            (*n).data.assign = (*f).mod_exp as *mut mln_lang_assign_t;
                        }
                        12 => {
                            (*n)
                                .data
                                .logiclow = (*f).mod_exp as *mut mln_lang_logiclow_t;
                        }
                        13 => {
                            (*n)
                                .data
                                .logichigh = (*f).mod_exp as *mut mln_lang_logichigh_t;
                            (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                        }
                        14 => {
                            (*n)
                                .data
                                .relativelow = (*f).mod_exp as *mut mln_lang_relativelow_t;
                            (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                        }
                        15 => {
                            (*n)
                                .data
                                .relativehigh = (*f).mod_exp
                                as *mut mln_lang_relativehigh_t;
                            (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                        }
                        16 => {
                            (*n).data.move_0 = (*f).mod_exp as *mut mln_lang_move_t;
                            (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                        }
                        17 => {
                            (*n).data.addsub = (*f).mod_exp as *mut mln_lang_addsub_t;
                            (*n).pos = (*n).data.addsub as *mut libc::c_void;
                        }
                        18 => {
                            (*n).data.muldiv = (*f).mod_exp as *mut mln_lang_muldiv_t;
                            (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                        }
                        19 => {
                            (*n).data.not = (*f).mod_exp as *mut mln_lang_not_t;
                            (*n).pos = (*n).data.not as *mut libc::c_void;
                        }
                        20 => {
                            (*n).data.suffix = (*f).mod_exp as *mut mln_lang_suffix_t;
                        }
                        21 => {
                            (*n).data.locate = (*f).mod_exp as *mut mln_lang_locate_t;
                        }
                        22 => {
                            (*n).data.spec = (*f).mod_exp as *mut mln_lang_spec_t;
                        }
                        23 => {
                            (*n).data.factor = (*f).mod_exp as *mut mln_lang_factor_t;
                        }
                        _ => {
                            (*n)
                                .data
                                .elemlist = (*f).mod_exp as *mut mln_lang_elemlist_t;
                        }
                    }
                }
                n
            });
            if node.is_null() {
                __mln_lang_errmsg(
                    ctx,
                    b"Stack is full.\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                );
                (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                return;
            }
            (mln_lang_stack_map[(*node).type_0 as usize])
                .expect("non-null function pointer")(ctx);
            return;
        } else {
            current_block = 16293943185965708741;
        }
    }
    match current_block {
        16293943185965708741 => {
            (*node).set_step(2 as libc::c_int as mln_u32_t);
            if !((*f).condition).is_null() {
                node = ({
                    let mut n: *mut mln_lang_stack_node_t = 0
                        as *mut mln_lang_stack_node_t;
                    if ((*ctx).run_stack_top).is_null() {
                        (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                        n = (*ctx).run_stack_top;
                    } else if (((*ctx).run_stack_top)
                        .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                        < 1024 as libc::c_int as libc::c_long
                    {
                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                        n = (*ctx).run_stack_top;
                    }
                    if !n.is_null() {
                        (*n).type_0 = M_LSNT_EXP;
                        (*n).pos = 0 as *mut libc::c_void;
                        (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                        (*n).ret_var = (*n).ret_var2;
                        (*n).set_step(0 as libc::c_int as mln_u32_t);
                        (*n).set_call(0 as libc::c_int as mln_u32_t);
                        match M_LSNT_EXP as libc::c_int {
                            0 => {
                                (*n).data.stm = (*f).condition as *mut mln_lang_stm_t;
                            }
                            1 => {
                                (*n)
                                    .data
                                    .funcdef = (*f).condition as *mut mln_lang_funcdef_t;
                            }
                            2 => {
                                (*n).data.set = (*f).condition as *mut mln_lang_set_t;
                            }
                            3 => {
                                (*n)
                                    .data
                                    .set_stm = (*f).condition as *mut mln_lang_setstm_t;
                            }
                            4 => {
                                (*n).data.block = (*f).condition as *mut mln_lang_block_t;
                            }
                            5 => {
                                (*n).data.w = (*f).condition as *mut mln_lang_while_t;
                            }
                            6 => {
                                (*n).data.sw = (*f).condition as *mut mln_lang_switch_t;
                            }
                            7 => {
                                (*n)
                                    .data
                                    .sw_stm = (*f).condition as *mut mln_lang_switchstm_t;
                            }
                            8 => {
                                (*n).data.f = (*f).condition as *mut mln_lang_for_t;
                            }
                            9 => {
                                (*n).data.i = (*f).condition as *mut mln_lang_if_t;
                            }
                            10 => {
                                (*n).data.exp = (*f).condition;
                            }
                            11 => {
                                (*n).data.assign = (*f).condition as *mut mln_lang_assign_t;
                            }
                            12 => {
                                (*n)
                                    .data
                                    .logiclow = (*f).condition as *mut mln_lang_logiclow_t;
                            }
                            13 => {
                                (*n)
                                    .data
                                    .logichigh = (*f).condition as *mut mln_lang_logichigh_t;
                                (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                            }
                            14 => {
                                (*n)
                                    .data
                                    .relativelow = (*f).condition
                                    as *mut mln_lang_relativelow_t;
                                (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                            }
                            15 => {
                                (*n)
                                    .data
                                    .relativehigh = (*f).condition
                                    as *mut mln_lang_relativehigh_t;
                                (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                            }
                            16 => {
                                (*n).data.move_0 = (*f).condition as *mut mln_lang_move_t;
                                (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                            }
                            17 => {
                                (*n).data.addsub = (*f).condition as *mut mln_lang_addsub_t;
                                (*n).pos = (*n).data.addsub as *mut libc::c_void;
                            }
                            18 => {
                                (*n).data.muldiv = (*f).condition as *mut mln_lang_muldiv_t;
                                (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                            }
                            19 => {
                                (*n).data.not = (*f).condition as *mut mln_lang_not_t;
                                (*n).pos = (*n).data.not as *mut libc::c_void;
                            }
                            20 => {
                                (*n).data.suffix = (*f).condition as *mut mln_lang_suffix_t;
                            }
                            21 => {
                                (*n).data.locate = (*f).condition as *mut mln_lang_locate_t;
                            }
                            22 => {
                                (*n).data.spec = (*f).condition as *mut mln_lang_spec_t;
                            }
                            23 => {
                                (*n).data.factor = (*f).condition as *mut mln_lang_factor_t;
                            }
                            _ => {
                                (*n)
                                    .data
                                    .elemlist = (*f).condition as *mut mln_lang_elemlist_t;
                            }
                        }
                    }
                    n
                });
                if node.is_null() {
                    __mln_lang_errmsg(
                        ctx,
                        b"Stack is full.\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                    );
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                (mln_lang_stack_map[(*node).type_0 as usize])
                    .expect("non-null function pointer")(ctx);
                return;
            }
        }
        _ => {}
    }
    if ((*ctx).ret_var).is_null() || __mln_lang_condition_is_true((*ctx).ret_var) != 0 {
        (*node).set_step(3 as libc::c_int as mln_u32_t);
        node = ({
            let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
            if ((*ctx).run_stack_top).is_null() {
                (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                n = (*ctx).run_stack_top;
            } else if (((*ctx).run_stack_top)
                .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                < 1024 as libc::c_int as libc::c_long
            {
                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                n = (*ctx).run_stack_top;
            }
            if !n.is_null() {
                (*n).type_0 = M_LSNT_BLOCK;
                (*n).pos = 0 as *mut libc::c_void;
                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                (*n).ret_var = (*n).ret_var2;
                (*n).set_step(0 as libc::c_int as mln_u32_t);
                (*n).set_call(0 as libc::c_int as mln_u32_t);
                match M_LSNT_BLOCK as libc::c_int {
                    0 => {
                        (*n).data.stm = (*f).blockstm as *mut mln_lang_stm_t;
                    }
                    1 => {
                        (*n).data.funcdef = (*f).blockstm as *mut mln_lang_funcdef_t;
                    }
                    2 => {
                        (*n).data.set = (*f).blockstm as *mut mln_lang_set_t;
                    }
                    3 => {
                        (*n).data.set_stm = (*f).blockstm as *mut mln_lang_setstm_t;
                    }
                    4 => {
                        (*n).data.block = (*f).blockstm;
                    }
                    5 => {
                        (*n).data.w = (*f).blockstm as *mut mln_lang_while_t;
                    }
                    6 => {
                        (*n).data.sw = (*f).blockstm as *mut mln_lang_switch_t;
                    }
                    7 => {
                        (*n).data.sw_stm = (*f).blockstm as *mut mln_lang_switchstm_t;
                    }
                    8 => {
                        (*n).data.f = (*f).blockstm as *mut mln_lang_for_t;
                    }
                    9 => {
                        (*n).data.i = (*f).blockstm as *mut mln_lang_if_t;
                    }
                    10 => {
                        (*n).data.exp = (*f).blockstm as *mut mln_lang_exp_t;
                    }
                    11 => {
                        (*n).data.assign = (*f).blockstm as *mut mln_lang_assign_t;
                    }
                    12 => {
                        (*n).data.logiclow = (*f).blockstm as *mut mln_lang_logiclow_t;
                    }
                    13 => {
                        (*n).data.logichigh = (*f).blockstm as *mut mln_lang_logichigh_t;
                        (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                    }
                    14 => {
                        (*n)
                            .data
                            .relativelow = (*f).blockstm as *mut mln_lang_relativelow_t;
                        (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                    }
                    15 => {
                        (*n)
                            .data
                            .relativehigh = (*f).blockstm
                            as *mut mln_lang_relativehigh_t;
                        (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                    }
                    16 => {
                        (*n).data.move_0 = (*f).blockstm as *mut mln_lang_move_t;
                        (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                    }
                    17 => {
                        (*n).data.addsub = (*f).blockstm as *mut mln_lang_addsub_t;
                        (*n).pos = (*n).data.addsub as *mut libc::c_void;
                    }
                    18 => {
                        (*n).data.muldiv = (*f).blockstm as *mut mln_lang_muldiv_t;
                        (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                    }
                    19 => {
                        (*n).data.not = (*f).blockstm as *mut mln_lang_not_t;
                        (*n).pos = (*n).data.not as *mut libc::c_void;
                    }
                    20 => {
                        (*n).data.suffix = (*f).blockstm as *mut mln_lang_suffix_t;
                    }
                    21 => {
                        (*n).data.locate = (*f).blockstm as *mut mln_lang_locate_t;
                    }
                    22 => {
                        (*n).data.spec = (*f).blockstm as *mut mln_lang_spec_t;
                    }
                    23 => {
                        (*n).data.factor = (*f).blockstm as *mut mln_lang_factor_t;
                    }
                    _ => {
                        (*n).data.elemlist = (*f).blockstm as *mut mln_lang_elemlist_t;
                    }
                }
            }
            n
        });
        if node.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"Stack is full.\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
            return;
        }
        (mln_lang_stack_map[(*node).type_0 as usize])
            .expect("non-null function pointer")(ctx);
        return;
    } else {
        let mut n: *mut mln_lang_stack_node_t = ({
            let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
            if !n_0.is_null()
                && {
                    (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                    (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                }
            {
                (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
            }
            n_0
        });
        if !n.is_null() {
            if !((*n).ret_var).is_null() {
                __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                (*n).ret_var = 0 as *mut mln_lang_var_t;
            }
            if !((*n).ret_var2).is_null() {
                __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
            }
        }
    };
}
unsafe extern "C" fn mln_lang_stack_handler_if(mut ctx: *mut mln_lang_ctx_t) {
    let mut node: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
    let mut i: *mut mln_lang_if_t = (*node).data.i;
    if (*node).step() as libc::c_int == 0 as libc::c_int {
        (*node).set_step(1 as libc::c_int as mln_u32_t);
        mln_lang_ctx_reset_ret_var(ctx);
        if !((*i).condition).is_null() {
            node = ({
                let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
                if ((*ctx).run_stack_top).is_null() {
                    (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                    n = (*ctx).run_stack_top;
                } else if (((*ctx).run_stack_top)
                    .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                    < 1024 as libc::c_int as libc::c_long
                {
                    (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                    n = (*ctx).run_stack_top;
                }
                if !n.is_null() {
                    (*n).type_0 = M_LSNT_EXP;
                    (*n).pos = 0 as *mut libc::c_void;
                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    (*n).ret_var = (*n).ret_var2;
                    (*n).set_step(0 as libc::c_int as mln_u32_t);
                    (*n).set_call(0 as libc::c_int as mln_u32_t);
                    match M_LSNT_EXP as libc::c_int {
                        0 => {
                            (*n).data.stm = (*i).condition as *mut mln_lang_stm_t;
                        }
                        1 => {
                            (*n)
                                .data
                                .funcdef = (*i).condition as *mut mln_lang_funcdef_t;
                        }
                        2 => {
                            (*n).data.set = (*i).condition as *mut mln_lang_set_t;
                        }
                        3 => {
                            (*n).data.set_stm = (*i).condition as *mut mln_lang_setstm_t;
                        }
                        4 => {
                            (*n).data.block = (*i).condition as *mut mln_lang_block_t;
                        }
                        5 => {
                            (*n).data.w = (*i).condition as *mut mln_lang_while_t;
                        }
                        6 => {
                            (*n).data.sw = (*i).condition as *mut mln_lang_switch_t;
                        }
                        7 => {
                            (*n)
                                .data
                                .sw_stm = (*i).condition as *mut mln_lang_switchstm_t;
                        }
                        8 => {
                            (*n).data.f = (*i).condition as *mut mln_lang_for_t;
                        }
                        9 => {
                            (*n).data.i = (*i).condition as *mut mln_lang_if_t;
                        }
                        10 => {
                            (*n).data.exp = (*i).condition;
                        }
                        11 => {
                            (*n).data.assign = (*i).condition as *mut mln_lang_assign_t;
                        }
                        12 => {
                            (*n)
                                .data
                                .logiclow = (*i).condition as *mut mln_lang_logiclow_t;
                        }
                        13 => {
                            (*n)
                                .data
                                .logichigh = (*i).condition as *mut mln_lang_logichigh_t;
                            (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                        }
                        14 => {
                            (*n)
                                .data
                                .relativelow = (*i).condition
                                as *mut mln_lang_relativelow_t;
                            (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                        }
                        15 => {
                            (*n)
                                .data
                                .relativehigh = (*i).condition
                                as *mut mln_lang_relativehigh_t;
                            (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                        }
                        16 => {
                            (*n).data.move_0 = (*i).condition as *mut mln_lang_move_t;
                            (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                        }
                        17 => {
                            (*n).data.addsub = (*i).condition as *mut mln_lang_addsub_t;
                            (*n).pos = (*n).data.addsub as *mut libc::c_void;
                        }
                        18 => {
                            (*n).data.muldiv = (*i).condition as *mut mln_lang_muldiv_t;
                            (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                        }
                        19 => {
                            (*n).data.not = (*i).condition as *mut mln_lang_not_t;
                            (*n).pos = (*n).data.not as *mut libc::c_void;
                        }
                        20 => {
                            (*n).data.suffix = (*i).condition as *mut mln_lang_suffix_t;
                        }
                        21 => {
                            (*n).data.locate = (*i).condition as *mut mln_lang_locate_t;
                        }
                        22 => {
                            (*n).data.spec = (*i).condition as *mut mln_lang_spec_t;
                        }
                        23 => {
                            (*n).data.factor = (*i).condition as *mut mln_lang_factor_t;
                        }
                        _ => {
                            (*n)
                                .data
                                .elemlist = (*i).condition as *mut mln_lang_elemlist_t;
                        }
                    }
                }
                n
            });
            if node.is_null() {
                __mln_lang_errmsg(
                    ctx,
                    b"Stack is full.\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                );
                (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                return;
            }
            (mln_lang_stack_map[(*node).type_0 as usize])
                .expect("non-null function pointer")(ctx);
            return;
        }
    }
    let mut n: *mut mln_lang_stack_node_t = ({
        let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
        if !n_0.is_null()
            && {
                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
            }
        {
            (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
        }
        n_0
    });
    if !n.is_null() {
        if !((*n).ret_var).is_null() {
            __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
            (*n).ret_var = 0 as *mut mln_lang_var_t;
        }
        if !((*n).ret_var2).is_null() {
            __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
            (*n).ret_var2 = 0 as *mut mln_lang_var_t;
        }
    }
    if __mln_lang_condition_is_true((*ctx).ret_var) == 0 {
        if !((*i).elsestm).is_null() {
            node = ({
                let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
                if ((*ctx).run_stack_top).is_null() {
                    (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                    n = (*ctx).run_stack_top;
                } else if (((*ctx).run_stack_top)
                    .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                    < 1024 as libc::c_int as libc::c_long
                {
                    (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                    n = (*ctx).run_stack_top;
                }
                if !n.is_null() {
                    (*n).type_0 = M_LSNT_BLOCK;
                    (*n).pos = 0 as *mut libc::c_void;
                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    (*n).ret_var = (*n).ret_var2;
                    (*n).set_step(0 as libc::c_int as mln_u32_t);
                    (*n).set_call(0 as libc::c_int as mln_u32_t);
                    match M_LSNT_BLOCK as libc::c_int {
                        0 => {
                            (*n).data.stm = (*i).elsestm as *mut mln_lang_stm_t;
                        }
                        1 => {
                            (*n).data.funcdef = (*i).elsestm as *mut mln_lang_funcdef_t;
                        }
                        2 => {
                            (*n).data.set = (*i).elsestm as *mut mln_lang_set_t;
                        }
                        3 => {
                            (*n).data.set_stm = (*i).elsestm as *mut mln_lang_setstm_t;
                        }
                        4 => {
                            (*n).data.block = (*i).elsestm;
                        }
                        5 => {
                            (*n).data.w = (*i).elsestm as *mut mln_lang_while_t;
                        }
                        6 => {
                            (*n).data.sw = (*i).elsestm as *mut mln_lang_switch_t;
                        }
                        7 => {
                            (*n).data.sw_stm = (*i).elsestm as *mut mln_lang_switchstm_t;
                        }
                        8 => {
                            (*n).data.f = (*i).elsestm as *mut mln_lang_for_t;
                        }
                        9 => {
                            (*n).data.i = (*i).elsestm as *mut mln_lang_if_t;
                        }
                        10 => {
                            (*n).data.exp = (*i).elsestm as *mut mln_lang_exp_t;
                        }
                        11 => {
                            (*n).data.assign = (*i).elsestm as *mut mln_lang_assign_t;
                        }
                        12 => {
                            (*n)
                                .data
                                .logiclow = (*i).elsestm as *mut mln_lang_logiclow_t;
                        }
                        13 => {
                            (*n)
                                .data
                                .logichigh = (*i).elsestm as *mut mln_lang_logichigh_t;
                            (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                        }
                        14 => {
                            (*n)
                                .data
                                .relativelow = (*i).elsestm as *mut mln_lang_relativelow_t;
                            (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                        }
                        15 => {
                            (*n)
                                .data
                                .relativehigh = (*i).elsestm
                                as *mut mln_lang_relativehigh_t;
                            (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                        }
                        16 => {
                            (*n).data.move_0 = (*i).elsestm as *mut mln_lang_move_t;
                            (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                        }
                        17 => {
                            (*n).data.addsub = (*i).elsestm as *mut mln_lang_addsub_t;
                            (*n).pos = (*n).data.addsub as *mut libc::c_void;
                        }
                        18 => {
                            (*n).data.muldiv = (*i).elsestm as *mut mln_lang_muldiv_t;
                            (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                        }
                        19 => {
                            (*n).data.not = (*i).elsestm as *mut mln_lang_not_t;
                            (*n).pos = (*n).data.not as *mut libc::c_void;
                        }
                        20 => {
                            (*n).data.suffix = (*i).elsestm as *mut mln_lang_suffix_t;
                        }
                        21 => {
                            (*n).data.locate = (*i).elsestm as *mut mln_lang_locate_t;
                        }
                        22 => {
                            (*n).data.spec = (*i).elsestm as *mut mln_lang_spec_t;
                        }
                        23 => {
                            (*n).data.factor = (*i).elsestm as *mut mln_lang_factor_t;
                        }
                        _ => {
                            (*n)
                                .data
                                .elemlist = (*i).elsestm as *mut mln_lang_elemlist_t;
                        }
                    }
                }
                n
            });
            if node.is_null() {
                __mln_lang_errmsg(
                    ctx,
                    b"Stack is full.\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                );
                (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                return;
            }
        } else {
            node = 0 as *mut mln_lang_stack_node_t;
        }
    } else {
        node = ({
            let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
            if ((*ctx).run_stack_top).is_null() {
                (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                n = (*ctx).run_stack_top;
            } else if (((*ctx).run_stack_top)
                .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                < 1024 as libc::c_int as libc::c_long
            {
                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                n = (*ctx).run_stack_top;
            }
            if !n.is_null() {
                (*n).type_0 = M_LSNT_BLOCK;
                (*n).pos = 0 as *mut libc::c_void;
                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                (*n).ret_var = (*n).ret_var2;
                (*n).set_step(0 as libc::c_int as mln_u32_t);
                (*n).set_call(0 as libc::c_int as mln_u32_t);
                match M_LSNT_BLOCK as libc::c_int {
                    0 => {
                        (*n).data.stm = (*i).blockstm as *mut mln_lang_stm_t;
                    }
                    1 => {
                        (*n).data.funcdef = (*i).blockstm as *mut mln_lang_funcdef_t;
                    }
                    2 => {
                        (*n).data.set = (*i).blockstm as *mut mln_lang_set_t;
                    }
                    3 => {
                        (*n).data.set_stm = (*i).blockstm as *mut mln_lang_setstm_t;
                    }
                    4 => {
                        (*n).data.block = (*i).blockstm;
                    }
                    5 => {
                        (*n).data.w = (*i).blockstm as *mut mln_lang_while_t;
                    }
                    6 => {
                        (*n).data.sw = (*i).blockstm as *mut mln_lang_switch_t;
                    }
                    7 => {
                        (*n).data.sw_stm = (*i).blockstm as *mut mln_lang_switchstm_t;
                    }
                    8 => {
                        (*n).data.f = (*i).blockstm as *mut mln_lang_for_t;
                    }
                    9 => {
                        (*n).data.i = (*i).blockstm as *mut mln_lang_if_t;
                    }
                    10 => {
                        (*n).data.exp = (*i).blockstm as *mut mln_lang_exp_t;
                    }
                    11 => {
                        (*n).data.assign = (*i).blockstm as *mut mln_lang_assign_t;
                    }
                    12 => {
                        (*n).data.logiclow = (*i).blockstm as *mut mln_lang_logiclow_t;
                    }
                    13 => {
                        (*n).data.logichigh = (*i).blockstm as *mut mln_lang_logichigh_t;
                        (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                    }
                    14 => {
                        (*n)
                            .data
                            .relativelow = (*i).blockstm as *mut mln_lang_relativelow_t;
                        (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                    }
                    15 => {
                        (*n)
                            .data
                            .relativehigh = (*i).blockstm
                            as *mut mln_lang_relativehigh_t;
                        (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                    }
                    16 => {
                        (*n).data.move_0 = (*i).blockstm as *mut mln_lang_move_t;
                        (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                    }
                    17 => {
                        (*n).data.addsub = (*i).blockstm as *mut mln_lang_addsub_t;
                        (*n).pos = (*n).data.addsub as *mut libc::c_void;
                    }
                    18 => {
                        (*n).data.muldiv = (*i).blockstm as *mut mln_lang_muldiv_t;
                        (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                    }
                    19 => {
                        (*n).data.not = (*i).blockstm as *mut mln_lang_not_t;
                        (*n).pos = (*n).data.not as *mut libc::c_void;
                    }
                    20 => {
                        (*n).data.suffix = (*i).blockstm as *mut mln_lang_suffix_t;
                    }
                    21 => {
                        (*n).data.locate = (*i).blockstm as *mut mln_lang_locate_t;
                    }
                    22 => {
                        (*n).data.spec = (*i).blockstm as *mut mln_lang_spec_t;
                    }
                    23 => {
                        (*n).data.factor = (*i).blockstm as *mut mln_lang_factor_t;
                    }
                    _ => {
                        (*n).data.elemlist = (*i).blockstm as *mut mln_lang_elemlist_t;
                    }
                }
            }
            n
        });
        if node.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"Stack is full.\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
            return;
        }
    }
    if !node.is_null() {
        (mln_lang_stack_map[(*node).type_0 as usize])
            .expect("non-null function pointer")(ctx);
        return;
    }
    mln_lang_ctx_reset_ret_var(ctx);
}
#[inline]
unsafe extern "C" fn mln_lang_generate_jump_ptr(
    mut ptr: *mut libc::c_void,
    mut type_0: mln_lang_stack_node_type_t,
) {
    match type_0 as libc::c_uint {
        0 => {
            let mut stm: *mut mln_lang_stm_t = ptr as *mut mln_lang_stm_t;
            match (*stm).type_0 as libc::c_uint {
                0 => {
                    if (*(*stm).data.block).type_0 as libc::c_uint
                        == M_BLOCK_EXP as libc::c_int as libc::c_uint
                    {
                        if ((*(*stm).data.block).jump).is_null() {
                            mln_lang_generate_jump_ptr(
                                (*stm).data.block as *mut libc::c_void,
                                M_LSNT_BLOCK,
                            );
                        }
                        (*stm).jump = (*(*stm).data.block).jump;
                        (*stm).jump_type = (*(*stm).data.block).jump_type;
                    } else {
                        (*stm).jump = (*stm).data.block as *mut libc::c_void;
                        (*stm).jump_type = M_LSNT_BLOCK as libc::c_int;
                    }
                }
                1 => {
                    (*stm).jump = (*stm).data.func as *mut libc::c_void;
                    (*stm).jump_type = M_LSNT_FUNCDEF as libc::c_int;
                }
                2 => {
                    (*stm).jump = (*stm).data.setdef as *mut libc::c_void;
                    (*stm).jump_type = M_LSNT_SET as libc::c_int;
                }
                3 => {}
                4 => {
                    (*stm).jump = (*stm).data.sw as *mut libc::c_void;
                    (*stm).jump_type = M_LSNT_SWITCH as libc::c_int;
                }
                5 => {
                    (*stm).jump = (*stm).data.w as *mut libc::c_void;
                    (*stm).jump_type = M_LSNT_WHILE as libc::c_int;
                }
                _ => {
                    (*stm).jump = (*stm).data.f as *mut libc::c_void;
                    (*stm).jump_type = M_LSNT_FOR as libc::c_int;
                }
            }
        }
        4 => {
            let mut block: *mut mln_lang_block_t = ptr as *mut mln_lang_block_t;
            if ((*(*block).data.exp).jump).is_null() {
                mln_lang_generate_jump_ptr(
                    (*block).data.exp as *mut libc::c_void,
                    M_LSNT_EXP,
                );
            }
            (*block).jump = (*(*block).data.exp).jump;
            (*block).jump_type = (*(*block).data.exp).type_0;
        }
        10 => {
            let mut exp: *mut mln_lang_exp_t = ptr as *mut mln_lang_exp_t;
            if (*(*exp).assign).op as libc::c_uint
                != M_ASSIGN_NONE as libc::c_int as libc::c_uint
            {
                (*exp).jump = (*exp).assign as *mut libc::c_void;
                (*exp).type_0 = M_LSNT_ASSIGN as libc::c_int;
            } else {
                if ((*(*exp).assign).jump).is_null() {
                    mln_lang_generate_jump_ptr(
                        (*exp).assign as *mut libc::c_void,
                        M_LSNT_ASSIGN,
                    );
                }
                (*exp).jump = (*(*exp).assign).jump;
                (*exp).type_0 = (*(*exp).assign).type_0;
            }
        }
        11 => {
            let mut a: *mut mln_lang_assign_t = ptr as *mut mln_lang_assign_t;
            if (*(*a).left).op as libc::c_uint
                != M_LOGICLOW_NONE as libc::c_int as libc::c_uint
            {
                (*a).jump = (*a).left as *mut libc::c_void;
                (*a).type_0 = M_LSNT_LOGICLOW as libc::c_int;
            } else {
                if ((*(*a).left).jump).is_null() {
                    mln_lang_generate_jump_ptr(
                        (*a).left as *mut libc::c_void,
                        M_LSNT_LOGICLOW,
                    );
                }
                (*a).jump = (*(*a).left).jump;
                (*a).type_0 = (*(*a).left).type_0;
            }
        }
        12 => {
            let mut l: *mut mln_lang_logiclow_t = ptr as *mut mln_lang_logiclow_t;
            if (*(*l).left).op as libc::c_uint
                != M_LOGICHIGH_NONE as libc::c_int as libc::c_uint
            {
                (*l).jump = (*l).left as *mut libc::c_void;
                (*l).type_0 = M_LSNT_LOGICHIGH as libc::c_int;
            } else {
                if ((*(*l).left).jump).is_null() {
                    mln_lang_generate_jump_ptr(
                        (*l).left as *mut libc::c_void,
                        M_LSNT_LOGICHIGH,
                    );
                }
                (*l).jump = (*(*l).left).jump;
                (*l).type_0 = (*(*l).left).type_0;
            }
        }
        13 => {
            let mut l_0: *mut mln_lang_logichigh_t = ptr as *mut mln_lang_logichigh_t;
            if (*(*l_0).left).op as libc::c_uint
                != M_RELATIVELOW_NONE as libc::c_int as libc::c_uint
            {
                (*l_0).jump = (*l_0).left as *mut libc::c_void;
                (*l_0).type_0 = M_LSNT_RELATIVELOW as libc::c_int;
            } else {
                if ((*(*l_0).left).jump).is_null() {
                    mln_lang_generate_jump_ptr(
                        (*l_0).left as *mut libc::c_void,
                        M_LSNT_RELATIVELOW,
                    );
                }
                (*l_0).jump = (*(*l_0).left).jump;
                (*l_0).type_0 = (*(*l_0).left).type_0;
            }
        }
        14 => {
            let mut r: *mut mln_lang_relativelow_t = ptr as *mut mln_lang_relativelow_t;
            if (*(*r).left).op as libc::c_uint
                != M_RELATIVEHIGH_NONE as libc::c_int as libc::c_uint
            {
                (*r).jump = (*r).left as *mut libc::c_void;
                (*r).type_0 = M_LSNT_RELATIVEHIGH as libc::c_int;
            } else {
                if ((*(*r).left).jump).is_null() {
                    mln_lang_generate_jump_ptr(
                        (*r).left as *mut libc::c_void,
                        M_LSNT_RELATIVEHIGH,
                    );
                }
                (*r).jump = (*(*r).left).jump;
                (*r).type_0 = (*(*r).left).type_0;
            }
        }
        15 => {
            let mut r_0: *mut mln_lang_relativehigh_t = ptr
                as *mut mln_lang_relativehigh_t;
            if (*(*r_0).left).op as libc::c_uint
                != M_MOVE_NONE as libc::c_int as libc::c_uint
            {
                (*r_0).jump = (*r_0).left as *mut libc::c_void;
                (*r_0).type_0 = M_LSNT_MOVE as libc::c_int;
            } else {
                if ((*(*r_0).left).jump).is_null() {
                    mln_lang_generate_jump_ptr(
                        (*r_0).left as *mut libc::c_void,
                        M_LSNT_MOVE,
                    );
                }
                (*r_0).jump = (*(*r_0).left).jump;
                (*r_0).type_0 = (*(*r_0).left).type_0;
            }
        }
        16 => {
            let mut m: *mut mln_lang_move_t = ptr as *mut mln_lang_move_t;
            if (*(*m).left).op as libc::c_uint
                != M_ADDSUB_NONE as libc::c_int as libc::c_uint
            {
                (*m).jump = (*m).left as *mut libc::c_void;
                (*m).type_0 = M_LSNT_ADDSUB as libc::c_int;
            } else {
                if ((*(*m).left).jump).is_null() {
                    mln_lang_generate_jump_ptr(
                        (*m).left as *mut libc::c_void,
                        M_LSNT_ADDSUB,
                    );
                }
                (*m).jump = (*(*m).left).jump;
                (*m).type_0 = (*(*m).left).type_0;
            }
        }
        17 => {
            let mut a_0: *mut mln_lang_addsub_t = ptr as *mut mln_lang_addsub_t;
            if (*(*a_0).left).op as libc::c_uint
                != M_MULDIV_NONE as libc::c_int as libc::c_uint
            {
                (*a_0).jump = (*a_0).left as *mut libc::c_void;
                (*a_0).type_0 = M_LSNT_MULDIV as libc::c_int;
            } else {
                if ((*(*a_0).left).jump).is_null() {
                    mln_lang_generate_jump_ptr(
                        (*a_0).left as *mut libc::c_void,
                        M_LSNT_MULDIV,
                    );
                }
                (*a_0).jump = (*(*a_0).left).jump;
                (*a_0).type_0 = (*(*a_0).left).type_0;
            }
        }
        18 => {
            let mut m_0: *mut mln_lang_muldiv_t = ptr as *mut mln_lang_muldiv_t;
            if (*(*m_0).left).op as libc::c_uint
                == M_NOT_NONE as libc::c_int as libc::c_uint
            {
                if ((*(*m_0).left).jump).is_null() {
                    mln_lang_generate_jump_ptr(
                        (*m_0).left as *mut libc::c_void,
                        M_LSNT_NOT,
                    );
                }
                (*m_0).jump = (*(*m_0).left).jump;
                (*m_0).type_0 = (*(*m_0).left).type_0;
            } else {
                (*m_0).jump = (*m_0).left as *mut libc::c_void;
                (*m_0).type_0 = M_LSNT_NOT as libc::c_int;
            }
        }
        19 => {
            let mut n: *mut mln_lang_not_t = ptr as *mut mln_lang_not_t;
            if (*n).op as libc::c_uint != M_NOT_NONE as libc::c_int as libc::c_uint {
                (*n).jump = (*n).right.not as *mut libc::c_void;
                (*n).type_0 = M_LSNT_NOT as libc::c_int;
            } else if (*(*n).right.suffix).op as libc::c_uint
                != M_SUFFIX_NONE as libc::c_int as libc::c_uint
            {
                (*n).jump = (*n).right.suffix as *mut libc::c_void;
                (*n).type_0 = M_LSNT_SUFFIX as libc::c_int;
            } else {
                if ((*(*n).right.suffix).jump).is_null() {
                    mln_lang_generate_jump_ptr(
                        (*n).right.suffix as *mut libc::c_void,
                        M_LSNT_SUFFIX,
                    );
                }
                (*n).jump = (*(*n).right.suffix).jump;
                (*n).type_0 = (*(*n).right.suffix).type_0;
            }
        }
        20 => {
            let mut s: *mut mln_lang_suffix_t = ptr as *mut mln_lang_suffix_t;
            if (*(*s).left).op as libc::c_uint
                != M_LOCATE_NONE as libc::c_int as libc::c_uint
            {
                (*s).jump = (*s).left as *mut libc::c_void;
                (*s).type_0 = M_LSNT_LOCATE as libc::c_int;
            } else {
                if ((*(*s).left).jump).is_null() {
                    mln_lang_generate_jump_ptr(
                        (*s).left as *mut libc::c_void,
                        M_LSNT_LOCATE,
                    );
                }
                (*s).jump = (*(*s).left).jump;
                (*s).type_0 = (*(*s).left).type_0;
            }
        }
        21 => {
            let mut l_1: *mut mln_lang_locate_t = ptr as *mut mln_lang_locate_t;
            if (*(*l_1).left).op as libc::c_uint
                != M_SPEC_FACTOR as libc::c_int as libc::c_uint
            {
                (*l_1).jump = (*l_1).left as *mut libc::c_void;
                (*l_1).type_0 = M_LSNT_SPEC as libc::c_int;
            } else {
                (*l_1).jump = (*(*l_1).left).data.factor as *mut libc::c_void;
                (*l_1).type_0 = M_LSNT_FACTOR as libc::c_int;
            }
        }
        _ => {}
    };
}
unsafe extern "C" fn mln_lang_stack_handler_exp(mut ctx: *mut mln_lang_ctx_t) {
    let mut node: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
    let mut exp: *mut mln_lang_exp_t = (*node).data.exp;
    if (*node).step() as libc::c_int == 0 as libc::c_int {
        (*node).set_step(1 as libc::c_int as mln_u32_t);
    } else if !((*exp).next).is_null() {
        (*node).data.exp = (*exp).next;
        exp = (*exp).next;
        (*node).set_step(1 as libc::c_int as mln_u32_t);
    } else {
        let mut n: *mut mln_lang_stack_node_t = ({
            let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
            if !n_0.is_null()
                && {
                    (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                    (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                }
            {
                (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
            }
            n_0
        });
        if !n.is_null() {
            if !((*n).ret_var).is_null() {
                __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                (*n).ret_var = 0 as *mut mln_lang_var_t;
            }
            if !((*n).ret_var2).is_null() {
                __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
            }
        }
        while !((*ctx).run_stack_top).is_null()
            && (*(*ctx).run_stack_top).step() as libc::c_int == -(1 as libc::c_int)
        {
            let mut n: *mut mln_lang_stack_node_t = ({
                let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                if !n_0.is_null()
                    && {
                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                        (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                    }
                {
                    (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                }
                n_0
            });
            if !n.is_null() {
                if !((*n).ret_var).is_null() {
                    __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                    (*n).ret_var = 0 as *mut mln_lang_var_t;
                }
                if !((*n).ret_var2).is_null() {
                    __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                }
            }
        }
        return;
    }
    mln_lang_ctx_reset_ret_var(ctx);
    if ((*exp).jump).is_null() {
        mln_lang_generate_jump_ptr(exp as *mut libc::c_void, M_LSNT_EXP);
    }
    if ((*exp).next).is_null() {
        if (*exp).type_0 == M_LSNT_FACTOR as libc::c_int {
            let mut n: *mut mln_lang_stack_node_t = ({
                let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                if !n_0.is_null()
                    && {
                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                        (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                    }
                {
                    (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                }
                n_0
            });
            if !n.is_null() {
                if !((*n).ret_var).is_null() {
                    __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                    (*n).ret_var = 0 as *mut mln_lang_var_t;
                }
                if !((*n).ret_var2).is_null() {
                    __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                }
            }
        } else {
            (*node).set_step(-(1 as libc::c_int) as mln_u32_t);
        }
    }
    node = ({
        let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
        if ((*ctx).run_stack_top).is_null() {
            (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
            n = (*ctx).run_stack_top;
        } else if (((*ctx).run_stack_top).offset_from(((*ctx).run_stack).as_mut_ptr())
            as libc::c_long) < 1024 as libc::c_int as libc::c_long
        {
            (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
            n = (*ctx).run_stack_top;
        }
        if !n.is_null() {
            (*n).type_0 = (*exp).type_0 as mln_lang_stack_node_type_t;
            (*n).pos = 0 as *mut libc::c_void;
            (*n).ret_var2 = 0 as *mut mln_lang_var_t;
            (*n).ret_var = (*n).ret_var2;
            (*n).set_step(0 as libc::c_int as mln_u32_t);
            (*n).set_call(0 as libc::c_int as mln_u32_t);
            match (*exp).type_0 as mln_lang_stack_node_type_t as libc::c_uint {
                0 => {
                    (*n).data.stm = (*exp).jump as *mut mln_lang_stm_t;
                }
                1 => {
                    (*n).data.funcdef = (*exp).jump as *mut mln_lang_funcdef_t;
                }
                2 => {
                    (*n).data.set = (*exp).jump as *mut mln_lang_set_t;
                }
                3 => {
                    (*n).data.set_stm = (*exp).jump as *mut mln_lang_setstm_t;
                }
                4 => {
                    (*n).data.block = (*exp).jump as *mut mln_lang_block_t;
                }
                5 => {
                    (*n).data.w = (*exp).jump as *mut mln_lang_while_t;
                }
                6 => {
                    (*n).data.sw = (*exp).jump as *mut mln_lang_switch_t;
                }
                7 => {
                    (*n).data.sw_stm = (*exp).jump as *mut mln_lang_switchstm_t;
                }
                8 => {
                    (*n).data.f = (*exp).jump as *mut mln_lang_for_t;
                }
                9 => {
                    (*n).data.i = (*exp).jump as *mut mln_lang_if_t;
                }
                10 => {
                    (*n).data.exp = (*exp).jump as *mut mln_lang_exp_t;
                }
                11 => {
                    (*n).data.assign = (*exp).jump as *mut mln_lang_assign_t;
                }
                12 => {
                    (*n).data.logiclow = (*exp).jump as *mut mln_lang_logiclow_t;
                }
                13 => {
                    (*n).data.logichigh = (*exp).jump as *mut mln_lang_logichigh_t;
                    (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                }
                14 => {
                    (*n).data.relativelow = (*exp).jump as *mut mln_lang_relativelow_t;
                    (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                }
                15 => {
                    (*n).data.relativehigh = (*exp).jump as *mut mln_lang_relativehigh_t;
                    (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                }
                16 => {
                    (*n).data.move_0 = (*exp).jump as *mut mln_lang_move_t;
                    (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                }
                17 => {
                    (*n).data.addsub = (*exp).jump as *mut mln_lang_addsub_t;
                    (*n).pos = (*n).data.addsub as *mut libc::c_void;
                }
                18 => {
                    (*n).data.muldiv = (*exp).jump as *mut mln_lang_muldiv_t;
                    (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                }
                19 => {
                    (*n).data.not = (*exp).jump as *mut mln_lang_not_t;
                    (*n).pos = (*n).data.not as *mut libc::c_void;
                }
                20 => {
                    (*n).data.suffix = (*exp).jump as *mut mln_lang_suffix_t;
                }
                21 => {
                    (*n).data.locate = (*exp).jump as *mut mln_lang_locate_t;
                }
                22 => {
                    (*n).data.spec = (*exp).jump as *mut mln_lang_spec_t;
                }
                23 => {
                    (*n).data.factor = (*exp).jump as *mut mln_lang_factor_t;
                }
                _ => {
                    (*n).data.elemlist = (*exp).jump as *mut mln_lang_elemlist_t;
                }
            }
        }
        n
    });
    if node.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"Stack is full.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
        return;
    }
    (mln_lang_stack_map[(*node).type_0 as usize])
        .expect("non-null function pointer")(ctx);
    return;
}
unsafe extern "C" fn mln_lang_stack_handler_assign(mut ctx: *mut mln_lang_ctx_t) {
    let mut handler: mln_lang_op = None;
    let mut method: *mut mln_lang_method_t = 0 as *mut mln_lang_method_t;
    let mut current_block: u64;
    let mut res: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut node: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
    let mut assign: *mut mln_lang_assign_t = (*node).data.assign;
    if (*node).step() as libc::c_int == 0 as libc::c_int {
        mln_lang_ctx_reset_ret_var(ctx);
        if (*assign).op as libc::c_uint == M_ASSIGN_NONE as libc::c_int as libc::c_uint {
            (*node).set_step(-(1 as libc::c_int) as mln_u32_t);
        } else {
            (*node).set_step(1 as libc::c_int as mln_u32_t);
        }
        if ((*assign).jump).is_null() {
            mln_lang_generate_jump_ptr(assign as *mut libc::c_void, M_LSNT_ASSIGN);
        }
        if (*assign).type_0 == M_LSNT_FACTOR as libc::c_int
            && (*assign).op as libc::c_uint
                == M_ASSIGN_NONE as libc::c_int as libc::c_uint
        {
            let mut n: *mut mln_lang_stack_node_t = ({
                let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                if !n_0.is_null()
                    && {
                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                        (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                    }
                {
                    (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                }
                n_0
            });
            if !n.is_null() {
                if !((*n).ret_var).is_null() {
                    __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                    (*n).ret_var = 0 as *mut mln_lang_var_t;
                }
                if !((*n).ret_var2).is_null() {
                    __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                }
            }
            while !((*ctx).run_stack_top).is_null()
                && (*(*ctx).run_stack_top).step() as libc::c_int == -(1 as libc::c_int)
            {
                let mut n: *mut mln_lang_stack_node_t = ({
                    let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                    if !n_0.is_null()
                        && {
                            (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                            (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                        }
                    {
                        (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                    }
                    n_0
                });
                if !n.is_null() {
                    if !((*n).ret_var).is_null() {
                        __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                        (*n).ret_var = 0 as *mut mln_lang_var_t;
                    }
                    if !((*n).ret_var2).is_null() {
                        __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                        (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    }
                }
            }
        }
        node = ({
            let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
            if ((*ctx).run_stack_top).is_null() {
                (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                n = (*ctx).run_stack_top;
            } else if (((*ctx).run_stack_top)
                .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                < 1024 as libc::c_int as libc::c_long
            {
                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                n = (*ctx).run_stack_top;
            }
            if !n.is_null() {
                (*n).type_0 = (*assign).type_0 as mln_lang_stack_node_type_t;
                (*n).pos = 0 as *mut libc::c_void;
                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                (*n).ret_var = (*n).ret_var2;
                (*n).set_step(0 as libc::c_int as mln_u32_t);
                (*n).set_call(0 as libc::c_int as mln_u32_t);
                match (*assign).type_0 as mln_lang_stack_node_type_t as libc::c_uint {
                    0 => {
                        (*n).data.stm = (*assign).jump as *mut mln_lang_stm_t;
                    }
                    1 => {
                        (*n).data.funcdef = (*assign).jump as *mut mln_lang_funcdef_t;
                    }
                    2 => {
                        (*n).data.set = (*assign).jump as *mut mln_lang_set_t;
                    }
                    3 => {
                        (*n).data.set_stm = (*assign).jump as *mut mln_lang_setstm_t;
                    }
                    4 => {
                        (*n).data.block = (*assign).jump as *mut mln_lang_block_t;
                    }
                    5 => {
                        (*n).data.w = (*assign).jump as *mut mln_lang_while_t;
                    }
                    6 => {
                        (*n).data.sw = (*assign).jump as *mut mln_lang_switch_t;
                    }
                    7 => {
                        (*n).data.sw_stm = (*assign).jump as *mut mln_lang_switchstm_t;
                    }
                    8 => {
                        (*n).data.f = (*assign).jump as *mut mln_lang_for_t;
                    }
                    9 => {
                        (*n).data.i = (*assign).jump as *mut mln_lang_if_t;
                    }
                    10 => {
                        (*n).data.exp = (*assign).jump as *mut mln_lang_exp_t;
                    }
                    11 => {
                        (*n).data.assign = (*assign).jump as *mut mln_lang_assign_t;
                    }
                    12 => {
                        (*n).data.logiclow = (*assign).jump as *mut mln_lang_logiclow_t;
                    }
                    13 => {
                        (*n)
                            .data
                            .logichigh = (*assign).jump as *mut mln_lang_logichigh_t;
                        (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                    }
                    14 => {
                        (*n)
                            .data
                            .relativelow = (*assign).jump as *mut mln_lang_relativelow_t;
                        (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                    }
                    15 => {
                        (*n)
                            .data
                            .relativehigh = (*assign).jump
                            as *mut mln_lang_relativehigh_t;
                        (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                    }
                    16 => {
                        (*n).data.move_0 = (*assign).jump as *mut mln_lang_move_t;
                        (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                    }
                    17 => {
                        (*n).data.addsub = (*assign).jump as *mut mln_lang_addsub_t;
                        (*n).pos = (*n).data.addsub as *mut libc::c_void;
                    }
                    18 => {
                        (*n).data.muldiv = (*assign).jump as *mut mln_lang_muldiv_t;
                        (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                    }
                    19 => {
                        (*n).data.not = (*assign).jump as *mut mln_lang_not_t;
                        (*n).pos = (*n).data.not as *mut libc::c_void;
                    }
                    20 => {
                        (*n).data.suffix = (*assign).jump as *mut mln_lang_suffix_t;
                    }
                    21 => {
                        (*n).data.locate = (*assign).jump as *mut mln_lang_locate_t;
                    }
                    22 => {
                        (*n).data.spec = (*assign).jump as *mut mln_lang_spec_t;
                    }
                    23 => {
                        (*n).data.factor = (*assign).jump as *mut mln_lang_factor_t;
                    }
                    _ => {
                        (*n).data.elemlist = (*assign).jump as *mut mln_lang_elemlist_t;
                    }
                }
            }
            n
        });
        if node.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"Stack is full.\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
            return;
        }
        (mln_lang_stack_map[(*node).type_0 as usize])
            .expect("non-null function pointer")(ctx);
        return;
    } else if (*node).step() as libc::c_int == 1 as libc::c_int {
        (*node).set_step(2 as libc::c_int as mln_u32_t);
        mln_lang_stack_node_get_ctx_ret_var(node, ctx);
        node = ({
            let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
            if ((*ctx).run_stack_top).is_null() {
                (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                n = (*ctx).run_stack_top;
            } else if (((*ctx).run_stack_top)
                .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                < 1024 as libc::c_int as libc::c_long
            {
                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                n = (*ctx).run_stack_top;
            }
            if !n.is_null() {
                (*n).type_0 = M_LSNT_ASSIGN;
                (*n).pos = 0 as *mut libc::c_void;
                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                (*n).ret_var = (*n).ret_var2;
                (*n).set_step(0 as libc::c_int as mln_u32_t);
                (*n).set_call(0 as libc::c_int as mln_u32_t);
                match M_LSNT_ASSIGN as libc::c_int {
                    0 => {
                        (*n).data.stm = (*assign).right as *mut mln_lang_stm_t;
                    }
                    1 => {
                        (*n).data.funcdef = (*assign).right as *mut mln_lang_funcdef_t;
                    }
                    2 => {
                        (*n).data.set = (*assign).right as *mut mln_lang_set_t;
                    }
                    3 => {
                        (*n).data.set_stm = (*assign).right as *mut mln_lang_setstm_t;
                    }
                    4 => {
                        (*n).data.block = (*assign).right as *mut mln_lang_block_t;
                    }
                    5 => {
                        (*n).data.w = (*assign).right as *mut mln_lang_while_t;
                    }
                    6 => {
                        (*n).data.sw = (*assign).right as *mut mln_lang_switch_t;
                    }
                    7 => {
                        (*n).data.sw_stm = (*assign).right as *mut mln_lang_switchstm_t;
                    }
                    8 => {
                        (*n).data.f = (*assign).right as *mut mln_lang_for_t;
                    }
                    9 => {
                        (*n).data.i = (*assign).right as *mut mln_lang_if_t;
                    }
                    10 => {
                        (*n).data.exp = (*assign).right as *mut mln_lang_exp_t;
                    }
                    11 => {
                        (*n).data.assign = (*assign).right;
                    }
                    12 => {
                        (*n).data.logiclow = (*assign).right as *mut mln_lang_logiclow_t;
                    }
                    13 => {
                        (*n)
                            .data
                            .logichigh = (*assign).right as *mut mln_lang_logichigh_t;
                        (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                    }
                    14 => {
                        (*n)
                            .data
                            .relativelow = (*assign).right
                            as *mut mln_lang_relativelow_t;
                        (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                    }
                    15 => {
                        (*n)
                            .data
                            .relativehigh = (*assign).right
                            as *mut mln_lang_relativehigh_t;
                        (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                    }
                    16 => {
                        (*n).data.move_0 = (*assign).right as *mut mln_lang_move_t;
                        (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                    }
                    17 => {
                        (*n).data.addsub = (*assign).right as *mut mln_lang_addsub_t;
                        (*n).pos = (*n).data.addsub as *mut libc::c_void;
                    }
                    18 => {
                        (*n).data.muldiv = (*assign).right as *mut mln_lang_muldiv_t;
                        (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                    }
                    19 => {
                        (*n).data.not = (*assign).right as *mut mln_lang_not_t;
                        (*n).pos = (*n).data.not as *mut libc::c_void;
                    }
                    20 => {
                        (*n).data.suffix = (*assign).right as *mut mln_lang_suffix_t;
                    }
                    21 => {
                        (*n).data.locate = (*assign).right as *mut mln_lang_locate_t;
                    }
                    22 => {
                        (*n).data.spec = (*assign).right as *mut mln_lang_spec_t;
                    }
                    23 => {
                        (*n).data.factor = (*assign).right as *mut mln_lang_factor_t;
                    }
                    _ => {
                        (*n).data.elemlist = (*assign).right as *mut mln_lang_elemlist_t;
                    }
                }
            }
            n
        });
        if node.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"Stack is full.\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
            return;
        }
        (mln_lang_stack_map[(*node).type_0 as usize])
            .expect("non-null function pointer")(ctx);
        return;
    } else {
        if (*node).step() as libc::c_int == 2 as libc::c_int {
            (*node).set_step(3 as libc::c_int as mln_u32_t);
            handler = None;
            method = 0 as *mut mln_lang_method_t;
            if (*assign).op as libc::c_uint
                != M_ASSIGN_NONE as libc::c_int as libc::c_uint
            {
                method = mln_lang_methods[(*(*(*ctx).ret_var).val).type_0 as usize];
                if method.is_null() {
                    __mln_lang_errmsg(
                        ctx,
                        b"Operation NOT support.\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                    );
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                match (*assign).op as libc::c_uint {
                    1 => {
                        handler = (*method).assign_handler;
                    }
                    2 => {
                        handler = (*method).pluseq_handler;
                    }
                    3 => {
                        handler = (*method).subeq_handler;
                    }
                    4 => {
                        handler = (*method).lmoveq_handler;
                    }
                    5 => {
                        handler = (*method).rmoveq_handler;
                    }
                    6 => {
                        handler = (*method).muleq_handler;
                    }
                    7 => {
                        handler = (*method).diveq_handler;
                    }
                    8 => {
                        handler = (*method).oreq_handler;
                    }
                    9 => {
                        handler = (*method).andeq_handler;
                    }
                    10 => {
                        handler = (*method).xoreq_handler;
                    }
                    11 => {
                        handler = (*method).modeq_handler;
                    }
                    _ => {}
                }
            }
            if handler.is_some() {
                if (*(*(*node).ret_var).val).not_modify() != 0 {
                    __mln_lang_errmsg(
                        ctx,
                        b"Operand cannot be changed.\0" as *const u8
                            as *const libc::c_char as *mut libc::c_char,
                    );
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                if handler
                    .expect(
                        "non-null function pointer",
                    )(ctx, &mut res, (*node).ret_var, (*ctx).ret_var) < 0 as libc::c_int
                {
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                __mln_lang_ctx_set_ret_var(ctx, res);
                if (*(*res).val).type_0 == 8 as libc::c_int {
                    (*node).set_call(1 as libc::c_int as mln_u32_t);
                    current_block = 10147602450694744789;
                } else {
                    current_block = 15015283358615844190;
                }
            } else {
                if (*assign).op as libc::c_uint
                    == M_ASSIGN_NONE as libc::c_int as libc::c_uint
                {
                    mln_lang_ctx_get_node_ret_val(ctx, node);
                } else {
                    __mln_lang_errmsg(
                        ctx,
                        b"Operation NOT support.\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                    );
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                current_block = 15015283358615844190;
            }
        } else if (*node).step() as libc::c_int == 3 as libc::c_int {
            if (*node).call() != 0 {
                if mln_lang_withdraw_until_func(ctx) < 0 as libc::c_int {
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                res = (*ctx).ret_var;
                if (*(*(*ctx).ret_var).val).type_0 == 8 as libc::c_int {
                    current_block = 10147602450694744789;
                } else {
                    (*node).set_call(0 as libc::c_int as mln_u32_t);
                    current_block = 15015283358615844190;
                }
            } else {
                current_block = 15015283358615844190;
            }
        } else if (*node).step() as libc::c_int == 4 as libc::c_int {
            if (*node).call() != 0 {
                if mln_lang_withdraw_until_func(ctx) < 0 as libc::c_int {
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                (*node).set_call(0 as libc::c_int as mln_u32_t);
            }
            mln_lang_ctx_get_node_ret_val(ctx, node);
            current_block = 7966203691789621922;
        } else {
            let mut n: *mut mln_lang_stack_node_t = ({
                let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                if !n_0.is_null()
                    && {
                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                        (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                    }
                {
                    (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                }
                n_0
            });
            if !n.is_null() {
                if !((*n).ret_var).is_null() {
                    __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                    (*n).ret_var = 0 as *mut mln_lang_var_t;
                }
                if !((*n).ret_var2).is_null() {
                    __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                }
            }
            while !((*ctx).run_stack_top).is_null()
                && (*(*ctx).run_stack_top).step() as libc::c_int == -(1 as libc::c_int)
            {
                let mut n: *mut mln_lang_stack_node_t = ({
                    let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                    if !n_0.is_null()
                        && {
                            (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                            (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                        }
                    {
                        (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                    }
                    n_0
                });
                if !n.is_null() {
                    if !((*n).ret_var).is_null() {
                        __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                        (*n).ret_var = 0 as *mut mln_lang_var_t;
                    }
                    if !((*n).ret_var2).is_null() {
                        __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                        (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    }
                }
            }
            current_block = 2705889988320590074;
        }
        match current_block {
            15015283358615844190 => {
                (*node).set_step(4 as libc::c_int as mln_u32_t);
                if !((*node).ret_var).is_null()
                    && !((*(*(*node).ret_var).val).func).is_null()
                {
                    if mln_lang_watch_func_build(
                        ctx,
                        node,
                        (*(*(*node).ret_var).val).func,
                        (*(*(*node).ret_var).val).udata,
                        (*(*node).ret_var).val,
                    ) < 0 as libc::c_int
                    {
                        (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                        return;
                    }
                    mln_lang_stack_node_get_ctx_ret_var(node, ctx);
                    mln_lang_ctx_reset_ret_var(ctx);
                    current_block = 2705889988320590074;
                } else {
                    current_block = 7966203691789621922;
                }
            }
            10147602450694744789 => {
                if mln_lang_stack_handler_funccall_run(
                    ctx,
                    node,
                    (*(*res).val).data.call,
                ) < 0 as libc::c_int
                {
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                current_block = 2705889988320590074;
            }
            _ => {}
        }
        match current_block {
            7966203691789621922 => {
                let mut n: *mut mln_lang_stack_node_t = ({
                    let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                    if !n_0.is_null()
                        && {
                            (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                            (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                        }
                    {
                        (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                    }
                    n_0
                });
                if !n.is_null() {
                    if !((*n).ret_var).is_null() {
                        __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                        (*n).ret_var = 0 as *mut mln_lang_var_t;
                    }
                    if !((*n).ret_var2).is_null() {
                        __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                        (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    }
                }
                while !((*ctx).run_stack_top).is_null()
                    && (*(*ctx).run_stack_top).step() as libc::c_int
                        == -(1 as libc::c_int)
                {
                    let mut n: *mut mln_lang_stack_node_t = ({
                        let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                        if !n_0.is_null()
                            && {
                                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                                (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                            }
                        {
                            (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                        }
                        n_0
                    });
                    if !n.is_null() {
                        if !((*n).ret_var).is_null() {
                            __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                            (*n).ret_var = 0 as *mut mln_lang_var_t;
                        }
                        if !((*n).ret_var2).is_null() {
                            __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                            (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                        }
                    }
                }
            }
            _ => {}
        }
        return;
    };
}
unsafe extern "C" fn mln_lang_stack_handler_logiclow(mut ctx: *mut mln_lang_ctx_t) {
    let mut node: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
    let mut logiclow: *mut mln_lang_logiclow_t = (*node).data.logiclow;
    if (*node).step() as libc::c_int == 0 as libc::c_int {
        mln_lang_stack_node_reset_ret_val(node);
        mln_lang_ctx_reset_ret_var(ctx);
        if (*logiclow).op as libc::c_uint
            == M_LOGICLOW_NONE as libc::c_int as libc::c_uint
        {
            (*node).set_step(-(1 as libc::c_int) as mln_u32_t);
        } else {
            (*node).set_step(1 as libc::c_int as mln_u32_t);
        }
        if ((*logiclow).jump).is_null() {
            mln_lang_generate_jump_ptr(logiclow as *mut libc::c_void, M_LSNT_LOGICLOW);
        }
        if (*logiclow).type_0 == M_LSNT_FACTOR as libc::c_int
            && (*logiclow).op as libc::c_uint
                == M_LOGICLOW_NONE as libc::c_int as libc::c_uint
        {
            let mut n: *mut mln_lang_stack_node_t = ({
                let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                if !n_0.is_null()
                    && {
                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                        (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                    }
                {
                    (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                }
                n_0
            });
            if !n.is_null() {
                if !((*n).ret_var).is_null() {
                    __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                    (*n).ret_var = 0 as *mut mln_lang_var_t;
                }
                if !((*n).ret_var2).is_null() {
                    __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                }
            }
            while !((*ctx).run_stack_top).is_null()
                && (*(*ctx).run_stack_top).step() as libc::c_int == -(1 as libc::c_int)
            {
                let mut n: *mut mln_lang_stack_node_t = ({
                    let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                    if !n_0.is_null()
                        && {
                            (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                            (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                        }
                    {
                        (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                    }
                    n_0
                });
                if !n.is_null() {
                    if !((*n).ret_var).is_null() {
                        __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                        (*n).ret_var = 0 as *mut mln_lang_var_t;
                    }
                    if !((*n).ret_var2).is_null() {
                        __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                        (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    }
                }
            }
        }
        node = ({
            let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
            if ((*ctx).run_stack_top).is_null() {
                (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                n = (*ctx).run_stack_top;
            } else if (((*ctx).run_stack_top)
                .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                < 1024 as libc::c_int as libc::c_long
            {
                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                n = (*ctx).run_stack_top;
            }
            if !n.is_null() {
                (*n).type_0 = (*logiclow).type_0 as mln_lang_stack_node_type_t;
                (*n).pos = 0 as *mut libc::c_void;
                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                (*n).ret_var = (*n).ret_var2;
                (*n).set_step(0 as libc::c_int as mln_u32_t);
                (*n).set_call(0 as libc::c_int as mln_u32_t);
                match (*logiclow).type_0 as mln_lang_stack_node_type_t as libc::c_uint {
                    0 => {
                        (*n).data.stm = (*logiclow).jump as *mut mln_lang_stm_t;
                    }
                    1 => {
                        (*n).data.funcdef = (*logiclow).jump as *mut mln_lang_funcdef_t;
                    }
                    2 => {
                        (*n).data.set = (*logiclow).jump as *mut mln_lang_set_t;
                    }
                    3 => {
                        (*n).data.set_stm = (*logiclow).jump as *mut mln_lang_setstm_t;
                    }
                    4 => {
                        (*n).data.block = (*logiclow).jump as *mut mln_lang_block_t;
                    }
                    5 => {
                        (*n).data.w = (*logiclow).jump as *mut mln_lang_while_t;
                    }
                    6 => {
                        (*n).data.sw = (*logiclow).jump as *mut mln_lang_switch_t;
                    }
                    7 => {
                        (*n).data.sw_stm = (*logiclow).jump as *mut mln_lang_switchstm_t;
                    }
                    8 => {
                        (*n).data.f = (*logiclow).jump as *mut mln_lang_for_t;
                    }
                    9 => {
                        (*n).data.i = (*logiclow).jump as *mut mln_lang_if_t;
                    }
                    10 => {
                        (*n).data.exp = (*logiclow).jump as *mut mln_lang_exp_t;
                    }
                    11 => {
                        (*n).data.assign = (*logiclow).jump as *mut mln_lang_assign_t;
                    }
                    12 => {
                        (*n)
                            .data
                            .logiclow = (*logiclow).jump as *mut mln_lang_logiclow_t;
                    }
                    13 => {
                        (*n)
                            .data
                            .logichigh = (*logiclow).jump as *mut mln_lang_logichigh_t;
                        (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                    }
                    14 => {
                        (*n)
                            .data
                            .relativelow = (*logiclow).jump
                            as *mut mln_lang_relativelow_t;
                        (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                    }
                    15 => {
                        (*n)
                            .data
                            .relativehigh = (*logiclow).jump
                            as *mut mln_lang_relativehigh_t;
                        (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                    }
                    16 => {
                        (*n).data.move_0 = (*logiclow).jump as *mut mln_lang_move_t;
                        (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                    }
                    17 => {
                        (*n).data.addsub = (*logiclow).jump as *mut mln_lang_addsub_t;
                        (*n).pos = (*n).data.addsub as *mut libc::c_void;
                    }
                    18 => {
                        (*n).data.muldiv = (*logiclow).jump as *mut mln_lang_muldiv_t;
                        (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                    }
                    19 => {
                        (*n).data.not = (*logiclow).jump as *mut mln_lang_not_t;
                        (*n).pos = (*n).data.not as *mut libc::c_void;
                    }
                    20 => {
                        (*n).data.suffix = (*logiclow).jump as *mut mln_lang_suffix_t;
                    }
                    21 => {
                        (*n).data.locate = (*logiclow).jump as *mut mln_lang_locate_t;
                    }
                    22 => {
                        (*n).data.spec = (*logiclow).jump as *mut mln_lang_spec_t;
                    }
                    23 => {
                        (*n).data.factor = (*logiclow).jump as *mut mln_lang_factor_t;
                    }
                    _ => {
                        (*n)
                            .data
                            .elemlist = (*logiclow).jump as *mut mln_lang_elemlist_t;
                    }
                }
            }
            n
        });
        if node.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"Stack is full.\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
            return;
        }
        (mln_lang_stack_map[(*node).type_0 as usize])
            .expect("non-null function pointer")(ctx);
        return;
    } else if (*node).step() as libc::c_int == 1 as libc::c_int {
        (*node).set_step(2 as libc::c_int as mln_u32_t);
        if __mln_lang_condition_is_true((*ctx).ret_var) != 0 {
            if (*logiclow).op as libc::c_uint
                == M_LOGICLOW_AND as libc::c_int as libc::c_uint
            {
                node = ({
                    let mut n: *mut mln_lang_stack_node_t = 0
                        as *mut mln_lang_stack_node_t;
                    if ((*ctx).run_stack_top).is_null() {
                        (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                        n = (*ctx).run_stack_top;
                    } else if (((*ctx).run_stack_top)
                        .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                        < 1024 as libc::c_int as libc::c_long
                    {
                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                        n = (*ctx).run_stack_top;
                    }
                    if !n.is_null() {
                        (*n).type_0 = M_LSNT_LOGICLOW;
                        (*n).pos = 0 as *mut libc::c_void;
                        (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                        (*n).ret_var = (*n).ret_var2;
                        (*n).set_step(0 as libc::c_int as mln_u32_t);
                        (*n).set_call(0 as libc::c_int as mln_u32_t);
                        match M_LSNT_LOGICLOW as libc::c_int {
                            0 => {
                                (*n).data.stm = (*logiclow).right as *mut mln_lang_stm_t;
                            }
                            1 => {
                                (*n)
                                    .data
                                    .funcdef = (*logiclow).right as *mut mln_lang_funcdef_t;
                            }
                            2 => {
                                (*n).data.set = (*logiclow).right as *mut mln_lang_set_t;
                            }
                            3 => {
                                (*n)
                                    .data
                                    .set_stm = (*logiclow).right as *mut mln_lang_setstm_t;
                            }
                            4 => {
                                (*n)
                                    .data
                                    .block = (*logiclow).right as *mut mln_lang_block_t;
                            }
                            5 => {
                                (*n).data.w = (*logiclow).right as *mut mln_lang_while_t;
                            }
                            6 => {
                                (*n).data.sw = (*logiclow).right as *mut mln_lang_switch_t;
                            }
                            7 => {
                                (*n)
                                    .data
                                    .sw_stm = (*logiclow).right as *mut mln_lang_switchstm_t;
                            }
                            8 => {
                                (*n).data.f = (*logiclow).right as *mut mln_lang_for_t;
                            }
                            9 => {
                                (*n).data.i = (*logiclow).right as *mut mln_lang_if_t;
                            }
                            10 => {
                                (*n).data.exp = (*logiclow).right as *mut mln_lang_exp_t;
                            }
                            11 => {
                                (*n)
                                    .data
                                    .assign = (*logiclow).right as *mut mln_lang_assign_t;
                            }
                            12 => {
                                (*n).data.logiclow = (*logiclow).right;
                            }
                            13 => {
                                (*n)
                                    .data
                                    .logichigh = (*logiclow).right as *mut mln_lang_logichigh_t;
                                (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                            }
                            14 => {
                                (*n)
                                    .data
                                    .relativelow = (*logiclow).right
                                    as *mut mln_lang_relativelow_t;
                                (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                            }
                            15 => {
                                (*n)
                                    .data
                                    .relativehigh = (*logiclow).right
                                    as *mut mln_lang_relativehigh_t;
                                (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                            }
                            16 => {
                                (*n)
                                    .data
                                    .move_0 = (*logiclow).right as *mut mln_lang_move_t;
                                (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                            }
                            17 => {
                                (*n)
                                    .data
                                    .addsub = (*logiclow).right as *mut mln_lang_addsub_t;
                                (*n).pos = (*n).data.addsub as *mut libc::c_void;
                            }
                            18 => {
                                (*n)
                                    .data
                                    .muldiv = (*logiclow).right as *mut mln_lang_muldiv_t;
                                (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                            }
                            19 => {
                                (*n).data.not = (*logiclow).right as *mut mln_lang_not_t;
                                (*n).pos = (*n).data.not as *mut libc::c_void;
                            }
                            20 => {
                                (*n)
                                    .data
                                    .suffix = (*logiclow).right as *mut mln_lang_suffix_t;
                            }
                            21 => {
                                (*n)
                                    .data
                                    .locate = (*logiclow).right as *mut mln_lang_locate_t;
                            }
                            22 => {
                                (*n).data.spec = (*logiclow).right as *mut mln_lang_spec_t;
                            }
                            23 => {
                                (*n)
                                    .data
                                    .factor = (*logiclow).right as *mut mln_lang_factor_t;
                            }
                            _ => {
                                (*n)
                                    .data
                                    .elemlist = (*logiclow).right as *mut mln_lang_elemlist_t;
                            }
                        }
                    }
                    n
                });
                if node.is_null() {
                    __mln_lang_errmsg(
                        ctx,
                        b"Stack is full.\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                    );
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                (mln_lang_stack_map[(*node).type_0 as usize])
                    .expect("non-null function pointer")(ctx);
                return;
            }
        } else {
            loop {
                if (*logiclow).op as libc::c_uint
                    == M_LOGICLOW_OR as libc::c_int as libc::c_uint
                {
                    node = ({
                        let mut n: *mut mln_lang_stack_node_t = 0
                            as *mut mln_lang_stack_node_t;
                        if ((*ctx).run_stack_top).is_null() {
                            (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                            n = (*ctx).run_stack_top;
                        } else if (((*ctx).run_stack_top)
                            .offset_from(((*ctx).run_stack).as_mut_ptr())
                            as libc::c_long) < 1024 as libc::c_int as libc::c_long
                        {
                            (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                            n = (*ctx).run_stack_top;
                        }
                        if !n.is_null() {
                            (*n).type_0 = M_LSNT_LOGICLOW;
                            (*n).pos = 0 as *mut libc::c_void;
                            (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                            (*n).ret_var = (*n).ret_var2;
                            (*n).set_step(0 as libc::c_int as mln_u32_t);
                            (*n).set_call(0 as libc::c_int as mln_u32_t);
                            match M_LSNT_LOGICLOW as libc::c_int {
                                0 => {
                                    (*n).data.stm = (*logiclow).right as *mut mln_lang_stm_t;
                                }
                                1 => {
                                    (*n)
                                        .data
                                        .funcdef = (*logiclow).right as *mut mln_lang_funcdef_t;
                                }
                                2 => {
                                    (*n).data.set = (*logiclow).right as *mut mln_lang_set_t;
                                }
                                3 => {
                                    (*n)
                                        .data
                                        .set_stm = (*logiclow).right as *mut mln_lang_setstm_t;
                                }
                                4 => {
                                    (*n)
                                        .data
                                        .block = (*logiclow).right as *mut mln_lang_block_t;
                                }
                                5 => {
                                    (*n).data.w = (*logiclow).right as *mut mln_lang_while_t;
                                }
                                6 => {
                                    (*n).data.sw = (*logiclow).right as *mut mln_lang_switch_t;
                                }
                                7 => {
                                    (*n)
                                        .data
                                        .sw_stm = (*logiclow).right as *mut mln_lang_switchstm_t;
                                }
                                8 => {
                                    (*n).data.f = (*logiclow).right as *mut mln_lang_for_t;
                                }
                                9 => {
                                    (*n).data.i = (*logiclow).right as *mut mln_lang_if_t;
                                }
                                10 => {
                                    (*n).data.exp = (*logiclow).right as *mut mln_lang_exp_t;
                                }
                                11 => {
                                    (*n)
                                        .data
                                        .assign = (*logiclow).right as *mut mln_lang_assign_t;
                                }
                                12 => {
                                    (*n).data.logiclow = (*logiclow).right;
                                }
                                13 => {
                                    (*n)
                                        .data
                                        .logichigh = (*logiclow).right as *mut mln_lang_logichigh_t;
                                    (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                                }
                                14 => {
                                    (*n)
                                        .data
                                        .relativelow = (*logiclow).right
                                        as *mut mln_lang_relativelow_t;
                                    (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                                }
                                15 => {
                                    (*n)
                                        .data
                                        .relativehigh = (*logiclow).right
                                        as *mut mln_lang_relativehigh_t;
                                    (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                                }
                                16 => {
                                    (*n)
                                        .data
                                        .move_0 = (*logiclow).right as *mut mln_lang_move_t;
                                    (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                                }
                                17 => {
                                    (*n)
                                        .data
                                        .addsub = (*logiclow).right as *mut mln_lang_addsub_t;
                                    (*n).pos = (*n).data.addsub as *mut libc::c_void;
                                }
                                18 => {
                                    (*n)
                                        .data
                                        .muldiv = (*logiclow).right as *mut mln_lang_muldiv_t;
                                    (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                                }
                                19 => {
                                    (*n).data.not = (*logiclow).right as *mut mln_lang_not_t;
                                    (*n).pos = (*n).data.not as *mut libc::c_void;
                                }
                                20 => {
                                    (*n)
                                        .data
                                        .suffix = (*logiclow).right as *mut mln_lang_suffix_t;
                                }
                                21 => {
                                    (*n)
                                        .data
                                        .locate = (*logiclow).right as *mut mln_lang_locate_t;
                                }
                                22 => {
                                    (*n).data.spec = (*logiclow).right as *mut mln_lang_spec_t;
                                }
                                23 => {
                                    (*n)
                                        .data
                                        .factor = (*logiclow).right as *mut mln_lang_factor_t;
                                }
                                _ => {
                                    (*n)
                                        .data
                                        .elemlist = (*logiclow).right as *mut mln_lang_elemlist_t;
                                }
                            }
                        }
                        n
                    });
                    if node.is_null() {
                        __mln_lang_errmsg(
                            ctx,
                            b"Stack is full.\0" as *const u8 as *const libc::c_char
                                as *mut libc::c_char,
                        );
                        (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                        return;
                    }
                    (mln_lang_stack_map[(*node).type_0 as usize])
                        .expect("non-null function pointer")(ctx);
                    return;
                } else {
                    logiclow = (*logiclow).right;
                    if !logiclow.is_null() {
                        continue;
                    }
                    return;
                }
            }
        }
    } else {
        let mut n: *mut mln_lang_stack_node_t = ({
            let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
            if !n_0.is_null()
                && {
                    (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                    (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                }
            {
                (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
            }
            n_0
        });
        if !n.is_null() {
            if !((*n).ret_var).is_null() {
                __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                (*n).ret_var = 0 as *mut mln_lang_var_t;
            }
            if !((*n).ret_var2).is_null() {
                __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
            }
        }
        while !((*ctx).run_stack_top).is_null()
            && (*(*ctx).run_stack_top).step() as libc::c_int == -(1 as libc::c_int)
        {
            let mut n: *mut mln_lang_stack_node_t = ({
                let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                if !n_0.is_null()
                    && {
                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                        (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                    }
                {
                    (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                }
                n_0
            });
            if !n.is_null() {
                if !((*n).ret_var).is_null() {
                    __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                    (*n).ret_var = 0 as *mut mln_lang_var_t;
                }
                if !((*n).ret_var2).is_null() {
                    __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                }
            }
        }
    };
}
unsafe extern "C" fn mln_lang_stack_handler_logichigh(mut ctx: *mut mln_lang_ctx_t) {
    let mut node: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
    let mut ll: *mut mln_lang_logichigh_t = 0 as *mut mln_lang_logichigh_t;
    let mut logichigh: *mut mln_lang_logichigh_t = (*node).pos
        as *mut mln_lang_logichigh_t;
    let mut res: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    if (*node).step() as libc::c_int == 0 as libc::c_int {
        mln_lang_stack_node_reset_ret_val(node);
        mln_lang_ctx_reset_ret_var(ctx);
        if (*logichigh).op as libc::c_uint
            == M_LOGICHIGH_NONE as libc::c_int as libc::c_uint
        {
            (*node).set_step(-(1 as libc::c_int) as mln_u32_t);
        } else {
            (*node).set_step(1 as libc::c_int as mln_u32_t);
        }
        if ((*logichigh).jump).is_null() {
            mln_lang_generate_jump_ptr(logichigh as *mut libc::c_void, M_LSNT_LOGICHIGH);
        }
        if (*logichigh).type_0 == M_LSNT_FACTOR as libc::c_int
            && (*logichigh).op as libc::c_uint
                == M_LOGICHIGH_NONE as libc::c_int as libc::c_uint
        {
            let mut n: *mut mln_lang_stack_node_t = ({
                let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                if !n_0.is_null()
                    && {
                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                        (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                    }
                {
                    (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                }
                n_0
            });
            if !n.is_null() {
                if !((*n).ret_var).is_null() {
                    __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                    (*n).ret_var = 0 as *mut mln_lang_var_t;
                }
                if !((*n).ret_var2).is_null() {
                    __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                }
            }
            while !((*ctx).run_stack_top).is_null()
                && (*(*ctx).run_stack_top).step() as libc::c_int == -(1 as libc::c_int)
            {
                let mut n: *mut mln_lang_stack_node_t = ({
                    let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                    if !n_0.is_null()
                        && {
                            (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                            (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                        }
                    {
                        (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                    }
                    n_0
                });
                if !n.is_null() {
                    if !((*n).ret_var).is_null() {
                        __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                        (*n).ret_var = 0 as *mut mln_lang_var_t;
                    }
                    if !((*n).ret_var2).is_null() {
                        __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                        (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    }
                }
            }
        }
        node = ({
            let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
            if ((*ctx).run_stack_top).is_null() {
                (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                n = (*ctx).run_stack_top;
            } else if (((*ctx).run_stack_top)
                .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                < 1024 as libc::c_int as libc::c_long
            {
                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                n = (*ctx).run_stack_top;
            }
            if !n.is_null() {
                (*n).type_0 = (*logichigh).type_0 as mln_lang_stack_node_type_t;
                (*n).pos = 0 as *mut libc::c_void;
                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                (*n).ret_var = (*n).ret_var2;
                (*n).set_step(0 as libc::c_int as mln_u32_t);
                (*n).set_call(0 as libc::c_int as mln_u32_t);
                match (*logichigh).type_0 as mln_lang_stack_node_type_t as libc::c_uint {
                    0 => {
                        (*n).data.stm = (*logichigh).jump as *mut mln_lang_stm_t;
                    }
                    1 => {
                        (*n).data.funcdef = (*logichigh).jump as *mut mln_lang_funcdef_t;
                    }
                    2 => {
                        (*n).data.set = (*logichigh).jump as *mut mln_lang_set_t;
                    }
                    3 => {
                        (*n).data.set_stm = (*logichigh).jump as *mut mln_lang_setstm_t;
                    }
                    4 => {
                        (*n).data.block = (*logichigh).jump as *mut mln_lang_block_t;
                    }
                    5 => {
                        (*n).data.w = (*logichigh).jump as *mut mln_lang_while_t;
                    }
                    6 => {
                        (*n).data.sw = (*logichigh).jump as *mut mln_lang_switch_t;
                    }
                    7 => {
                        (*n)
                            .data
                            .sw_stm = (*logichigh).jump as *mut mln_lang_switchstm_t;
                    }
                    8 => {
                        (*n).data.f = (*logichigh).jump as *mut mln_lang_for_t;
                    }
                    9 => {
                        (*n).data.i = (*logichigh).jump as *mut mln_lang_if_t;
                    }
                    10 => {
                        (*n).data.exp = (*logichigh).jump as *mut mln_lang_exp_t;
                    }
                    11 => {
                        (*n).data.assign = (*logichigh).jump as *mut mln_lang_assign_t;
                    }
                    12 => {
                        (*n)
                            .data
                            .logiclow = (*logichigh).jump as *mut mln_lang_logiclow_t;
                    }
                    13 => {
                        (*n)
                            .data
                            .logichigh = (*logichigh).jump as *mut mln_lang_logichigh_t;
                        (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                    }
                    14 => {
                        (*n)
                            .data
                            .relativelow = (*logichigh).jump
                            as *mut mln_lang_relativelow_t;
                        (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                    }
                    15 => {
                        (*n)
                            .data
                            .relativehigh = (*logichigh).jump
                            as *mut mln_lang_relativehigh_t;
                        (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                    }
                    16 => {
                        (*n).data.move_0 = (*logichigh).jump as *mut mln_lang_move_t;
                        (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                    }
                    17 => {
                        (*n).data.addsub = (*logichigh).jump as *mut mln_lang_addsub_t;
                        (*n).pos = (*n).data.addsub as *mut libc::c_void;
                    }
                    18 => {
                        (*n).data.muldiv = (*logichigh).jump as *mut mln_lang_muldiv_t;
                        (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                    }
                    19 => {
                        (*n).data.not = (*logichigh).jump as *mut mln_lang_not_t;
                        (*n).pos = (*n).data.not as *mut libc::c_void;
                    }
                    20 => {
                        (*n).data.suffix = (*logichigh).jump as *mut mln_lang_suffix_t;
                    }
                    21 => {
                        (*n).data.locate = (*logichigh).jump as *mut mln_lang_locate_t;
                    }
                    22 => {
                        (*n).data.spec = (*logichigh).jump as *mut mln_lang_spec_t;
                    }
                    23 => {
                        (*n).data.factor = (*logichigh).jump as *mut mln_lang_factor_t;
                    }
                    _ => {
                        (*n)
                            .data
                            .elemlist = (*logichigh).jump as *mut mln_lang_elemlist_t;
                    }
                }
            }
            n
        });
        if node.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"Stack is full.\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
            return;
        }
        (mln_lang_stack_map[(*node).type_0 as usize])
            .expect("non-null function pointer")(ctx);
        return;
    } else {
        if (*node).step() as libc::c_int == 1 as libc::c_int {
            (*node).set_step(2 as libc::c_int as mln_u32_t);
            mln_lang_stack_node_get_ctx_ret_var(node, ctx);
        } else if !((*node).step() as libc::c_int == 2 as libc::c_int) {
            let mut handler: mln_lang_op = None;
            let mut method: *mut mln_lang_method_t = 0 as *mut mln_lang_method_t;
            let mut current_block_91: u64;
            if (*node).step() as libc::c_int == 3 as libc::c_int {
                (*node).set_step(4 as libc::c_int as mln_u32_t);
                handler = None;
                method = 0 as *mut mln_lang_method_t;
                method = mln_lang_methods[(*(*(*node).ret_var).val).type_0 as usize];
                if method.is_null() {
                    __mln_lang_errmsg(
                        ctx,
                        b"Operation NOT support.\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                    );
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                match (*logichigh).op as libc::c_uint {
                    1 => {
                        handler = (*method).cor_handler;
                    }
                    2 => {
                        handler = (*method).cand_handler;
                    }
                    3 => {
                        handler = (*method).cxor_handler;
                    }
                    _ => {}
                }
                if handler.is_none() {
                    __mln_lang_errmsg(
                        ctx,
                        b"Operation NOT support.\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                    );
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                if handler
                    .expect(
                        "non-null function pointer",
                    )(ctx, &mut res, (*node).ret_var, (*ctx).ret_var) < 0 as libc::c_int
                {
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                mln_lang_stack_node_get_ctx_ret_var(node, ctx);
                __mln_lang_ctx_set_ret_var(ctx, res);
                if (*(*res).val).type_0 == 8 as libc::c_int {
                    current_block_91 = 6548636697844393749;
                } else {
                    current_block_91 = 6294755287239680199;
                }
            } else if (*node).step() as libc::c_int == 4 as libc::c_int {
                if (*node).call() != 0 {
                    if mln_lang_withdraw_until_func(ctx) < 0 as libc::c_int {
                        (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                        return;
                    }
                    (*node).set_call(0 as libc::c_int as mln_u32_t);
                    res = (*ctx).ret_var;
                    if (*(*res).val).type_0 == 8 as libc::c_int {
                        current_block_91 = 6548636697844393749;
                    } else {
                        current_block_91 = 6294755287239680199;
                    }
                } else {
                    current_block_91 = 6294755287239680199;
                }
            } else {
                let mut n: *mut mln_lang_stack_node_t = ({
                    let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                    if !n_0.is_null()
                        && {
                            (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                            (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                        }
                    {
                        (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                    }
                    n_0
                });
                if !n.is_null() {
                    if !((*n).ret_var).is_null() {
                        __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                        (*n).ret_var = 0 as *mut mln_lang_var_t;
                    }
                    if !((*n).ret_var2).is_null() {
                        __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                        (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    }
                }
                while !((*ctx).run_stack_top).is_null()
                    && (*(*ctx).run_stack_top).step() as libc::c_int
                        == -(1 as libc::c_int)
                {
                    let mut n: *mut mln_lang_stack_node_t = ({
                        let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                        if !n_0.is_null()
                            && {
                                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                                (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                            }
                        {
                            (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                        }
                        n_0
                    });
                    if !n.is_null() {
                        if !((*n).ret_var).is_null() {
                            __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                            (*n).ret_var = 0 as *mut mln_lang_var_t;
                        }
                        if !((*n).ret_var2).is_null() {
                            __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                            (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                        }
                    }
                }
                current_block_91 = 7318352876044315808;
            }
            match current_block_91 {
                6294755287239680199 => {
                    (*node).pos = (*logichigh).right as *mut libc::c_void;
                    if !((*node).pos).is_null()
                        && (*(*logichigh).right).op as libc::c_uint
                            != M_LOGICHIGH_NONE as libc::c_int as libc::c_uint
                    {
                        (*node).set_step(2 as libc::c_int as mln_u32_t);
                        mln_lang_stack_node_get_ctx_ret_var(node, ctx);
                    } else {
                        let mut n: *mut mln_lang_stack_node_t = ({
                            let mut n_0: *mut mln_lang_stack_node_t = (*ctx)
                                .run_stack_top;
                            if !n_0.is_null()
                                && {
                                    (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                                    (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                                }
                            {
                                (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                            }
                            n_0
                        });
                        if !n.is_null() {
                            if !((*n).ret_var).is_null() {
                                __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                                (*n).ret_var = 0 as *mut mln_lang_var_t;
                            }
                            if !((*n).ret_var2).is_null() {
                                __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                            }
                        }
                        while !((*ctx).run_stack_top).is_null()
                            && (*(*ctx).run_stack_top).step() as libc::c_int
                                == -(1 as libc::c_int)
                        {
                            let mut n: *mut mln_lang_stack_node_t = ({
                                let mut n_0: *mut mln_lang_stack_node_t = (*ctx)
                                    .run_stack_top;
                                if !n_0.is_null()
                                    && {
                                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                                        (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                                    }
                                {
                                    (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                                }
                                n_0
                            });
                            if !n.is_null() {
                                if !((*n).ret_var).is_null() {
                                    __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                                    (*n).ret_var = 0 as *mut mln_lang_var_t;
                                }
                                if !((*n).ret_var2).is_null() {
                                    __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                                }
                            }
                        }
                    }
                }
                6548636697844393749 => {
                    (*node).set_call(1 as libc::c_int as mln_u32_t);
                    if mln_lang_stack_handler_funccall_run(
                        ctx,
                        node,
                        (*(*res).val).data.call,
                    ) < 0 as libc::c_int
                    {
                        (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                        return;
                    }
                }
                _ => {}
            }
            return;
        }
        (*node).set_step(3 as libc::c_int as mln_u32_t);
        ll = (*logichigh).right;
        node = ({
            let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
            if ((*ctx).run_stack_top).is_null() {
                (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                n = (*ctx).run_stack_top;
            } else if (((*ctx).run_stack_top)
                .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                < 1024 as libc::c_int as libc::c_long
            {
                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                n = (*ctx).run_stack_top;
            }
            if !n.is_null() {
                (*n).type_0 = M_LSNT_RELATIVELOW;
                (*n).pos = 0 as *mut libc::c_void;
                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                (*n).ret_var = (*n).ret_var2;
                (*n).set_step(0 as libc::c_int as mln_u32_t);
                (*n).set_call(0 as libc::c_int as mln_u32_t);
                match M_LSNT_RELATIVELOW as libc::c_int {
                    0 => {
                        (*n).data.stm = (*ll).left as *mut mln_lang_stm_t;
                    }
                    1 => {
                        (*n).data.funcdef = (*ll).left as *mut mln_lang_funcdef_t;
                    }
                    2 => {
                        (*n).data.set = (*ll).left as *mut mln_lang_set_t;
                    }
                    3 => {
                        (*n).data.set_stm = (*ll).left as *mut mln_lang_setstm_t;
                    }
                    4 => {
                        (*n).data.block = (*ll).left as *mut mln_lang_block_t;
                    }
                    5 => {
                        (*n).data.w = (*ll).left as *mut mln_lang_while_t;
                    }
                    6 => {
                        (*n).data.sw = (*ll).left as *mut mln_lang_switch_t;
                    }
                    7 => {
                        (*n).data.sw_stm = (*ll).left as *mut mln_lang_switchstm_t;
                    }
                    8 => {
                        (*n).data.f = (*ll).left as *mut mln_lang_for_t;
                    }
                    9 => {
                        (*n).data.i = (*ll).left as *mut mln_lang_if_t;
                    }
                    10 => {
                        (*n).data.exp = (*ll).left as *mut mln_lang_exp_t;
                    }
                    11 => {
                        (*n).data.assign = (*ll).left as *mut mln_lang_assign_t;
                    }
                    12 => {
                        (*n).data.logiclow = (*ll).left as *mut mln_lang_logiclow_t;
                    }
                    13 => {
                        (*n).data.logichigh = (*ll).left as *mut mln_lang_logichigh_t;
                        (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                    }
                    14 => {
                        (*n).data.relativelow = (*ll).left;
                        (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                    }
                    15 => {
                        (*n)
                            .data
                            .relativehigh = (*ll).left as *mut mln_lang_relativehigh_t;
                        (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                    }
                    16 => {
                        (*n).data.move_0 = (*ll).left as *mut mln_lang_move_t;
                        (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                    }
                    17 => {
                        (*n).data.addsub = (*ll).left as *mut mln_lang_addsub_t;
                        (*n).pos = (*n).data.addsub as *mut libc::c_void;
                    }
                    18 => {
                        (*n).data.muldiv = (*ll).left as *mut mln_lang_muldiv_t;
                        (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                    }
                    19 => {
                        (*n).data.not = (*ll).left as *mut mln_lang_not_t;
                        (*n).pos = (*n).data.not as *mut libc::c_void;
                    }
                    20 => {
                        (*n).data.suffix = (*ll).left as *mut mln_lang_suffix_t;
                    }
                    21 => {
                        (*n).data.locate = (*ll).left as *mut mln_lang_locate_t;
                    }
                    22 => {
                        (*n).data.spec = (*ll).left as *mut mln_lang_spec_t;
                    }
                    23 => {
                        (*n).data.factor = (*ll).left as *mut mln_lang_factor_t;
                    }
                    _ => {
                        (*n).data.elemlist = (*ll).left as *mut mln_lang_elemlist_t;
                    }
                }
            }
            n
        });
        if node.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"Stack is full.\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
            return;
        }
        (mln_lang_stack_map[(*node).type_0 as usize])
            .expect("non-null function pointer")(ctx);
        return;
    };
}
unsafe extern "C" fn mln_lang_stack_handler_relativelow(mut ctx: *mut mln_lang_ctx_t) {
    let mut node: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
    let mut tmp: *mut mln_lang_relativelow_t = 0 as *mut mln_lang_relativelow_t;
    let mut relativelow: *mut mln_lang_relativelow_t = (*node).pos
        as *mut mln_lang_relativelow_t;
    let mut res: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    if (*node).step() as libc::c_int == 0 as libc::c_int {
        mln_lang_stack_node_reset_ret_val(node);
        mln_lang_ctx_reset_ret_var(ctx);
        if (*relativelow).op as libc::c_uint
            == M_RELATIVELOW_NONE as libc::c_int as libc::c_uint
        {
            (*node).set_step(-(1 as libc::c_int) as mln_u32_t);
        } else {
            (*node).set_step(1 as libc::c_int as mln_u32_t);
        }
        if ((*relativelow).jump).is_null() {
            mln_lang_generate_jump_ptr(
                relativelow as *mut libc::c_void,
                M_LSNT_RELATIVELOW,
            );
        }
        if (*relativelow).type_0 == M_LSNT_FACTOR as libc::c_int
            && (*relativelow).op as libc::c_uint
                == M_RELATIVELOW_NONE as libc::c_int as libc::c_uint
        {
            let mut n: *mut mln_lang_stack_node_t = ({
                let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                if !n_0.is_null()
                    && {
                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                        (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                    }
                {
                    (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                }
                n_0
            });
            if !n.is_null() {
                if !((*n).ret_var).is_null() {
                    __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                    (*n).ret_var = 0 as *mut mln_lang_var_t;
                }
                if !((*n).ret_var2).is_null() {
                    __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                }
            }
            while !((*ctx).run_stack_top).is_null()
                && (*(*ctx).run_stack_top).step() as libc::c_int == -(1 as libc::c_int)
            {
                let mut n: *mut mln_lang_stack_node_t = ({
                    let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                    if !n_0.is_null()
                        && {
                            (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                            (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                        }
                    {
                        (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                    }
                    n_0
                });
                if !n.is_null() {
                    if !((*n).ret_var).is_null() {
                        __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                        (*n).ret_var = 0 as *mut mln_lang_var_t;
                    }
                    if !((*n).ret_var2).is_null() {
                        __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                        (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    }
                }
            }
        }
        node = ({
            let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
            if ((*ctx).run_stack_top).is_null() {
                (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                n = (*ctx).run_stack_top;
            } else if (((*ctx).run_stack_top)
                .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                < 1024 as libc::c_int as libc::c_long
            {
                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                n = (*ctx).run_stack_top;
            }
            if !n.is_null() {
                (*n).type_0 = (*relativelow).type_0 as mln_lang_stack_node_type_t;
                (*n).pos = 0 as *mut libc::c_void;
                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                (*n).ret_var = (*n).ret_var2;
                (*n).set_step(0 as libc::c_int as mln_u32_t);
                (*n).set_call(0 as libc::c_int as mln_u32_t);
                match (*relativelow).type_0 as mln_lang_stack_node_type_t as libc::c_uint
                {
                    0 => {
                        (*n).data.stm = (*relativelow).jump as *mut mln_lang_stm_t;
                    }
                    1 => {
                        (*n)
                            .data
                            .funcdef = (*relativelow).jump as *mut mln_lang_funcdef_t;
                    }
                    2 => {
                        (*n).data.set = (*relativelow).jump as *mut mln_lang_set_t;
                    }
                    3 => {
                        (*n)
                            .data
                            .set_stm = (*relativelow).jump as *mut mln_lang_setstm_t;
                    }
                    4 => {
                        (*n).data.block = (*relativelow).jump as *mut mln_lang_block_t;
                    }
                    5 => {
                        (*n).data.w = (*relativelow).jump as *mut mln_lang_while_t;
                    }
                    6 => {
                        (*n).data.sw = (*relativelow).jump as *mut mln_lang_switch_t;
                    }
                    7 => {
                        (*n)
                            .data
                            .sw_stm = (*relativelow).jump as *mut mln_lang_switchstm_t;
                    }
                    8 => {
                        (*n).data.f = (*relativelow).jump as *mut mln_lang_for_t;
                    }
                    9 => {
                        (*n).data.i = (*relativelow).jump as *mut mln_lang_if_t;
                    }
                    10 => {
                        (*n).data.exp = (*relativelow).jump as *mut mln_lang_exp_t;
                    }
                    11 => {
                        (*n).data.assign = (*relativelow).jump as *mut mln_lang_assign_t;
                    }
                    12 => {
                        (*n)
                            .data
                            .logiclow = (*relativelow).jump as *mut mln_lang_logiclow_t;
                    }
                    13 => {
                        (*n)
                            .data
                            .logichigh = (*relativelow).jump
                            as *mut mln_lang_logichigh_t;
                        (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                    }
                    14 => {
                        (*n)
                            .data
                            .relativelow = (*relativelow).jump
                            as *mut mln_lang_relativelow_t;
                        (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                    }
                    15 => {
                        (*n)
                            .data
                            .relativehigh = (*relativelow).jump
                            as *mut mln_lang_relativehigh_t;
                        (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                    }
                    16 => {
                        (*n).data.move_0 = (*relativelow).jump as *mut mln_lang_move_t;
                        (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                    }
                    17 => {
                        (*n).data.addsub = (*relativelow).jump as *mut mln_lang_addsub_t;
                        (*n).pos = (*n).data.addsub as *mut libc::c_void;
                    }
                    18 => {
                        (*n).data.muldiv = (*relativelow).jump as *mut mln_lang_muldiv_t;
                        (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                    }
                    19 => {
                        (*n).data.not = (*relativelow).jump as *mut mln_lang_not_t;
                        (*n).pos = (*n).data.not as *mut libc::c_void;
                    }
                    20 => {
                        (*n).data.suffix = (*relativelow).jump as *mut mln_lang_suffix_t;
                    }
                    21 => {
                        (*n).data.locate = (*relativelow).jump as *mut mln_lang_locate_t;
                    }
                    22 => {
                        (*n).data.spec = (*relativelow).jump as *mut mln_lang_spec_t;
                    }
                    23 => {
                        (*n).data.factor = (*relativelow).jump as *mut mln_lang_factor_t;
                    }
                    _ => {
                        (*n)
                            .data
                            .elemlist = (*relativelow).jump as *mut mln_lang_elemlist_t;
                    }
                }
            }
            n
        });
        if node.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"Stack is full.\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
            return;
        }
        (mln_lang_stack_map[(*node).type_0 as usize])
            .expect("non-null function pointer")(ctx);
        return;
    } else {
        if (*node).step() as libc::c_int == 1 as libc::c_int {
            (*node).set_step(2 as libc::c_int as mln_u32_t);
            mln_lang_stack_node_get_ctx_ret_var(node, ctx);
        } else if !((*node).step() as libc::c_int == 2 as libc::c_int) {
            let mut handler: mln_lang_op = None;
            let mut method: *mut mln_lang_method_t = 0 as *mut mln_lang_method_t;
            let mut current_block_90: u64;
            if (*node).step() as libc::c_int == 3 as libc::c_int {
                (*node).set_step(4 as libc::c_int as mln_u32_t);
                handler = None;
                method = 0 as *mut mln_lang_method_t;
                method = mln_lang_methods[(*(*(*node).ret_var).val).type_0 as usize];
                if method.is_null() {
                    __mln_lang_errmsg(
                        ctx,
                        b"Operation NOT support.\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                    );
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                match (*relativelow).op as libc::c_uint {
                    1 => {
                        handler = (*method).equal_handler;
                    }
                    2 => {
                        handler = (*method).nonequal_handler;
                    }
                    _ => {}
                }
                if handler.is_none() {
                    __mln_lang_errmsg(
                        ctx,
                        b"Operation NOT support.\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                    );
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                if handler
                    .expect(
                        "non-null function pointer",
                    )(ctx, &mut res, (*node).ret_var, (*ctx).ret_var) < 0 as libc::c_int
                {
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                mln_lang_stack_node_get_ctx_ret_var(node, ctx);
                __mln_lang_ctx_set_ret_var(ctx, res);
                if (*(*res).val).type_0 == 8 as libc::c_int {
                    current_block_90 = 2021600353646938851;
                } else {
                    current_block_90 = 1466397211712759728;
                }
            } else if (*node).step() as libc::c_int == 4 as libc::c_int {
                if (*node).call() != 0 {
                    if mln_lang_withdraw_until_func(ctx) < 0 as libc::c_int {
                        (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                        return;
                    }
                    (*node).set_call(0 as libc::c_int as mln_u32_t);
                    res = (*ctx).ret_var;
                    if (*(*res).val).type_0 == 8 as libc::c_int {
                        current_block_90 = 2021600353646938851;
                    } else {
                        current_block_90 = 1466397211712759728;
                    }
                } else {
                    current_block_90 = 1466397211712759728;
                }
            } else {
                let mut n: *mut mln_lang_stack_node_t = ({
                    let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                    if !n_0.is_null()
                        && {
                            (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                            (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                        }
                    {
                        (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                    }
                    n_0
                });
                if !n.is_null() {
                    if !((*n).ret_var).is_null() {
                        __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                        (*n).ret_var = 0 as *mut mln_lang_var_t;
                    }
                    if !((*n).ret_var2).is_null() {
                        __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                        (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    }
                }
                while !((*ctx).run_stack_top).is_null()
                    && (*(*ctx).run_stack_top).step() as libc::c_int
                        == -(1 as libc::c_int)
                {
                    let mut n: *mut mln_lang_stack_node_t = ({
                        let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                        if !n_0.is_null()
                            && {
                                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                                (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                            }
                        {
                            (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                        }
                        n_0
                    });
                    if !n.is_null() {
                        if !((*n).ret_var).is_null() {
                            __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                            (*n).ret_var = 0 as *mut mln_lang_var_t;
                        }
                        if !((*n).ret_var2).is_null() {
                            __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                            (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                        }
                    }
                }
                current_block_90 = 5658374378798827547;
            }
            match current_block_90 {
                1466397211712759728 => {
                    (*node).pos = (*relativelow).right as *mut libc::c_void;
                    if !((*node).pos).is_null()
                        && (*(*relativelow).right).op as libc::c_uint
                            != M_RELATIVELOW_NONE as libc::c_int as libc::c_uint
                    {
                        (*node).set_step(2 as libc::c_int as mln_u32_t);
                        mln_lang_stack_node_get_ctx_ret_var(node, ctx);
                    } else {
                        let mut n: *mut mln_lang_stack_node_t = ({
                            let mut n_0: *mut mln_lang_stack_node_t = (*ctx)
                                .run_stack_top;
                            if !n_0.is_null()
                                && {
                                    (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                                    (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                                }
                            {
                                (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                            }
                            n_0
                        });
                        if !n.is_null() {
                            if !((*n).ret_var).is_null() {
                                __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                                (*n).ret_var = 0 as *mut mln_lang_var_t;
                            }
                            if !((*n).ret_var2).is_null() {
                                __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                            }
                        }
                        while !((*ctx).run_stack_top).is_null()
                            && (*(*ctx).run_stack_top).step() as libc::c_int
                                == -(1 as libc::c_int)
                        {
                            let mut n: *mut mln_lang_stack_node_t = ({
                                let mut n_0: *mut mln_lang_stack_node_t = (*ctx)
                                    .run_stack_top;
                                if !n_0.is_null()
                                    && {
                                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                                        (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                                    }
                                {
                                    (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                                }
                                n_0
                            });
                            if !n.is_null() {
                                if !((*n).ret_var).is_null() {
                                    __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                                    (*n).ret_var = 0 as *mut mln_lang_var_t;
                                }
                                if !((*n).ret_var2).is_null() {
                                    __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                                }
                            }
                        }
                    }
                }
                2021600353646938851 => {
                    (*node).set_call(1 as libc::c_int as mln_u32_t);
                    if mln_lang_stack_handler_funccall_run(
                        ctx,
                        node,
                        (*(*res).val).data.call,
                    ) < 0 as libc::c_int
                    {
                        (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                        return;
                    }
                }
                _ => {}
            }
            return;
        }
        (*node).set_step(3 as libc::c_int as mln_u32_t);
        tmp = (*relativelow).right;
        node = ({
            let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
            if ((*ctx).run_stack_top).is_null() {
                (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                n = (*ctx).run_stack_top;
            } else if (((*ctx).run_stack_top)
                .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                < 1024 as libc::c_int as libc::c_long
            {
                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                n = (*ctx).run_stack_top;
            }
            if !n.is_null() {
                (*n).type_0 = M_LSNT_RELATIVEHIGH;
                (*n).pos = 0 as *mut libc::c_void;
                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                (*n).ret_var = (*n).ret_var2;
                (*n).set_step(0 as libc::c_int as mln_u32_t);
                (*n).set_call(0 as libc::c_int as mln_u32_t);
                match M_LSNT_RELATIVEHIGH as libc::c_int {
                    0 => {
                        (*n).data.stm = (*tmp).left as *mut mln_lang_stm_t;
                    }
                    1 => {
                        (*n).data.funcdef = (*tmp).left as *mut mln_lang_funcdef_t;
                    }
                    2 => {
                        (*n).data.set = (*tmp).left as *mut mln_lang_set_t;
                    }
                    3 => {
                        (*n).data.set_stm = (*tmp).left as *mut mln_lang_setstm_t;
                    }
                    4 => {
                        (*n).data.block = (*tmp).left as *mut mln_lang_block_t;
                    }
                    5 => {
                        (*n).data.w = (*tmp).left as *mut mln_lang_while_t;
                    }
                    6 => {
                        (*n).data.sw = (*tmp).left as *mut mln_lang_switch_t;
                    }
                    7 => {
                        (*n).data.sw_stm = (*tmp).left as *mut mln_lang_switchstm_t;
                    }
                    8 => {
                        (*n).data.f = (*tmp).left as *mut mln_lang_for_t;
                    }
                    9 => {
                        (*n).data.i = (*tmp).left as *mut mln_lang_if_t;
                    }
                    10 => {
                        (*n).data.exp = (*tmp).left as *mut mln_lang_exp_t;
                    }
                    11 => {
                        (*n).data.assign = (*tmp).left as *mut mln_lang_assign_t;
                    }
                    12 => {
                        (*n).data.logiclow = (*tmp).left as *mut mln_lang_logiclow_t;
                    }
                    13 => {
                        (*n).data.logichigh = (*tmp).left as *mut mln_lang_logichigh_t;
                        (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                    }
                    14 => {
                        (*n)
                            .data
                            .relativelow = (*tmp).left as *mut mln_lang_relativelow_t;
                        (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                    }
                    15 => {
                        (*n).data.relativehigh = (*tmp).left;
                        (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                    }
                    16 => {
                        (*n).data.move_0 = (*tmp).left as *mut mln_lang_move_t;
                        (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                    }
                    17 => {
                        (*n).data.addsub = (*tmp).left as *mut mln_lang_addsub_t;
                        (*n).pos = (*n).data.addsub as *mut libc::c_void;
                    }
                    18 => {
                        (*n).data.muldiv = (*tmp).left as *mut mln_lang_muldiv_t;
                        (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                    }
                    19 => {
                        (*n).data.not = (*tmp).left as *mut mln_lang_not_t;
                        (*n).pos = (*n).data.not as *mut libc::c_void;
                    }
                    20 => {
                        (*n).data.suffix = (*tmp).left as *mut mln_lang_suffix_t;
                    }
                    21 => {
                        (*n).data.locate = (*tmp).left as *mut mln_lang_locate_t;
                    }
                    22 => {
                        (*n).data.spec = (*tmp).left as *mut mln_lang_spec_t;
                    }
                    23 => {
                        (*n).data.factor = (*tmp).left as *mut mln_lang_factor_t;
                    }
                    _ => {
                        (*n).data.elemlist = (*tmp).left as *mut mln_lang_elemlist_t;
                    }
                }
            }
            n
        });
        if node.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"Stack is full.\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
            return;
        }
        (mln_lang_stack_map[(*node).type_0 as usize])
            .expect("non-null function pointer")(ctx);
        return;
    };
}
unsafe extern "C" fn mln_lang_stack_handler_relativehigh(mut ctx: *mut mln_lang_ctx_t) {
    let mut node: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
    let mut tmp: *mut mln_lang_relativehigh_t = 0 as *mut mln_lang_relativehigh_t;
    let mut relativehigh: *mut mln_lang_relativehigh_t = (*node).pos
        as *mut mln_lang_relativehigh_t;
    let mut res: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    if (*node).step() as libc::c_int == 0 as libc::c_int {
        mln_lang_stack_node_reset_ret_val(node);
        mln_lang_ctx_reset_ret_var(ctx);
        if (*relativehigh).op as libc::c_uint
            == M_RELATIVEHIGH_NONE as libc::c_int as libc::c_uint
        {
            (*node).set_step(-(1 as libc::c_int) as mln_u32_t);
        } else {
            (*node).set_step(1 as libc::c_int as mln_u32_t);
        }
        if ((*relativehigh).jump).is_null() {
            mln_lang_generate_jump_ptr(
                relativehigh as *mut libc::c_void,
                M_LSNT_RELATIVEHIGH,
            );
        }
        if (*relativehigh).type_0 == M_LSNT_FACTOR as libc::c_int
            && (*relativehigh).op as libc::c_uint
                == M_RELATIVEHIGH_NONE as libc::c_int as libc::c_uint
        {
            let mut n: *mut mln_lang_stack_node_t = ({
                let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                if !n_0.is_null()
                    && {
                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                        (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                    }
                {
                    (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                }
                n_0
            });
            if !n.is_null() {
                if !((*n).ret_var).is_null() {
                    __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                    (*n).ret_var = 0 as *mut mln_lang_var_t;
                }
                if !((*n).ret_var2).is_null() {
                    __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                }
            }
            while !((*ctx).run_stack_top).is_null()
                && (*(*ctx).run_stack_top).step() as libc::c_int == -(1 as libc::c_int)
            {
                let mut n: *mut mln_lang_stack_node_t = ({
                    let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                    if !n_0.is_null()
                        && {
                            (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                            (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                        }
                    {
                        (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                    }
                    n_0
                });
                if !n.is_null() {
                    if !((*n).ret_var).is_null() {
                        __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                        (*n).ret_var = 0 as *mut mln_lang_var_t;
                    }
                    if !((*n).ret_var2).is_null() {
                        __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                        (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    }
                }
            }
        }
        node = ({
            let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
            if ((*ctx).run_stack_top).is_null() {
                (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                n = (*ctx).run_stack_top;
            } else if (((*ctx).run_stack_top)
                .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                < 1024 as libc::c_int as libc::c_long
            {
                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                n = (*ctx).run_stack_top;
            }
            if !n.is_null() {
                (*n).type_0 = (*relativehigh).type_0 as mln_lang_stack_node_type_t;
                (*n).pos = 0 as *mut libc::c_void;
                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                (*n).ret_var = (*n).ret_var2;
                (*n).set_step(0 as libc::c_int as mln_u32_t);
                (*n).set_call(0 as libc::c_int as mln_u32_t);
                match (*relativehigh).type_0 as mln_lang_stack_node_type_t
                    as libc::c_uint
                {
                    0 => {
                        (*n).data.stm = (*relativehigh).jump as *mut mln_lang_stm_t;
                    }
                    1 => {
                        (*n)
                            .data
                            .funcdef = (*relativehigh).jump as *mut mln_lang_funcdef_t;
                    }
                    2 => {
                        (*n).data.set = (*relativehigh).jump as *mut mln_lang_set_t;
                    }
                    3 => {
                        (*n)
                            .data
                            .set_stm = (*relativehigh).jump as *mut mln_lang_setstm_t;
                    }
                    4 => {
                        (*n).data.block = (*relativehigh).jump as *mut mln_lang_block_t;
                    }
                    5 => {
                        (*n).data.w = (*relativehigh).jump as *mut mln_lang_while_t;
                    }
                    6 => {
                        (*n).data.sw = (*relativehigh).jump as *mut mln_lang_switch_t;
                    }
                    7 => {
                        (*n)
                            .data
                            .sw_stm = (*relativehigh).jump as *mut mln_lang_switchstm_t;
                    }
                    8 => {
                        (*n).data.f = (*relativehigh).jump as *mut mln_lang_for_t;
                    }
                    9 => {
                        (*n).data.i = (*relativehigh).jump as *mut mln_lang_if_t;
                    }
                    10 => {
                        (*n).data.exp = (*relativehigh).jump as *mut mln_lang_exp_t;
                    }
                    11 => {
                        (*n)
                            .data
                            .assign = (*relativehigh).jump as *mut mln_lang_assign_t;
                    }
                    12 => {
                        (*n)
                            .data
                            .logiclow = (*relativehigh).jump as *mut mln_lang_logiclow_t;
                    }
                    13 => {
                        (*n)
                            .data
                            .logichigh = (*relativehigh).jump
                            as *mut mln_lang_logichigh_t;
                        (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                    }
                    14 => {
                        (*n)
                            .data
                            .relativelow = (*relativehigh).jump
                            as *mut mln_lang_relativelow_t;
                        (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                    }
                    15 => {
                        (*n)
                            .data
                            .relativehigh = (*relativehigh).jump
                            as *mut mln_lang_relativehigh_t;
                        (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                    }
                    16 => {
                        (*n).data.move_0 = (*relativehigh).jump as *mut mln_lang_move_t;
                        (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                    }
                    17 => {
                        (*n)
                            .data
                            .addsub = (*relativehigh).jump as *mut mln_lang_addsub_t;
                        (*n).pos = (*n).data.addsub as *mut libc::c_void;
                    }
                    18 => {
                        (*n)
                            .data
                            .muldiv = (*relativehigh).jump as *mut mln_lang_muldiv_t;
                        (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                    }
                    19 => {
                        (*n).data.not = (*relativehigh).jump as *mut mln_lang_not_t;
                        (*n).pos = (*n).data.not as *mut libc::c_void;
                    }
                    20 => {
                        (*n)
                            .data
                            .suffix = (*relativehigh).jump as *mut mln_lang_suffix_t;
                    }
                    21 => {
                        (*n)
                            .data
                            .locate = (*relativehigh).jump as *mut mln_lang_locate_t;
                    }
                    22 => {
                        (*n).data.spec = (*relativehigh).jump as *mut mln_lang_spec_t;
                    }
                    23 => {
                        (*n)
                            .data
                            .factor = (*relativehigh).jump as *mut mln_lang_factor_t;
                    }
                    _ => {
                        (*n)
                            .data
                            .elemlist = (*relativehigh).jump as *mut mln_lang_elemlist_t;
                    }
                }
            }
            n
        });
        if node.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"Stack is full.\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
            return;
        }
        (mln_lang_stack_map[(*node).type_0 as usize])
            .expect("non-null function pointer")(ctx);
        return;
    } else {
        if (*node).step() as libc::c_int == 1 as libc::c_int {
            (*node).set_step(2 as libc::c_int as mln_u32_t);
            mln_lang_stack_node_get_ctx_ret_var(node, ctx);
        } else if !((*node).step() as libc::c_int == 2 as libc::c_int) {
            let mut handler: mln_lang_op = None;
            let mut method: *mut mln_lang_method_t = 0 as *mut mln_lang_method_t;
            let mut current_block_92: u64;
            if (*node).step() as libc::c_int == 3 as libc::c_int {
                (*node).set_step(4 as libc::c_int as mln_u32_t);
                handler = None;
                method = 0 as *mut mln_lang_method_t;
                method = mln_lang_methods[(*(*(*node).ret_var).val).type_0 as usize];
                if method.is_null() {
                    __mln_lang_errmsg(
                        ctx,
                        b"Operation NOT support.\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                    );
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                match (*relativehigh).op as libc::c_uint {
                    1 => {
                        handler = (*method).less_handler;
                    }
                    2 => {
                        handler = (*method).lesseq_handler;
                    }
                    3 => {
                        handler = (*method).grea_handler;
                    }
                    4 => {
                        handler = (*method).greale_handler;
                    }
                    _ => {}
                }
                if handler.is_none() {
                    __mln_lang_errmsg(
                        ctx,
                        b"Operation NOT support.\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                    );
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                if handler
                    .expect(
                        "non-null function pointer",
                    )(ctx, &mut res, (*node).ret_var, (*ctx).ret_var) < 0 as libc::c_int
                {
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                mln_lang_stack_node_get_ctx_ret_var(node, ctx);
                __mln_lang_ctx_set_ret_var(ctx, res);
                if (*(*res).val).type_0 == 8 as libc::c_int {
                    current_block_92 = 9358705795425424674;
                } else {
                    current_block_92 = 12169902218863630677;
                }
            } else if (*node).step() as libc::c_int == 4 as libc::c_int {
                if (*node).call() != 0 {
                    if mln_lang_withdraw_until_func(ctx) < 0 as libc::c_int {
                        (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                        return;
                    }
                    (*node).set_call(0 as libc::c_int as mln_u32_t);
                    res = (*ctx).ret_var;
                    if (*(*res).val).type_0 == 8 as libc::c_int {
                        current_block_92 = 9358705795425424674;
                    } else {
                        current_block_92 = 12169902218863630677;
                    }
                } else {
                    current_block_92 = 12169902218863630677;
                }
            } else {
                let mut n: *mut mln_lang_stack_node_t = ({
                    let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                    if !n_0.is_null()
                        && {
                            (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                            (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                        }
                    {
                        (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                    }
                    n_0
                });
                if !n.is_null() {
                    if !((*n).ret_var).is_null() {
                        __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                        (*n).ret_var = 0 as *mut mln_lang_var_t;
                    }
                    if !((*n).ret_var2).is_null() {
                        __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                        (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    }
                }
                while !((*ctx).run_stack_top).is_null()
                    && (*(*ctx).run_stack_top).step() as libc::c_int
                        == -(1 as libc::c_int)
                {
                    let mut n: *mut mln_lang_stack_node_t = ({
                        let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                        if !n_0.is_null()
                            && {
                                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                                (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                            }
                        {
                            (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                        }
                        n_0
                    });
                    if !n.is_null() {
                        if !((*n).ret_var).is_null() {
                            __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                            (*n).ret_var = 0 as *mut mln_lang_var_t;
                        }
                        if !((*n).ret_var2).is_null() {
                            __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                            (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                        }
                    }
                }
                current_block_92 = 16231175055492490595;
            }
            match current_block_92 {
                12169902218863630677 => {
                    (*node).pos = (*relativehigh).right as *mut libc::c_void;
                    if !((*node).pos).is_null()
                        && (*(*relativehigh).right).op as libc::c_uint
                            != M_RELATIVEHIGH_NONE as libc::c_int as libc::c_uint
                    {
                        (*node).set_step(2 as libc::c_int as mln_u32_t);
                        mln_lang_stack_node_get_ctx_ret_var(node, ctx);
                    } else {
                        let mut n: *mut mln_lang_stack_node_t = ({
                            let mut n_0: *mut mln_lang_stack_node_t = (*ctx)
                                .run_stack_top;
                            if !n_0.is_null()
                                && {
                                    (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                                    (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                                }
                            {
                                (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                            }
                            n_0
                        });
                        if !n.is_null() {
                            if !((*n).ret_var).is_null() {
                                __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                                (*n).ret_var = 0 as *mut mln_lang_var_t;
                            }
                            if !((*n).ret_var2).is_null() {
                                __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                            }
                        }
                        while !((*ctx).run_stack_top).is_null()
                            && (*(*ctx).run_stack_top).step() as libc::c_int
                                == -(1 as libc::c_int)
                        {
                            let mut n: *mut mln_lang_stack_node_t = ({
                                let mut n_0: *mut mln_lang_stack_node_t = (*ctx)
                                    .run_stack_top;
                                if !n_0.is_null()
                                    && {
                                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                                        (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                                    }
                                {
                                    (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                                }
                                n_0
                            });
                            if !n.is_null() {
                                if !((*n).ret_var).is_null() {
                                    __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                                    (*n).ret_var = 0 as *mut mln_lang_var_t;
                                }
                                if !((*n).ret_var2).is_null() {
                                    __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                                }
                            }
                        }
                    }
                }
                9358705795425424674 => {
                    (*node).set_call(1 as libc::c_int as mln_u32_t);
                    if mln_lang_stack_handler_funccall_run(
                        ctx,
                        node,
                        (*(*res).val).data.call,
                    ) < 0 as libc::c_int
                    {
                        (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                        return;
                    }
                }
                _ => {}
            }
            return;
        }
        (*node).set_step(3 as libc::c_int as mln_u32_t);
        tmp = (*relativehigh).right;
        node = ({
            let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
            if ((*ctx).run_stack_top).is_null() {
                (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                n = (*ctx).run_stack_top;
            } else if (((*ctx).run_stack_top)
                .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                < 1024 as libc::c_int as libc::c_long
            {
                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                n = (*ctx).run_stack_top;
            }
            if !n.is_null() {
                (*n).type_0 = M_LSNT_MOVE;
                (*n).pos = 0 as *mut libc::c_void;
                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                (*n).ret_var = (*n).ret_var2;
                (*n).set_step(0 as libc::c_int as mln_u32_t);
                (*n).set_call(0 as libc::c_int as mln_u32_t);
                match M_LSNT_MOVE as libc::c_int {
                    0 => {
                        (*n).data.stm = (*tmp).left as *mut mln_lang_stm_t;
                    }
                    1 => {
                        (*n).data.funcdef = (*tmp).left as *mut mln_lang_funcdef_t;
                    }
                    2 => {
                        (*n).data.set = (*tmp).left as *mut mln_lang_set_t;
                    }
                    3 => {
                        (*n).data.set_stm = (*tmp).left as *mut mln_lang_setstm_t;
                    }
                    4 => {
                        (*n).data.block = (*tmp).left as *mut mln_lang_block_t;
                    }
                    5 => {
                        (*n).data.w = (*tmp).left as *mut mln_lang_while_t;
                    }
                    6 => {
                        (*n).data.sw = (*tmp).left as *mut mln_lang_switch_t;
                    }
                    7 => {
                        (*n).data.sw_stm = (*tmp).left as *mut mln_lang_switchstm_t;
                    }
                    8 => {
                        (*n).data.f = (*tmp).left as *mut mln_lang_for_t;
                    }
                    9 => {
                        (*n).data.i = (*tmp).left as *mut mln_lang_if_t;
                    }
                    10 => {
                        (*n).data.exp = (*tmp).left as *mut mln_lang_exp_t;
                    }
                    11 => {
                        (*n).data.assign = (*tmp).left as *mut mln_lang_assign_t;
                    }
                    12 => {
                        (*n).data.logiclow = (*tmp).left as *mut mln_lang_logiclow_t;
                    }
                    13 => {
                        (*n).data.logichigh = (*tmp).left as *mut mln_lang_logichigh_t;
                        (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                    }
                    14 => {
                        (*n)
                            .data
                            .relativelow = (*tmp).left as *mut mln_lang_relativelow_t;
                        (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                    }
                    15 => {
                        (*n)
                            .data
                            .relativehigh = (*tmp).left as *mut mln_lang_relativehigh_t;
                        (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                    }
                    16 => {
                        (*n).data.move_0 = (*tmp).left;
                        (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                    }
                    17 => {
                        (*n).data.addsub = (*tmp).left as *mut mln_lang_addsub_t;
                        (*n).pos = (*n).data.addsub as *mut libc::c_void;
                    }
                    18 => {
                        (*n).data.muldiv = (*tmp).left as *mut mln_lang_muldiv_t;
                        (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                    }
                    19 => {
                        (*n).data.not = (*tmp).left as *mut mln_lang_not_t;
                        (*n).pos = (*n).data.not as *mut libc::c_void;
                    }
                    20 => {
                        (*n).data.suffix = (*tmp).left as *mut mln_lang_suffix_t;
                    }
                    21 => {
                        (*n).data.locate = (*tmp).left as *mut mln_lang_locate_t;
                    }
                    22 => {
                        (*n).data.spec = (*tmp).left as *mut mln_lang_spec_t;
                    }
                    23 => {
                        (*n).data.factor = (*tmp).left as *mut mln_lang_factor_t;
                    }
                    _ => {
                        (*n).data.elemlist = (*tmp).left as *mut mln_lang_elemlist_t;
                    }
                }
            }
            n
        });
        if node.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"Stack is full.\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
            return;
        }
        (mln_lang_stack_map[(*node).type_0 as usize])
            .expect("non-null function pointer")(ctx);
        return;
    };
}
unsafe extern "C" fn mln_lang_stack_handler_move(mut ctx: *mut mln_lang_ctx_t) {
    let mut node: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
    let mut tmp: *mut mln_lang_move_t = 0 as *mut mln_lang_move_t;
    let mut move_0: *mut mln_lang_move_t = (*node).pos as *mut mln_lang_move_t;
    let mut res: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    if (*node).step() as libc::c_int == 0 as libc::c_int {
        mln_lang_stack_node_reset_ret_val(node);
        mln_lang_ctx_reset_ret_var(ctx);
        if (*move_0).op as libc::c_uint == M_MOVE_NONE as libc::c_int as libc::c_uint {
            (*node).set_step(-(1 as libc::c_int) as mln_u32_t);
        } else {
            (*node).set_step(1 as libc::c_int as mln_u32_t);
        }
        if ((*move_0).jump).is_null() {
            mln_lang_generate_jump_ptr(move_0 as *mut libc::c_void, M_LSNT_MOVE);
        }
        if (*move_0).type_0 == M_LSNT_FACTOR as libc::c_int
            && (*move_0).op as libc::c_uint == M_MOVE_NONE as libc::c_int as libc::c_uint
        {
            let mut n: *mut mln_lang_stack_node_t = ({
                let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                if !n_0.is_null()
                    && {
                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                        (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                    }
                {
                    (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                }
                n_0
            });
            if !n.is_null() {
                if !((*n).ret_var).is_null() {
                    __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                    (*n).ret_var = 0 as *mut mln_lang_var_t;
                }
                if !((*n).ret_var2).is_null() {
                    __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                }
            }
            while !((*ctx).run_stack_top).is_null()
                && (*(*ctx).run_stack_top).step() as libc::c_int == -(1 as libc::c_int)
            {
                let mut n: *mut mln_lang_stack_node_t = ({
                    let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                    if !n_0.is_null()
                        && {
                            (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                            (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                        }
                    {
                        (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                    }
                    n_0
                });
                if !n.is_null() {
                    if !((*n).ret_var).is_null() {
                        __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                        (*n).ret_var = 0 as *mut mln_lang_var_t;
                    }
                    if !((*n).ret_var2).is_null() {
                        __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                        (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    }
                }
            }
        }
        node = ({
            let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
            if ((*ctx).run_stack_top).is_null() {
                (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                n = (*ctx).run_stack_top;
            } else if (((*ctx).run_stack_top)
                .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                < 1024 as libc::c_int as libc::c_long
            {
                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                n = (*ctx).run_stack_top;
            }
            if !n.is_null() {
                (*n).type_0 = (*move_0).type_0 as mln_lang_stack_node_type_t;
                (*n).pos = 0 as *mut libc::c_void;
                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                (*n).ret_var = (*n).ret_var2;
                (*n).set_step(0 as libc::c_int as mln_u32_t);
                (*n).set_call(0 as libc::c_int as mln_u32_t);
                match (*move_0).type_0 as mln_lang_stack_node_type_t as libc::c_uint {
                    0 => {
                        (*n).data.stm = (*move_0).jump as *mut mln_lang_stm_t;
                    }
                    1 => {
                        (*n).data.funcdef = (*move_0).jump as *mut mln_lang_funcdef_t;
                    }
                    2 => {
                        (*n).data.set = (*move_0).jump as *mut mln_lang_set_t;
                    }
                    3 => {
                        (*n).data.set_stm = (*move_0).jump as *mut mln_lang_setstm_t;
                    }
                    4 => {
                        (*n).data.block = (*move_0).jump as *mut mln_lang_block_t;
                    }
                    5 => {
                        (*n).data.w = (*move_0).jump as *mut mln_lang_while_t;
                    }
                    6 => {
                        (*n).data.sw = (*move_0).jump as *mut mln_lang_switch_t;
                    }
                    7 => {
                        (*n).data.sw_stm = (*move_0).jump as *mut mln_lang_switchstm_t;
                    }
                    8 => {
                        (*n).data.f = (*move_0).jump as *mut mln_lang_for_t;
                    }
                    9 => {
                        (*n).data.i = (*move_0).jump as *mut mln_lang_if_t;
                    }
                    10 => {
                        (*n).data.exp = (*move_0).jump as *mut mln_lang_exp_t;
                    }
                    11 => {
                        (*n).data.assign = (*move_0).jump as *mut mln_lang_assign_t;
                    }
                    12 => {
                        (*n).data.logiclow = (*move_0).jump as *mut mln_lang_logiclow_t;
                    }
                    13 => {
                        (*n)
                            .data
                            .logichigh = (*move_0).jump as *mut mln_lang_logichigh_t;
                        (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                    }
                    14 => {
                        (*n)
                            .data
                            .relativelow = (*move_0).jump as *mut mln_lang_relativelow_t;
                        (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                    }
                    15 => {
                        (*n)
                            .data
                            .relativehigh = (*move_0).jump
                            as *mut mln_lang_relativehigh_t;
                        (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                    }
                    16 => {
                        (*n).data.move_0 = (*move_0).jump as *mut mln_lang_move_t;
                        (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                    }
                    17 => {
                        (*n).data.addsub = (*move_0).jump as *mut mln_lang_addsub_t;
                        (*n).pos = (*n).data.addsub as *mut libc::c_void;
                    }
                    18 => {
                        (*n).data.muldiv = (*move_0).jump as *mut mln_lang_muldiv_t;
                        (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                    }
                    19 => {
                        (*n).data.not = (*move_0).jump as *mut mln_lang_not_t;
                        (*n).pos = (*n).data.not as *mut libc::c_void;
                    }
                    20 => {
                        (*n).data.suffix = (*move_0).jump as *mut mln_lang_suffix_t;
                    }
                    21 => {
                        (*n).data.locate = (*move_0).jump as *mut mln_lang_locate_t;
                    }
                    22 => {
                        (*n).data.spec = (*move_0).jump as *mut mln_lang_spec_t;
                    }
                    23 => {
                        (*n).data.factor = (*move_0).jump as *mut mln_lang_factor_t;
                    }
                    _ => {
                        (*n).data.elemlist = (*move_0).jump as *mut mln_lang_elemlist_t;
                    }
                }
            }
            n
        });
        if node.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"Stack is full.\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
            return;
        }
        (mln_lang_stack_map[(*node).type_0 as usize])
            .expect("non-null function pointer")(ctx);
        return;
    } else {
        if (*node).step() as libc::c_int == 1 as libc::c_int {
            (*node).set_step(2 as libc::c_int as mln_u32_t);
            mln_lang_stack_node_get_ctx_ret_var(node, ctx);
        } else if !((*node).step() as libc::c_int == 2 as libc::c_int) {
            let mut handler: mln_lang_op = None;
            let mut method: *mut mln_lang_method_t = 0 as *mut mln_lang_method_t;
            let mut current_block_90: u64;
            if (*node).step() as libc::c_int == 3 as libc::c_int {
                (*node).set_step(4 as libc::c_int as mln_u32_t);
                handler = None;
                method = 0 as *mut mln_lang_method_t;
                method = mln_lang_methods[(*(*(*node).ret_var).val).type_0 as usize];
                if method.is_null() {
                    __mln_lang_errmsg(
                        ctx,
                        b"Operation NOT support.\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                    );
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                match (*move_0).op as libc::c_uint {
                    1 => {
                        handler = (*method).lmov_handler;
                    }
                    2 => {
                        handler = (*method).rmov_handler;
                    }
                    _ => {}
                }
                if handler.is_none() {
                    __mln_lang_errmsg(
                        ctx,
                        b"Operation NOT support.\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                    );
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                if handler
                    .expect(
                        "non-null function pointer",
                    )(ctx, &mut res, (*node).ret_var, (*ctx).ret_var) < 0 as libc::c_int
                {
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                mln_lang_stack_node_get_ctx_ret_var(node, ctx);
                __mln_lang_ctx_set_ret_var(ctx, res);
                if (*(*res).val).type_0 == 8 as libc::c_int {
                    current_block_90 = 10366808504357195930;
                } else {
                    current_block_90 = 11921141332467440075;
                }
            } else if (*node).step() as libc::c_int == 4 as libc::c_int {
                if (*node).call() != 0 {
                    if mln_lang_withdraw_until_func(ctx) < 0 as libc::c_int {
                        (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                        return;
                    }
                    (*node).set_call(0 as libc::c_int as mln_u32_t);
                    res = (*ctx).ret_var;
                    if (*(*res).val).type_0 == 8 as libc::c_int {
                        current_block_90 = 10366808504357195930;
                    } else {
                        current_block_90 = 11921141332467440075;
                    }
                } else {
                    current_block_90 = 11921141332467440075;
                }
            } else {
                let mut n: *mut mln_lang_stack_node_t = ({
                    let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                    if !n_0.is_null()
                        && {
                            (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                            (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                        }
                    {
                        (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                    }
                    n_0
                });
                if !n.is_null() {
                    if !((*n).ret_var).is_null() {
                        __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                        (*n).ret_var = 0 as *mut mln_lang_var_t;
                    }
                    if !((*n).ret_var2).is_null() {
                        __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                        (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    }
                }
                while !((*ctx).run_stack_top).is_null()
                    && (*(*ctx).run_stack_top).step() as libc::c_int
                        == -(1 as libc::c_int)
                {
                    let mut n: *mut mln_lang_stack_node_t = ({
                        let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                        if !n_0.is_null()
                            && {
                                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                                (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                            }
                        {
                            (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                        }
                        n_0
                    });
                    if !n.is_null() {
                        if !((*n).ret_var).is_null() {
                            __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                            (*n).ret_var = 0 as *mut mln_lang_var_t;
                        }
                        if !((*n).ret_var2).is_null() {
                            __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                            (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                        }
                    }
                }
                current_block_90 = 5658374378798827547;
            }
            match current_block_90 {
                11921141332467440075 => {
                    (*node).pos = (*move_0).right as *mut libc::c_void;
                    if !((*node).pos).is_null()
                        && (*(*move_0).right).op as libc::c_uint
                            != M_MOVE_NONE as libc::c_int as libc::c_uint
                    {
                        (*node).set_step(2 as libc::c_int as mln_u32_t);
                        mln_lang_stack_node_get_ctx_ret_var(node, ctx);
                    } else {
                        let mut n: *mut mln_lang_stack_node_t = ({
                            let mut n_0: *mut mln_lang_stack_node_t = (*ctx)
                                .run_stack_top;
                            if !n_0.is_null()
                                && {
                                    (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                                    (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                                }
                            {
                                (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                            }
                            n_0
                        });
                        if !n.is_null() {
                            if !((*n).ret_var).is_null() {
                                __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                                (*n).ret_var = 0 as *mut mln_lang_var_t;
                            }
                            if !((*n).ret_var2).is_null() {
                                __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                            }
                        }
                        while !((*ctx).run_stack_top).is_null()
                            && (*(*ctx).run_stack_top).step() as libc::c_int
                                == -(1 as libc::c_int)
                        {
                            let mut n: *mut mln_lang_stack_node_t = ({
                                let mut n_0: *mut mln_lang_stack_node_t = (*ctx)
                                    .run_stack_top;
                                if !n_0.is_null()
                                    && {
                                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                                        (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                                    }
                                {
                                    (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                                }
                                n_0
                            });
                            if !n.is_null() {
                                if !((*n).ret_var).is_null() {
                                    __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                                    (*n).ret_var = 0 as *mut mln_lang_var_t;
                                }
                                if !((*n).ret_var2).is_null() {
                                    __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                                }
                            }
                        }
                    }
                }
                10366808504357195930 => {
                    (*node).set_call(1 as libc::c_int as mln_u32_t);
                    if mln_lang_stack_handler_funccall_run(
                        ctx,
                        node,
                        (*(*res).val).data.call,
                    ) < 0 as libc::c_int
                    {
                        (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                        return;
                    }
                }
                _ => {}
            }
            return;
        }
        (*node).set_step(3 as libc::c_int as mln_u32_t);
        tmp = (*move_0).right;
        node = ({
            let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
            if ((*ctx).run_stack_top).is_null() {
                (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                n = (*ctx).run_stack_top;
            } else if (((*ctx).run_stack_top)
                .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                < 1024 as libc::c_int as libc::c_long
            {
                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                n = (*ctx).run_stack_top;
            }
            if !n.is_null() {
                (*n).type_0 = M_LSNT_ADDSUB;
                (*n).pos = 0 as *mut libc::c_void;
                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                (*n).ret_var = (*n).ret_var2;
                (*n).set_step(0 as libc::c_int as mln_u32_t);
                (*n).set_call(0 as libc::c_int as mln_u32_t);
                match M_LSNT_ADDSUB as libc::c_int {
                    0 => {
                        (*n).data.stm = (*tmp).left as *mut mln_lang_stm_t;
                    }
                    1 => {
                        (*n).data.funcdef = (*tmp).left as *mut mln_lang_funcdef_t;
                    }
                    2 => {
                        (*n).data.set = (*tmp).left as *mut mln_lang_set_t;
                    }
                    3 => {
                        (*n).data.set_stm = (*tmp).left as *mut mln_lang_setstm_t;
                    }
                    4 => {
                        (*n).data.block = (*tmp).left as *mut mln_lang_block_t;
                    }
                    5 => {
                        (*n).data.w = (*tmp).left as *mut mln_lang_while_t;
                    }
                    6 => {
                        (*n).data.sw = (*tmp).left as *mut mln_lang_switch_t;
                    }
                    7 => {
                        (*n).data.sw_stm = (*tmp).left as *mut mln_lang_switchstm_t;
                    }
                    8 => {
                        (*n).data.f = (*tmp).left as *mut mln_lang_for_t;
                    }
                    9 => {
                        (*n).data.i = (*tmp).left as *mut mln_lang_if_t;
                    }
                    10 => {
                        (*n).data.exp = (*tmp).left as *mut mln_lang_exp_t;
                    }
                    11 => {
                        (*n).data.assign = (*tmp).left as *mut mln_lang_assign_t;
                    }
                    12 => {
                        (*n).data.logiclow = (*tmp).left as *mut mln_lang_logiclow_t;
                    }
                    13 => {
                        (*n).data.logichigh = (*tmp).left as *mut mln_lang_logichigh_t;
                        (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                    }
                    14 => {
                        (*n)
                            .data
                            .relativelow = (*tmp).left as *mut mln_lang_relativelow_t;
                        (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                    }
                    15 => {
                        (*n)
                            .data
                            .relativehigh = (*tmp).left as *mut mln_lang_relativehigh_t;
                        (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                    }
                    16 => {
                        (*n).data.move_0 = (*tmp).left as *mut mln_lang_move_t;
                        (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                    }
                    17 => {
                        (*n).data.addsub = (*tmp).left;
                        (*n).pos = (*n).data.addsub as *mut libc::c_void;
                    }
                    18 => {
                        (*n).data.muldiv = (*tmp).left as *mut mln_lang_muldiv_t;
                        (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                    }
                    19 => {
                        (*n).data.not = (*tmp).left as *mut mln_lang_not_t;
                        (*n).pos = (*n).data.not as *mut libc::c_void;
                    }
                    20 => {
                        (*n).data.suffix = (*tmp).left as *mut mln_lang_suffix_t;
                    }
                    21 => {
                        (*n).data.locate = (*tmp).left as *mut mln_lang_locate_t;
                    }
                    22 => {
                        (*n).data.spec = (*tmp).left as *mut mln_lang_spec_t;
                    }
                    23 => {
                        (*n).data.factor = (*tmp).left as *mut mln_lang_factor_t;
                    }
                    _ => {
                        (*n).data.elemlist = (*tmp).left as *mut mln_lang_elemlist_t;
                    }
                }
            }
            n
        });
        if node.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"Stack is full.\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
            return;
        }
        (mln_lang_stack_map[(*node).type_0 as usize])
            .expect("non-null function pointer")(ctx);
        return;
    };
}
unsafe extern "C" fn mln_lang_stack_handler_addsub(mut ctx: *mut mln_lang_ctx_t) {
    let mut node: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
    let mut tmp: *mut mln_lang_addsub_t = 0 as *mut mln_lang_addsub_t;
    let mut addsub: *mut mln_lang_addsub_t = (*node).pos as *mut mln_lang_addsub_t;
    let mut res: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    if (*node).step() as libc::c_int == 0 as libc::c_int {
        mln_lang_stack_node_reset_ret_val(node);
        mln_lang_ctx_reset_ret_var(ctx);
        if (*addsub).op as libc::c_uint == M_ADDSUB_NONE as libc::c_int as libc::c_uint {
            (*node).set_step(-(1 as libc::c_int) as mln_u32_t);
        } else {
            (*node).set_step(1 as libc::c_int as mln_u32_t);
        }
        if ((*addsub).jump).is_null() {
            mln_lang_generate_jump_ptr(addsub as *mut libc::c_void, M_LSNT_ADDSUB);
        }
        if (*addsub).type_0 == M_LSNT_FACTOR as libc::c_int
            && (*addsub).op as libc::c_uint
                == M_ADDSUB_NONE as libc::c_int as libc::c_uint
        {
            let mut n: *mut mln_lang_stack_node_t = ({
                let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                if !n_0.is_null()
                    && {
                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                        (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                    }
                {
                    (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                }
                n_0
            });
            if !n.is_null() {
                if !((*n).ret_var).is_null() {
                    __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                    (*n).ret_var = 0 as *mut mln_lang_var_t;
                }
                if !((*n).ret_var2).is_null() {
                    __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                }
            }
            while !((*ctx).run_stack_top).is_null()
                && (*(*ctx).run_stack_top).step() as libc::c_int == -(1 as libc::c_int)
            {
                let mut n: *mut mln_lang_stack_node_t = ({
                    let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                    if !n_0.is_null()
                        && {
                            (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                            (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                        }
                    {
                        (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                    }
                    n_0
                });
                if !n.is_null() {
                    if !((*n).ret_var).is_null() {
                        __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                        (*n).ret_var = 0 as *mut mln_lang_var_t;
                    }
                    if !((*n).ret_var2).is_null() {
                        __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                        (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    }
                }
            }
        }
        node = ({
            let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
            if ((*ctx).run_stack_top).is_null() {
                (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                n = (*ctx).run_stack_top;
            } else if (((*ctx).run_stack_top)
                .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                < 1024 as libc::c_int as libc::c_long
            {
                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                n = (*ctx).run_stack_top;
            }
            if !n.is_null() {
                (*n).type_0 = (*addsub).type_0 as mln_lang_stack_node_type_t;
                (*n).pos = 0 as *mut libc::c_void;
                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                (*n).ret_var = (*n).ret_var2;
                (*n).set_step(0 as libc::c_int as mln_u32_t);
                (*n).set_call(0 as libc::c_int as mln_u32_t);
                match (*addsub).type_0 as mln_lang_stack_node_type_t as libc::c_uint {
                    0 => {
                        (*n).data.stm = (*addsub).jump as *mut mln_lang_stm_t;
                    }
                    1 => {
                        (*n).data.funcdef = (*addsub).jump as *mut mln_lang_funcdef_t;
                    }
                    2 => {
                        (*n).data.set = (*addsub).jump as *mut mln_lang_set_t;
                    }
                    3 => {
                        (*n).data.set_stm = (*addsub).jump as *mut mln_lang_setstm_t;
                    }
                    4 => {
                        (*n).data.block = (*addsub).jump as *mut mln_lang_block_t;
                    }
                    5 => {
                        (*n).data.w = (*addsub).jump as *mut mln_lang_while_t;
                    }
                    6 => {
                        (*n).data.sw = (*addsub).jump as *mut mln_lang_switch_t;
                    }
                    7 => {
                        (*n).data.sw_stm = (*addsub).jump as *mut mln_lang_switchstm_t;
                    }
                    8 => {
                        (*n).data.f = (*addsub).jump as *mut mln_lang_for_t;
                    }
                    9 => {
                        (*n).data.i = (*addsub).jump as *mut mln_lang_if_t;
                    }
                    10 => {
                        (*n).data.exp = (*addsub).jump as *mut mln_lang_exp_t;
                    }
                    11 => {
                        (*n).data.assign = (*addsub).jump as *mut mln_lang_assign_t;
                    }
                    12 => {
                        (*n).data.logiclow = (*addsub).jump as *mut mln_lang_logiclow_t;
                    }
                    13 => {
                        (*n)
                            .data
                            .logichigh = (*addsub).jump as *mut mln_lang_logichigh_t;
                        (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                    }
                    14 => {
                        (*n)
                            .data
                            .relativelow = (*addsub).jump as *mut mln_lang_relativelow_t;
                        (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                    }
                    15 => {
                        (*n)
                            .data
                            .relativehigh = (*addsub).jump
                            as *mut mln_lang_relativehigh_t;
                        (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                    }
                    16 => {
                        (*n).data.move_0 = (*addsub).jump as *mut mln_lang_move_t;
                        (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                    }
                    17 => {
                        (*n).data.addsub = (*addsub).jump as *mut mln_lang_addsub_t;
                        (*n).pos = (*n).data.addsub as *mut libc::c_void;
                    }
                    18 => {
                        (*n).data.muldiv = (*addsub).jump as *mut mln_lang_muldiv_t;
                        (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                    }
                    19 => {
                        (*n).data.not = (*addsub).jump as *mut mln_lang_not_t;
                        (*n).pos = (*n).data.not as *mut libc::c_void;
                    }
                    20 => {
                        (*n).data.suffix = (*addsub).jump as *mut mln_lang_suffix_t;
                    }
                    21 => {
                        (*n).data.locate = (*addsub).jump as *mut mln_lang_locate_t;
                    }
                    22 => {
                        (*n).data.spec = (*addsub).jump as *mut mln_lang_spec_t;
                    }
                    23 => {
                        (*n).data.factor = (*addsub).jump as *mut mln_lang_factor_t;
                    }
                    _ => {
                        (*n).data.elemlist = (*addsub).jump as *mut mln_lang_elemlist_t;
                    }
                }
            }
            n
        });
        if node.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"Stack is full.\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
            return;
        }
        (mln_lang_stack_map[(*node).type_0 as usize])
            .expect("non-null function pointer")(ctx);
        return;
    } else {
        if (*node).step() as libc::c_int == 1 as libc::c_int {
            (*node).set_step(2 as libc::c_int as mln_u32_t);
            mln_lang_stack_node_get_ctx_ret_var(node, ctx);
        } else if !((*node).step() as libc::c_int == 2 as libc::c_int) {
            let mut handler: mln_lang_op = None;
            let mut method: *mut mln_lang_method_t = 0 as *mut mln_lang_method_t;
            let mut current_block_90: u64;
            if (*node).step() as libc::c_int == 3 as libc::c_int {
                (*node).set_step(4 as libc::c_int as mln_u32_t);
                handler = None;
                method = 0 as *mut mln_lang_method_t;
                method = mln_lang_methods[(*(*(*node).ret_var).val).type_0 as usize];
                if method.is_null() {
                    __mln_lang_errmsg(
                        ctx,
                        b"Operation NOT support.\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                    );
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                match (*addsub).op as libc::c_uint {
                    1 => {
                        handler = (*method).plus_handler;
                    }
                    2 => {
                        handler = (*method).sub_handler;
                    }
                    _ => {}
                }
                if handler.is_none() {
                    __mln_lang_errmsg(
                        ctx,
                        b"Operation NOT support.\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                    );
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                if handler
                    .expect(
                        "non-null function pointer",
                    )(ctx, &mut res, (*node).ret_var, (*ctx).ret_var) < 0 as libc::c_int
                {
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                mln_lang_stack_node_get_ctx_ret_var(node, ctx);
                __mln_lang_ctx_set_ret_var(ctx, res);
                if (*(*res).val).type_0 == 8 as libc::c_int {
                    current_block_90 = 6797081956882827194;
                } else {
                    current_block_90 = 8066038403347099398;
                }
            } else if (*node).step() as libc::c_int == 4 as libc::c_int {
                if (*node).call() != 0 {
                    if mln_lang_withdraw_until_func(ctx) < 0 as libc::c_int {
                        (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                        return;
                    }
                    (*node).set_call(0 as libc::c_int as mln_u32_t);
                    res = (*ctx).ret_var;
                    if (*(*res).val).type_0 == 8 as libc::c_int {
                        current_block_90 = 6797081956882827194;
                    } else {
                        current_block_90 = 8066038403347099398;
                    }
                } else {
                    current_block_90 = 8066038403347099398;
                }
            } else {
                let mut n: *mut mln_lang_stack_node_t = ({
                    let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                    if !n_0.is_null()
                        && {
                            (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                            (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                        }
                    {
                        (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                    }
                    n_0
                });
                if !n.is_null() {
                    if !((*n).ret_var).is_null() {
                        __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                        (*n).ret_var = 0 as *mut mln_lang_var_t;
                    }
                    if !((*n).ret_var2).is_null() {
                        __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                        (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    }
                }
                while !((*ctx).run_stack_top).is_null()
                    && (*(*ctx).run_stack_top).step() as libc::c_int
                        == -(1 as libc::c_int)
                {
                    let mut n: *mut mln_lang_stack_node_t = ({
                        let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                        if !n_0.is_null()
                            && {
                                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                                (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                            }
                        {
                            (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                        }
                        n_0
                    });
                    if !n.is_null() {
                        if !((*n).ret_var).is_null() {
                            __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                            (*n).ret_var = 0 as *mut mln_lang_var_t;
                        }
                        if !((*n).ret_var2).is_null() {
                            __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                            (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                        }
                    }
                }
                current_block_90 = 5658374378798827547;
            }
            match current_block_90 {
                8066038403347099398 => {
                    (*node).pos = (*addsub).right as *mut libc::c_void;
                    if !((*node).pos).is_null()
                        && (*(*addsub).right).op as libc::c_uint
                            != M_ADDSUB_NONE as libc::c_int as libc::c_uint
                    {
                        (*node).set_step(2 as libc::c_int as mln_u32_t);
                        mln_lang_stack_node_get_ctx_ret_var(node, ctx);
                    } else {
                        let mut n: *mut mln_lang_stack_node_t = ({
                            let mut n_0: *mut mln_lang_stack_node_t = (*ctx)
                                .run_stack_top;
                            if !n_0.is_null()
                                && {
                                    (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                                    (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                                }
                            {
                                (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                            }
                            n_0
                        });
                        if !n.is_null() {
                            if !((*n).ret_var).is_null() {
                                __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                                (*n).ret_var = 0 as *mut mln_lang_var_t;
                            }
                            if !((*n).ret_var2).is_null() {
                                __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                            }
                        }
                        while !((*ctx).run_stack_top).is_null()
                            && (*(*ctx).run_stack_top).step() as libc::c_int
                                == -(1 as libc::c_int)
                        {
                            let mut n: *mut mln_lang_stack_node_t = ({
                                let mut n_0: *mut mln_lang_stack_node_t = (*ctx)
                                    .run_stack_top;
                                if !n_0.is_null()
                                    && {
                                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                                        (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                                    }
                                {
                                    (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                                }
                                n_0
                            });
                            if !n.is_null() {
                                if !((*n).ret_var).is_null() {
                                    __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                                    (*n).ret_var = 0 as *mut mln_lang_var_t;
                                }
                                if !((*n).ret_var2).is_null() {
                                    __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                                }
                            }
                        }
                    }
                }
                6797081956882827194 => {
                    (*node).set_call(1 as libc::c_int as mln_u32_t);
                    if mln_lang_stack_handler_funccall_run(
                        ctx,
                        node,
                        (*(*res).val).data.call,
                    ) < 0 as libc::c_int
                    {
                        (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                        return;
                    }
                }
                _ => {}
            }
            return;
        }
        (*node).set_step(3 as libc::c_int as mln_u32_t);
        tmp = (*addsub).right;
        node = ({
            let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
            if ((*ctx).run_stack_top).is_null() {
                (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                n = (*ctx).run_stack_top;
            } else if (((*ctx).run_stack_top)
                .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                < 1024 as libc::c_int as libc::c_long
            {
                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                n = (*ctx).run_stack_top;
            }
            if !n.is_null() {
                (*n).type_0 = M_LSNT_MULDIV;
                (*n).pos = 0 as *mut libc::c_void;
                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                (*n).ret_var = (*n).ret_var2;
                (*n).set_step(0 as libc::c_int as mln_u32_t);
                (*n).set_call(0 as libc::c_int as mln_u32_t);
                match M_LSNT_MULDIV as libc::c_int {
                    0 => {
                        (*n).data.stm = (*tmp).left as *mut mln_lang_stm_t;
                    }
                    1 => {
                        (*n).data.funcdef = (*tmp).left as *mut mln_lang_funcdef_t;
                    }
                    2 => {
                        (*n).data.set = (*tmp).left as *mut mln_lang_set_t;
                    }
                    3 => {
                        (*n).data.set_stm = (*tmp).left as *mut mln_lang_setstm_t;
                    }
                    4 => {
                        (*n).data.block = (*tmp).left as *mut mln_lang_block_t;
                    }
                    5 => {
                        (*n).data.w = (*tmp).left as *mut mln_lang_while_t;
                    }
                    6 => {
                        (*n).data.sw = (*tmp).left as *mut mln_lang_switch_t;
                    }
                    7 => {
                        (*n).data.sw_stm = (*tmp).left as *mut mln_lang_switchstm_t;
                    }
                    8 => {
                        (*n).data.f = (*tmp).left as *mut mln_lang_for_t;
                    }
                    9 => {
                        (*n).data.i = (*tmp).left as *mut mln_lang_if_t;
                    }
                    10 => {
                        (*n).data.exp = (*tmp).left as *mut mln_lang_exp_t;
                    }
                    11 => {
                        (*n).data.assign = (*tmp).left as *mut mln_lang_assign_t;
                    }
                    12 => {
                        (*n).data.logiclow = (*tmp).left as *mut mln_lang_logiclow_t;
                    }
                    13 => {
                        (*n).data.logichigh = (*tmp).left as *mut mln_lang_logichigh_t;
                        (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                    }
                    14 => {
                        (*n)
                            .data
                            .relativelow = (*tmp).left as *mut mln_lang_relativelow_t;
                        (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                    }
                    15 => {
                        (*n)
                            .data
                            .relativehigh = (*tmp).left as *mut mln_lang_relativehigh_t;
                        (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                    }
                    16 => {
                        (*n).data.move_0 = (*tmp).left as *mut mln_lang_move_t;
                        (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                    }
                    17 => {
                        (*n).data.addsub = (*tmp).left as *mut mln_lang_addsub_t;
                        (*n).pos = (*n).data.addsub as *mut libc::c_void;
                    }
                    18 => {
                        (*n).data.muldiv = (*tmp).left;
                        (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                    }
                    19 => {
                        (*n).data.not = (*tmp).left as *mut mln_lang_not_t;
                        (*n).pos = (*n).data.not as *mut libc::c_void;
                    }
                    20 => {
                        (*n).data.suffix = (*tmp).left as *mut mln_lang_suffix_t;
                    }
                    21 => {
                        (*n).data.locate = (*tmp).left as *mut mln_lang_locate_t;
                    }
                    22 => {
                        (*n).data.spec = (*tmp).left as *mut mln_lang_spec_t;
                    }
                    23 => {
                        (*n).data.factor = (*tmp).left as *mut mln_lang_factor_t;
                    }
                    _ => {
                        (*n).data.elemlist = (*tmp).left as *mut mln_lang_elemlist_t;
                    }
                }
            }
            n
        });
        if node.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"Stack is full.\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
            return;
        }
        (mln_lang_stack_map[(*node).type_0 as usize])
            .expect("non-null function pointer")(ctx);
        return;
    };
}
unsafe extern "C" fn mln_lang_stack_handler_muldiv(mut ctx: *mut mln_lang_ctx_t) {
    let mut node: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
    let mut tmp: *mut mln_lang_muldiv_t = 0 as *mut mln_lang_muldiv_t;
    let mut muldiv: *mut mln_lang_muldiv_t = (*node).pos as *mut mln_lang_muldiv_t;
    let mut res: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    if (*node).step() as libc::c_int == 0 as libc::c_int {
        mln_lang_stack_node_reset_ret_val(node);
        mln_lang_ctx_reset_ret_var(ctx);
        if (*muldiv).op as libc::c_uint == M_MULDIV_NONE as libc::c_int as libc::c_uint {
            (*node).set_step(-(1 as libc::c_int) as mln_u32_t);
        } else {
            (*node).set_step(1 as libc::c_int as mln_u32_t);
        }
        if ((*muldiv).jump).is_null() {
            mln_lang_generate_jump_ptr(muldiv as *mut libc::c_void, M_LSNT_MULDIV);
        }
        if (*muldiv).type_0 == M_LSNT_FACTOR as libc::c_int
            && (*muldiv).op as libc::c_uint
                == M_MULDIV_NONE as libc::c_int as libc::c_uint
        {
            let mut n: *mut mln_lang_stack_node_t = ({
                let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                if !n_0.is_null()
                    && {
                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                        (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                    }
                {
                    (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                }
                n_0
            });
            if !n.is_null() {
                if !((*n).ret_var).is_null() {
                    __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                    (*n).ret_var = 0 as *mut mln_lang_var_t;
                }
                if !((*n).ret_var2).is_null() {
                    __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                }
            }
            while !((*ctx).run_stack_top).is_null()
                && (*(*ctx).run_stack_top).step() as libc::c_int == -(1 as libc::c_int)
            {
                let mut n: *mut mln_lang_stack_node_t = ({
                    let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                    if !n_0.is_null()
                        && {
                            (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                            (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                        }
                    {
                        (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                    }
                    n_0
                });
                if !n.is_null() {
                    if !((*n).ret_var).is_null() {
                        __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                        (*n).ret_var = 0 as *mut mln_lang_var_t;
                    }
                    if !((*n).ret_var2).is_null() {
                        __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                        (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    }
                }
            }
        }
        node = ({
            let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
            if ((*ctx).run_stack_top).is_null() {
                (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                n = (*ctx).run_stack_top;
            } else if (((*ctx).run_stack_top)
                .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                < 1024 as libc::c_int as libc::c_long
            {
                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                n = (*ctx).run_stack_top;
            }
            if !n.is_null() {
                (*n).type_0 = (*muldiv).type_0 as mln_lang_stack_node_type_t;
                (*n).pos = 0 as *mut libc::c_void;
                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                (*n).ret_var = (*n).ret_var2;
                (*n).set_step(0 as libc::c_int as mln_u32_t);
                (*n).set_call(0 as libc::c_int as mln_u32_t);
                match (*muldiv).type_0 as mln_lang_stack_node_type_t as libc::c_uint {
                    0 => {
                        (*n).data.stm = (*muldiv).jump as *mut mln_lang_stm_t;
                    }
                    1 => {
                        (*n).data.funcdef = (*muldiv).jump as *mut mln_lang_funcdef_t;
                    }
                    2 => {
                        (*n).data.set = (*muldiv).jump as *mut mln_lang_set_t;
                    }
                    3 => {
                        (*n).data.set_stm = (*muldiv).jump as *mut mln_lang_setstm_t;
                    }
                    4 => {
                        (*n).data.block = (*muldiv).jump as *mut mln_lang_block_t;
                    }
                    5 => {
                        (*n).data.w = (*muldiv).jump as *mut mln_lang_while_t;
                    }
                    6 => {
                        (*n).data.sw = (*muldiv).jump as *mut mln_lang_switch_t;
                    }
                    7 => {
                        (*n).data.sw_stm = (*muldiv).jump as *mut mln_lang_switchstm_t;
                    }
                    8 => {
                        (*n).data.f = (*muldiv).jump as *mut mln_lang_for_t;
                    }
                    9 => {
                        (*n).data.i = (*muldiv).jump as *mut mln_lang_if_t;
                    }
                    10 => {
                        (*n).data.exp = (*muldiv).jump as *mut mln_lang_exp_t;
                    }
                    11 => {
                        (*n).data.assign = (*muldiv).jump as *mut mln_lang_assign_t;
                    }
                    12 => {
                        (*n).data.logiclow = (*muldiv).jump as *mut mln_lang_logiclow_t;
                    }
                    13 => {
                        (*n)
                            .data
                            .logichigh = (*muldiv).jump as *mut mln_lang_logichigh_t;
                        (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                    }
                    14 => {
                        (*n)
                            .data
                            .relativelow = (*muldiv).jump as *mut mln_lang_relativelow_t;
                        (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                    }
                    15 => {
                        (*n)
                            .data
                            .relativehigh = (*muldiv).jump
                            as *mut mln_lang_relativehigh_t;
                        (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                    }
                    16 => {
                        (*n).data.move_0 = (*muldiv).jump as *mut mln_lang_move_t;
                        (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                    }
                    17 => {
                        (*n).data.addsub = (*muldiv).jump as *mut mln_lang_addsub_t;
                        (*n).pos = (*n).data.addsub as *mut libc::c_void;
                    }
                    18 => {
                        (*n).data.muldiv = (*muldiv).jump as *mut mln_lang_muldiv_t;
                        (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                    }
                    19 => {
                        (*n).data.not = (*muldiv).jump as *mut mln_lang_not_t;
                        (*n).pos = (*n).data.not as *mut libc::c_void;
                    }
                    20 => {
                        (*n).data.suffix = (*muldiv).jump as *mut mln_lang_suffix_t;
                    }
                    21 => {
                        (*n).data.locate = (*muldiv).jump as *mut mln_lang_locate_t;
                    }
                    22 => {
                        (*n).data.spec = (*muldiv).jump as *mut mln_lang_spec_t;
                    }
                    23 => {
                        (*n).data.factor = (*muldiv).jump as *mut mln_lang_factor_t;
                    }
                    _ => {
                        (*n).data.elemlist = (*muldiv).jump as *mut mln_lang_elemlist_t;
                    }
                }
            }
            n
        });
        if node.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"Stack is full.\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
            return;
        }
        (mln_lang_stack_map[(*node).type_0 as usize])
            .expect("non-null function pointer")(ctx);
        return;
    } else {
        if (*node).step() as libc::c_int == 1 as libc::c_int {
            (*node).set_step(2 as libc::c_int as mln_u32_t);
            mln_lang_stack_node_get_ctx_ret_var(node, ctx);
        } else if !((*node).step() as libc::c_int == 2 as libc::c_int) {
            let mut handler: mln_lang_op = None;
            let mut method: *mut mln_lang_method_t = 0 as *mut mln_lang_method_t;
            let mut current_block_91: u64;
            if (*node).step() as libc::c_int == 3 as libc::c_int {
                (*node).set_step(4 as libc::c_int as mln_u32_t);
                handler = None;
                method = 0 as *mut mln_lang_method_t;
                method = mln_lang_methods[(*(*(*node).ret_var).val).type_0 as usize];
                if method.is_null() {
                    __mln_lang_errmsg(
                        ctx,
                        b"Operation NOT support.\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                    );
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                match (*muldiv).op as libc::c_uint {
                    1 => {
                        handler = (*method).mul_handler;
                    }
                    2 => {
                        handler = (*method).div_handler;
                    }
                    3 => {
                        handler = (*method).mod_handler;
                    }
                    _ => {}
                }
                if handler.is_none() {
                    __mln_lang_errmsg(
                        ctx,
                        b"Operation NOT support.\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                    );
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                if handler
                    .expect(
                        "non-null function pointer",
                    )(ctx, &mut res, (*node).ret_var, (*ctx).ret_var) < 0 as libc::c_int
                {
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                mln_lang_stack_node_get_ctx_ret_var(node, ctx);
                __mln_lang_ctx_set_ret_var(ctx, res);
                if (*(*res).val).type_0 == 8 as libc::c_int {
                    current_block_91 = 13441899094124027331;
                } else {
                    current_block_91 = 17337866845713036003;
                }
            } else if (*node).step() as libc::c_int == 4 as libc::c_int {
                if (*node).call() != 0 {
                    if mln_lang_withdraw_until_func(ctx) < 0 as libc::c_int {
                        (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                        return;
                    }
                    (*node).set_call(0 as libc::c_int as mln_u32_t);
                    res = (*ctx).ret_var;
                    if (*(*res).val).type_0 == 8 as libc::c_int {
                        current_block_91 = 13441899094124027331;
                    } else {
                        current_block_91 = 17337866845713036003;
                    }
                } else {
                    current_block_91 = 17337866845713036003;
                }
            } else {
                let mut n: *mut mln_lang_stack_node_t = ({
                    let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                    if !n_0.is_null()
                        && {
                            (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                            (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                        }
                    {
                        (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                    }
                    n_0
                });
                if !n.is_null() {
                    if !((*n).ret_var).is_null() {
                        __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                        (*n).ret_var = 0 as *mut mln_lang_var_t;
                    }
                    if !((*n).ret_var2).is_null() {
                        __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                        (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    }
                }
                while !((*ctx).run_stack_top).is_null()
                    && (*(*ctx).run_stack_top).step() as libc::c_int
                        == -(1 as libc::c_int)
                {
                    let mut n: *mut mln_lang_stack_node_t = ({
                        let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                        if !n_0.is_null()
                            && {
                                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                                (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                            }
                        {
                            (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                        }
                        n_0
                    });
                    if !n.is_null() {
                        if !((*n).ret_var).is_null() {
                            __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                            (*n).ret_var = 0 as *mut mln_lang_var_t;
                        }
                        if !((*n).ret_var2).is_null() {
                            __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                            (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                        }
                    }
                }
                current_block_91 = 7318352876044315808;
            }
            match current_block_91 {
                17337866845713036003 => {
                    (*node).pos = (*muldiv).right as *mut libc::c_void;
                    if !((*node).pos).is_null()
                        && (*(*muldiv).right).op as libc::c_uint
                            != M_MULDIV_NONE as libc::c_int as libc::c_uint
                    {
                        (*node).set_step(2 as libc::c_int as mln_u32_t);
                        mln_lang_stack_node_get_ctx_ret_var(node, ctx);
                    } else {
                        let mut n: *mut mln_lang_stack_node_t = ({
                            let mut n_0: *mut mln_lang_stack_node_t = (*ctx)
                                .run_stack_top;
                            if !n_0.is_null()
                                && {
                                    (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                                    (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                                }
                            {
                                (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                            }
                            n_0
                        });
                        if !n.is_null() {
                            if !((*n).ret_var).is_null() {
                                __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                                (*n).ret_var = 0 as *mut mln_lang_var_t;
                            }
                            if !((*n).ret_var2).is_null() {
                                __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                            }
                        }
                        while !((*ctx).run_stack_top).is_null()
                            && (*(*ctx).run_stack_top).step() as libc::c_int
                                == -(1 as libc::c_int)
                        {
                            let mut n: *mut mln_lang_stack_node_t = ({
                                let mut n_0: *mut mln_lang_stack_node_t = (*ctx)
                                    .run_stack_top;
                                if !n_0.is_null()
                                    && {
                                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                                        (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                                    }
                                {
                                    (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                                }
                                n_0
                            });
                            if !n.is_null() {
                                if !((*n).ret_var).is_null() {
                                    __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                                    (*n).ret_var = 0 as *mut mln_lang_var_t;
                                }
                                if !((*n).ret_var2).is_null() {
                                    __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                                }
                            }
                        }
                    }
                }
                13441899094124027331 => {
                    (*node).set_call(1 as libc::c_int as mln_u32_t);
                    if mln_lang_stack_handler_funccall_run(
                        ctx,
                        node,
                        (*(*res).val).data.call,
                    ) < 0 as libc::c_int
                    {
                        (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                        return;
                    }
                }
                _ => {}
            }
            return;
        }
        (*node).set_step(3 as libc::c_int as mln_u32_t);
        tmp = (*muldiv).right;
        node = ({
            let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
            if ((*ctx).run_stack_top).is_null() {
                (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                n = (*ctx).run_stack_top;
            } else if (((*ctx).run_stack_top)
                .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                < 1024 as libc::c_int as libc::c_long
            {
                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                n = (*ctx).run_stack_top;
            }
            if !n.is_null() {
                (*n).type_0 = M_LSNT_NOT;
                (*n).pos = 0 as *mut libc::c_void;
                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                (*n).ret_var = (*n).ret_var2;
                (*n).set_step(0 as libc::c_int as mln_u32_t);
                (*n).set_call(0 as libc::c_int as mln_u32_t);
                match M_LSNT_NOT as libc::c_int {
                    0 => {
                        (*n).data.stm = (*tmp).left as *mut mln_lang_stm_t;
                    }
                    1 => {
                        (*n).data.funcdef = (*tmp).left as *mut mln_lang_funcdef_t;
                    }
                    2 => {
                        (*n).data.set = (*tmp).left as *mut mln_lang_set_t;
                    }
                    3 => {
                        (*n).data.set_stm = (*tmp).left as *mut mln_lang_setstm_t;
                    }
                    4 => {
                        (*n).data.block = (*tmp).left as *mut mln_lang_block_t;
                    }
                    5 => {
                        (*n).data.w = (*tmp).left as *mut mln_lang_while_t;
                    }
                    6 => {
                        (*n).data.sw = (*tmp).left as *mut mln_lang_switch_t;
                    }
                    7 => {
                        (*n).data.sw_stm = (*tmp).left as *mut mln_lang_switchstm_t;
                    }
                    8 => {
                        (*n).data.f = (*tmp).left as *mut mln_lang_for_t;
                    }
                    9 => {
                        (*n).data.i = (*tmp).left as *mut mln_lang_if_t;
                    }
                    10 => {
                        (*n).data.exp = (*tmp).left as *mut mln_lang_exp_t;
                    }
                    11 => {
                        (*n).data.assign = (*tmp).left as *mut mln_lang_assign_t;
                    }
                    12 => {
                        (*n).data.logiclow = (*tmp).left as *mut mln_lang_logiclow_t;
                    }
                    13 => {
                        (*n).data.logichigh = (*tmp).left as *mut mln_lang_logichigh_t;
                        (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                    }
                    14 => {
                        (*n)
                            .data
                            .relativelow = (*tmp).left as *mut mln_lang_relativelow_t;
                        (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                    }
                    15 => {
                        (*n)
                            .data
                            .relativehigh = (*tmp).left as *mut mln_lang_relativehigh_t;
                        (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                    }
                    16 => {
                        (*n).data.move_0 = (*tmp).left as *mut mln_lang_move_t;
                        (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                    }
                    17 => {
                        (*n).data.addsub = (*tmp).left as *mut mln_lang_addsub_t;
                        (*n).pos = (*n).data.addsub as *mut libc::c_void;
                    }
                    18 => {
                        (*n).data.muldiv = (*tmp).left as *mut mln_lang_muldiv_t;
                        (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                    }
                    19 => {
                        (*n).data.not = (*tmp).left;
                        (*n).pos = (*n).data.not as *mut libc::c_void;
                    }
                    20 => {
                        (*n).data.suffix = (*tmp).left as *mut mln_lang_suffix_t;
                    }
                    21 => {
                        (*n).data.locate = (*tmp).left as *mut mln_lang_locate_t;
                    }
                    22 => {
                        (*n).data.spec = (*tmp).left as *mut mln_lang_spec_t;
                    }
                    23 => {
                        (*n).data.factor = (*tmp).left as *mut mln_lang_factor_t;
                    }
                    _ => {
                        (*n).data.elemlist = (*tmp).left as *mut mln_lang_elemlist_t;
                    }
                }
            }
            n
        });
        if node.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"Stack is full.\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
            return;
        }
        (mln_lang_stack_map[(*node).type_0 as usize])
            .expect("non-null function pointer")(ctx);
        return;
    };
}
unsafe extern "C" fn mln_lang_stack_handler_not(mut ctx: *mut mln_lang_ctx_t) {
    let mut handler: mln_lang_op = None;
    let mut method: *mut mln_lang_method_t = 0 as *mut mln_lang_method_t;
    let mut current_block: u64;
    let mut res: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut node: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
    let mut not: *mut mln_lang_not_t = (*node).data.not;
    if (*node).step() as libc::c_int == 0 as libc::c_int {
        mln_lang_stack_node_reset_ret_val(node);
        mln_lang_ctx_reset_ret_var(ctx);
        (*node)
            .set_step(
                (if (*not).op as libc::c_uint
                    == M_NOT_NONE as libc::c_int as libc::c_uint
                {
                    -(1 as libc::c_int)
                } else {
                    1 as libc::c_int
                }) as mln_u32_t,
            );
        if ((*not).jump).is_null() {
            mln_lang_generate_jump_ptr(not as *mut libc::c_void, M_LSNT_NOT);
        }
        node = ({
            let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
            if ((*ctx).run_stack_top).is_null() {
                (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                n = (*ctx).run_stack_top;
            } else if (((*ctx).run_stack_top)
                .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                < 1024 as libc::c_int as libc::c_long
            {
                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                n = (*ctx).run_stack_top;
            }
            if !n.is_null() {
                (*n).type_0 = (*not).type_0 as mln_lang_stack_node_type_t;
                (*n).pos = 0 as *mut libc::c_void;
                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                (*n).ret_var = (*n).ret_var2;
                (*n).set_step(0 as libc::c_int as mln_u32_t);
                (*n).set_call(0 as libc::c_int as mln_u32_t);
                match (*not).type_0 as mln_lang_stack_node_type_t as libc::c_uint {
                    0 => {
                        (*n).data.stm = (*not).jump as *mut mln_lang_stm_t;
                    }
                    1 => {
                        (*n).data.funcdef = (*not).jump as *mut mln_lang_funcdef_t;
                    }
                    2 => {
                        (*n).data.set = (*not).jump as *mut mln_lang_set_t;
                    }
                    3 => {
                        (*n).data.set_stm = (*not).jump as *mut mln_lang_setstm_t;
                    }
                    4 => {
                        (*n).data.block = (*not).jump as *mut mln_lang_block_t;
                    }
                    5 => {
                        (*n).data.w = (*not).jump as *mut mln_lang_while_t;
                    }
                    6 => {
                        (*n).data.sw = (*not).jump as *mut mln_lang_switch_t;
                    }
                    7 => {
                        (*n).data.sw_stm = (*not).jump as *mut mln_lang_switchstm_t;
                    }
                    8 => {
                        (*n).data.f = (*not).jump as *mut mln_lang_for_t;
                    }
                    9 => {
                        (*n).data.i = (*not).jump as *mut mln_lang_if_t;
                    }
                    10 => {
                        (*n).data.exp = (*not).jump as *mut mln_lang_exp_t;
                    }
                    11 => {
                        (*n).data.assign = (*not).jump as *mut mln_lang_assign_t;
                    }
                    12 => {
                        (*n).data.logiclow = (*not).jump as *mut mln_lang_logiclow_t;
                    }
                    13 => {
                        (*n).data.logichigh = (*not).jump as *mut mln_lang_logichigh_t;
                        (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                    }
                    14 => {
                        (*n)
                            .data
                            .relativelow = (*not).jump as *mut mln_lang_relativelow_t;
                        (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                    }
                    15 => {
                        (*n)
                            .data
                            .relativehigh = (*not).jump as *mut mln_lang_relativehigh_t;
                        (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                    }
                    16 => {
                        (*n).data.move_0 = (*not).jump as *mut mln_lang_move_t;
                        (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                    }
                    17 => {
                        (*n).data.addsub = (*not).jump as *mut mln_lang_addsub_t;
                        (*n).pos = (*n).data.addsub as *mut libc::c_void;
                    }
                    18 => {
                        (*n).data.muldiv = (*not).jump as *mut mln_lang_muldiv_t;
                        (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                    }
                    19 => {
                        (*n).data.not = (*not).jump as *mut mln_lang_not_t;
                        (*n).pos = (*n).data.not as *mut libc::c_void;
                    }
                    20 => {
                        (*n).data.suffix = (*not).jump as *mut mln_lang_suffix_t;
                    }
                    21 => {
                        (*n).data.locate = (*not).jump as *mut mln_lang_locate_t;
                    }
                    22 => {
                        (*n).data.spec = (*not).jump as *mut mln_lang_spec_t;
                    }
                    23 => {
                        (*n).data.factor = (*not).jump as *mut mln_lang_factor_t;
                    }
                    _ => {
                        (*n).data.elemlist = (*not).jump as *mut mln_lang_elemlist_t;
                    }
                }
            }
            n
        });
        if node.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"Stack is full.\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
            return;
        }
        (mln_lang_stack_map[(*node).type_0 as usize])
            .expect("non-null function pointer")(ctx);
        return;
    } else {
        if (*node).step() as libc::c_int == 1 as libc::c_int {
            (*node).set_step(2 as libc::c_int as mln_u32_t);
            handler = None;
            method = 0 as *mut mln_lang_method_t;
            method = mln_lang_methods[(*(*(*ctx).ret_var).val).type_0 as usize];
            if method.is_null() {
                __mln_lang_errmsg(
                    ctx,
                    b"Operation NOT support.\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                );
                (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                return;
            }
            match (*not).op as libc::c_uint {
                1 => {
                    handler = (*method).not_handler;
                }
                _ => {}
            }
            if handler.is_some() {
                if handler
                    .expect(
                        "non-null function pointer",
                    )(ctx, &mut res, (*ctx).ret_var, 0 as *mut mln_lang_var_t)
                    < 0 as libc::c_int
                {
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                __mln_lang_ctx_set_ret_var(ctx, res);
                if (*(*res).val).type_0 == 8 as libc::c_int {
                    (*node).set_call(1 as libc::c_int as mln_u32_t);
                    current_block = 13449221920238182714;
                } else {
                    current_block = 4428713362648661177;
                }
            } else {
                current_block = 2543120759711851213;
            }
        } else if (*node).step() as libc::c_int == 2 as libc::c_int {
            if (*node).call() != 0 {
                if mln_lang_withdraw_until_func(ctx) < 0 as libc::c_int {
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                res = (*ctx).ret_var;
                if (*(*(*ctx).ret_var).val).type_0 == 8 as libc::c_int {
                    current_block = 13449221920238182714;
                } else {
                    current_block = 4428713362648661177;
                }
            } else {
                current_block = 4428713362648661177;
            }
        } else {
            current_block = 4428713362648661177;
        }
        match current_block {
            4428713362648661177 => {
                let mut n: *mut mln_lang_stack_node_t = ({
                    let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                    if !n_0.is_null()
                        && {
                            (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                            (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                        }
                    {
                        (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                    }
                    n_0
                });
                if !n.is_null() {
                    if !((*n).ret_var).is_null() {
                        __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                        (*n).ret_var = 0 as *mut mln_lang_var_t;
                    }
                    if !((*n).ret_var2).is_null() {
                        __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                        (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    }
                }
                while !((*ctx).run_stack_top).is_null()
                    && (*(*ctx).run_stack_top).step() as libc::c_int
                        == -(1 as libc::c_int)
                {
                    let mut n: *mut mln_lang_stack_node_t = ({
                        let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                        if !n_0.is_null()
                            && {
                                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                                (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                            }
                        {
                            (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                        }
                        n_0
                    });
                    if !n.is_null() {
                        if !((*n).ret_var).is_null() {
                            __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                            (*n).ret_var = 0 as *mut mln_lang_var_t;
                        }
                        if !((*n).ret_var2).is_null() {
                            __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                            (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                        }
                    }
                }
            }
            13449221920238182714 => {
                if mln_lang_stack_handler_funccall_run(
                    ctx,
                    node,
                    (*(*res).val).data.call,
                ) < 0 as libc::c_int
                {
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
            }
            _ => {}
        }
        return;
    };
}
unsafe extern "C" fn mln_lang_stack_handler_suffix(mut ctx: *mut mln_lang_ctx_t) {
    let mut res: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut node: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
    let mut suffix: *mut mln_lang_suffix_t = (*node).data.suffix;
    if (*node).step() as libc::c_int == 0 as libc::c_int {
        mln_lang_stack_node_reset_ret_val(node);
        mln_lang_ctx_reset_ret_var(ctx);
        (*node)
            .set_step(
                (if (*suffix).op as libc::c_uint
                    == M_SUFFIX_NONE as libc::c_int as libc::c_uint
                {
                    -(1 as libc::c_int)
                } else {
                    1 as libc::c_int
                }) as mln_u32_t,
            );
        if ((*suffix).jump).is_null() {
            mln_lang_generate_jump_ptr(suffix as *mut libc::c_void, M_LSNT_SUFFIX);
        }
        if (*suffix).type_0 == M_LSNT_FACTOR as libc::c_int
            && (*suffix).op as libc::c_uint
                == M_SUFFIX_NONE as libc::c_int as libc::c_uint
        {
            let mut n: *mut mln_lang_stack_node_t = ({
                let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                if !n_0.is_null()
                    && {
                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                        (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                    }
                {
                    (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                }
                n_0
            });
            if !n.is_null() {
                if !((*n).ret_var).is_null() {
                    __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                    (*n).ret_var = 0 as *mut mln_lang_var_t;
                }
                if !((*n).ret_var2).is_null() {
                    __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                }
            }
            while !((*ctx).run_stack_top).is_null()
                && (*(*ctx).run_stack_top).step() as libc::c_int == -(1 as libc::c_int)
            {
                let mut n: *mut mln_lang_stack_node_t = ({
                    let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                    if !n_0.is_null()
                        && {
                            (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                            (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                        }
                    {
                        (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                    }
                    n_0
                });
                if !n.is_null() {
                    if !((*n).ret_var).is_null() {
                        __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                        (*n).ret_var = 0 as *mut mln_lang_var_t;
                    }
                    if !((*n).ret_var2).is_null() {
                        __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                        (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    }
                }
            }
        }
        node = ({
            let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
            if ((*ctx).run_stack_top).is_null() {
                (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                n = (*ctx).run_stack_top;
            } else if (((*ctx).run_stack_top)
                .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                < 1024 as libc::c_int as libc::c_long
            {
                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                n = (*ctx).run_stack_top;
            }
            if !n.is_null() {
                (*n).type_0 = (*suffix).type_0 as mln_lang_stack_node_type_t;
                (*n).pos = 0 as *mut libc::c_void;
                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                (*n).ret_var = (*n).ret_var2;
                (*n).set_step(0 as libc::c_int as mln_u32_t);
                (*n).set_call(0 as libc::c_int as mln_u32_t);
                match (*suffix).type_0 as mln_lang_stack_node_type_t as libc::c_uint {
                    0 => {
                        (*n).data.stm = (*suffix).jump as *mut mln_lang_stm_t;
                    }
                    1 => {
                        (*n).data.funcdef = (*suffix).jump as *mut mln_lang_funcdef_t;
                    }
                    2 => {
                        (*n).data.set = (*suffix).jump as *mut mln_lang_set_t;
                    }
                    3 => {
                        (*n).data.set_stm = (*suffix).jump as *mut mln_lang_setstm_t;
                    }
                    4 => {
                        (*n).data.block = (*suffix).jump as *mut mln_lang_block_t;
                    }
                    5 => {
                        (*n).data.w = (*suffix).jump as *mut mln_lang_while_t;
                    }
                    6 => {
                        (*n).data.sw = (*suffix).jump as *mut mln_lang_switch_t;
                    }
                    7 => {
                        (*n).data.sw_stm = (*suffix).jump as *mut mln_lang_switchstm_t;
                    }
                    8 => {
                        (*n).data.f = (*suffix).jump as *mut mln_lang_for_t;
                    }
                    9 => {
                        (*n).data.i = (*suffix).jump as *mut mln_lang_if_t;
                    }
                    10 => {
                        (*n).data.exp = (*suffix).jump as *mut mln_lang_exp_t;
                    }
                    11 => {
                        (*n).data.assign = (*suffix).jump as *mut mln_lang_assign_t;
                    }
                    12 => {
                        (*n).data.logiclow = (*suffix).jump as *mut mln_lang_logiclow_t;
                    }
                    13 => {
                        (*n)
                            .data
                            .logichigh = (*suffix).jump as *mut mln_lang_logichigh_t;
                        (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                    }
                    14 => {
                        (*n)
                            .data
                            .relativelow = (*suffix).jump as *mut mln_lang_relativelow_t;
                        (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                    }
                    15 => {
                        (*n)
                            .data
                            .relativehigh = (*suffix).jump
                            as *mut mln_lang_relativehigh_t;
                        (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                    }
                    16 => {
                        (*n).data.move_0 = (*suffix).jump as *mut mln_lang_move_t;
                        (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                    }
                    17 => {
                        (*n).data.addsub = (*suffix).jump as *mut mln_lang_addsub_t;
                        (*n).pos = (*n).data.addsub as *mut libc::c_void;
                    }
                    18 => {
                        (*n).data.muldiv = (*suffix).jump as *mut mln_lang_muldiv_t;
                        (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                    }
                    19 => {
                        (*n).data.not = (*suffix).jump as *mut mln_lang_not_t;
                        (*n).pos = (*n).data.not as *mut libc::c_void;
                    }
                    20 => {
                        (*n).data.suffix = (*suffix).jump as *mut mln_lang_suffix_t;
                    }
                    21 => {
                        (*n).data.locate = (*suffix).jump as *mut mln_lang_locate_t;
                    }
                    22 => {
                        (*n).data.spec = (*suffix).jump as *mut mln_lang_spec_t;
                    }
                    23 => {
                        (*n).data.factor = (*suffix).jump as *mut mln_lang_factor_t;
                    }
                    _ => {
                        (*n).data.elemlist = (*suffix).jump as *mut mln_lang_elemlist_t;
                    }
                }
            }
            n
        });
        if node.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"Stack is full.\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
            return;
        }
        (mln_lang_stack_map[(*node).type_0 as usize])
            .expect("non-null function pointer")(ctx);
        return;
    } else {
        let mut handler: mln_lang_op = None;
        let mut method: *mut mln_lang_method_t = 0 as *mut mln_lang_method_t;
        let mut current_block_85: u64;
        if (*node).step() as libc::c_int == 1 as libc::c_int {
            (*node).set_step(2 as libc::c_int as mln_u32_t);
            handler = None;
            method = 0 as *mut mln_lang_method_t;
            method = mln_lang_methods[(*(*(*ctx).ret_var).val).type_0 as usize];
            if method.is_null() {
                __mln_lang_errmsg(
                    ctx,
                    b"Operation NOT support.\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                );
                (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                return;
            }
            match (*suffix).op as libc::c_uint {
                1 => {
                    handler = (*method).sinc_handler;
                }
                2 => {
                    handler = (*method).sdec_handler;
                }
                _ => {}
            }
            if handler.is_some() {
                if (*(*(*ctx).ret_var).val).not_modify() != 0 {
                    __mln_lang_errmsg(
                        ctx,
                        b"Operand cannot be changed.\0" as *const u8
                            as *const libc::c_char as *mut libc::c_char,
                    );
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                if handler
                    .expect(
                        "non-null function pointer",
                    )(ctx, &mut res, (*ctx).ret_var, 0 as *mut mln_lang_var_t)
                    < 0 as libc::c_int
                {
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                mln_lang_stack_node_get_ctx_ret_var(node, ctx);
                __mln_lang_ctx_set_ret_var(ctx, res);
                if (*(*res).val).type_0 == 8 as libc::c_int {
                    (*node).set_call(1 as libc::c_int as mln_u32_t);
                    current_block_85 = 17514682658674438393;
                } else {
                    current_block_85 = 4627425811397883209;
                }
            } else {
                if (*suffix).op as libc::c_uint
                    != M_SUFFIX_NONE as libc::c_int as libc::c_uint
                {
                    __mln_lang_errmsg(
                        ctx,
                        b"Operation NOT support.\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                    );
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                current_block_85 = 17441561948628420366;
            }
        } else if (*node).step() as libc::c_int == 2 as libc::c_int {
            if (*node).call() != 0 {
                if mln_lang_withdraw_until_func(ctx) < 0 as libc::c_int {
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                res = (*ctx).ret_var;
                if (*(*(*ctx).ret_var).val).type_0 == 8 as libc::c_int {
                    current_block_85 = 17514682658674438393;
                } else {
                    current_block_85 = 4627425811397883209;
                }
            } else {
                current_block_85 = 4627425811397883209;
            }
        } else if (*node).step() as libc::c_int == 3 as libc::c_int {
            if (*node).call() != 0 {
                if mln_lang_withdraw_until_func(ctx) < 0 as libc::c_int {
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                (*node).set_call(0 as libc::c_int as mln_u32_t);
            }
            mln_lang_ctx_get_node_ret_val(ctx, node);
            let mut n: *mut mln_lang_stack_node_t = ({
                let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                if !n_0.is_null()
                    && {
                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                        (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                    }
                {
                    (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                }
                n_0
            });
            if !n.is_null() {
                if !((*n).ret_var).is_null() {
                    __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                    (*n).ret_var = 0 as *mut mln_lang_var_t;
                }
                if !((*n).ret_var2).is_null() {
                    __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                }
            }
            while !((*ctx).run_stack_top).is_null()
                && (*(*ctx).run_stack_top).step() as libc::c_int == -(1 as libc::c_int)
            {
                let mut n: *mut mln_lang_stack_node_t = ({
                    let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                    if !n_0.is_null()
                        && {
                            (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                            (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                        }
                    {
                        (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                    }
                    n_0
                });
                if !n.is_null() {
                    if !((*n).ret_var).is_null() {
                        __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                        (*n).ret_var = 0 as *mut mln_lang_var_t;
                    }
                    if !((*n).ret_var2).is_null() {
                        __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                        (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    }
                }
            }
            current_block_85 = 17441561948628420366;
        } else {
            current_block_85 = 11167243700610280436;
        }
        match current_block_85 {
            4627425811397883209 => {
                (*node).set_step(3 as libc::c_int as mln_u32_t);
                if !((*node).ret_var).is_null()
                    && !((*(*(*node).ret_var).val).func).is_null()
                {
                    if mln_lang_watch_func_build(
                        ctx,
                        node,
                        (*(*(*node).ret_var).val).func,
                        (*(*(*node).ret_var).val).udata,
                        (*(*node).ret_var).val,
                    ) < 0 as libc::c_int
                    {
                        (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                        return;
                    }
                    mln_lang_stack_node_get_ctx_ret_var(node, ctx);
                    mln_lang_ctx_reset_ret_var(ctx);
                    current_block_85 = 17441561948628420366;
                } else {
                    current_block_85 = 11167243700610280436;
                }
            }
            17514682658674438393 => {
                if mln_lang_stack_handler_funccall_run(
                    ctx,
                    node,
                    (*(*res).val).data.call,
                ) < 0 as libc::c_int
                {
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                current_block_85 = 17441561948628420366;
            }
            _ => {}
        }
        match current_block_85 {
            11167243700610280436 => {
                let mut n: *mut mln_lang_stack_node_t = ({
                    let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                    if !n_0.is_null()
                        && {
                            (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                            (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                        }
                    {
                        (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                    }
                    n_0
                });
                if !n.is_null() {
                    if !((*n).ret_var).is_null() {
                        __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                        (*n).ret_var = 0 as *mut mln_lang_var_t;
                    }
                    if !((*n).ret_var2).is_null() {
                        __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                        (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    }
                }
                while !((*ctx).run_stack_top).is_null()
                    && (*(*ctx).run_stack_top).step() as libc::c_int
                        == -(1 as libc::c_int)
                {
                    let mut n: *mut mln_lang_stack_node_t = ({
                        let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                        if !n_0.is_null()
                            && {
                                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                                (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                            }
                        {
                            (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                        }
                        n_0
                    });
                    if !n.is_null() {
                        if !((*n).ret_var).is_null() {
                            __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                            (*n).ret_var = 0 as *mut mln_lang_var_t;
                        }
                        if !((*n).ret_var2).is_null() {
                            __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                            (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                        }
                    }
                }
            }
            _ => {}
        }
    };
}
unsafe extern "C" fn mln_lang_stack_handler_locate(mut ctx: *mut mln_lang_ctx_t) {
    let mut method_0: *mut mln_lang_method_t = 0 as *mut mln_lang_method_t;
    let mut res_0: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut method: *mut mln_lang_method_t = 0 as *mut mln_lang_method_t;
    let mut handler: mln_lang_op = None;
    let mut current_block: u64;
    let mut res: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut cur: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
    let mut node: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
    let mut tmp: mln_lang_stack_node_t = mln_lang_stack_node_t {
        ctx: 0 as *mut mln_lang_ctx_t,
        type_0: M_LSNT_STM,
        step_call: [0; 4],
        data: C2RustUnnamed_10 {
            stm: 0 as *mut mln_lang_stm_t,
        },
        ret_var: 0 as *mut mln_lang_var_t,
        ret_var2: 0 as *mut mln_lang_var_t,
        pos: 0 as *mut libc::c_void,
    };
    let mut locate: *mut mln_lang_locate_t = (*node).data.locate;
    if (*node).step() as libc::c_int == 0 as libc::c_int {
        mln_lang_stack_node_reset_ret_val(node);
        mln_lang_ctx_reset_ret_var(ctx);
        match (*locate).op as libc::c_uint {
            0 => {
                (*node).set_step(-(1 as libc::c_int) as mln_u32_t);
            }
            2 => {
                (*node).set_step(4 as libc::c_int as mln_u32_t);
            }
            1 => {
                (*node).set_step(1 as libc::c_int as mln_u32_t);
            }
            _ => {
                (*node).set_step(5 as libc::c_int as mln_u32_t);
            }
        }
        if ((*locate).jump).is_null() {
            mln_lang_generate_jump_ptr(locate as *mut libc::c_void, M_LSNT_LOCATE);
        }
        if (*locate).type_0 == M_LSNT_FACTOR as libc::c_int
            && (*locate).op as libc::c_uint
                == M_LOCATE_NONE as libc::c_int as libc::c_uint
        {
            let mut n: *mut mln_lang_stack_node_t = ({
                let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                if !n_0.is_null()
                    && {
                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                        (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                    }
                {
                    (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                }
                n_0
            });
            if !n.is_null() {
                if !((*n).ret_var).is_null() {
                    __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                    (*n).ret_var = 0 as *mut mln_lang_var_t;
                }
                if !((*n).ret_var2).is_null() {
                    __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                }
            }
            while !((*ctx).run_stack_top).is_null()
                && (*(*ctx).run_stack_top).step() as libc::c_int == -(1 as libc::c_int)
            {
                let mut n: *mut mln_lang_stack_node_t = ({
                    let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                    if !n_0.is_null()
                        && {
                            (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                            (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                        }
                    {
                        (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                    }
                    n_0
                });
                if !n.is_null() {
                    if !((*n).ret_var).is_null() {
                        __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                        (*n).ret_var = 0 as *mut mln_lang_var_t;
                    }
                    if !((*n).ret_var2).is_null() {
                        __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                        (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    }
                }
            }
        }
        node = ({
            let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
            if ((*ctx).run_stack_top).is_null() {
                (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                n = (*ctx).run_stack_top;
            } else if (((*ctx).run_stack_top)
                .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                < 1024 as libc::c_int as libc::c_long
            {
                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                n = (*ctx).run_stack_top;
            }
            if !n.is_null() {
                (*n).type_0 = (*locate).type_0 as mln_lang_stack_node_type_t;
                (*n).pos = 0 as *mut libc::c_void;
                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                (*n).ret_var = (*n).ret_var2;
                (*n).set_step(0 as libc::c_int as mln_u32_t);
                (*n).set_call(0 as libc::c_int as mln_u32_t);
                match (*locate).type_0 as mln_lang_stack_node_type_t as libc::c_uint {
                    0 => {
                        (*n).data.stm = (*locate).jump as *mut mln_lang_stm_t;
                    }
                    1 => {
                        (*n).data.funcdef = (*locate).jump as *mut mln_lang_funcdef_t;
                    }
                    2 => {
                        (*n).data.set = (*locate).jump as *mut mln_lang_set_t;
                    }
                    3 => {
                        (*n).data.set_stm = (*locate).jump as *mut mln_lang_setstm_t;
                    }
                    4 => {
                        (*n).data.block = (*locate).jump as *mut mln_lang_block_t;
                    }
                    5 => {
                        (*n).data.w = (*locate).jump as *mut mln_lang_while_t;
                    }
                    6 => {
                        (*n).data.sw = (*locate).jump as *mut mln_lang_switch_t;
                    }
                    7 => {
                        (*n).data.sw_stm = (*locate).jump as *mut mln_lang_switchstm_t;
                    }
                    8 => {
                        (*n).data.f = (*locate).jump as *mut mln_lang_for_t;
                    }
                    9 => {
                        (*n).data.i = (*locate).jump as *mut mln_lang_if_t;
                    }
                    10 => {
                        (*n).data.exp = (*locate).jump as *mut mln_lang_exp_t;
                    }
                    11 => {
                        (*n).data.assign = (*locate).jump as *mut mln_lang_assign_t;
                    }
                    12 => {
                        (*n).data.logiclow = (*locate).jump as *mut mln_lang_logiclow_t;
                    }
                    13 => {
                        (*n)
                            .data
                            .logichigh = (*locate).jump as *mut mln_lang_logichigh_t;
                        (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                    }
                    14 => {
                        (*n)
                            .data
                            .relativelow = (*locate).jump as *mut mln_lang_relativelow_t;
                        (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                    }
                    15 => {
                        (*n)
                            .data
                            .relativehigh = (*locate).jump
                            as *mut mln_lang_relativehigh_t;
                        (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                    }
                    16 => {
                        (*n).data.move_0 = (*locate).jump as *mut mln_lang_move_t;
                        (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                    }
                    17 => {
                        (*n).data.addsub = (*locate).jump as *mut mln_lang_addsub_t;
                        (*n).pos = (*n).data.addsub as *mut libc::c_void;
                    }
                    18 => {
                        (*n).data.muldiv = (*locate).jump as *mut mln_lang_muldiv_t;
                        (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                    }
                    19 => {
                        (*n).data.not = (*locate).jump as *mut mln_lang_not_t;
                        (*n).pos = (*n).data.not as *mut libc::c_void;
                    }
                    20 => {
                        (*n).data.suffix = (*locate).jump as *mut mln_lang_suffix_t;
                    }
                    21 => {
                        (*n).data.locate = (*locate).jump as *mut mln_lang_locate_t;
                    }
                    22 => {
                        (*n).data.spec = (*locate).jump as *mut mln_lang_spec_t;
                    }
                    23 => {
                        (*n).data.factor = (*locate).jump as *mut mln_lang_factor_t;
                    }
                    _ => {
                        (*n).data.elemlist = (*locate).jump as *mut mln_lang_elemlist_t;
                    }
                }
            }
            n
        });
        if node.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"Stack is full.\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
            return;
        }
        (mln_lang_stack_map[(*node).type_0 as usize])
            .expect("non-null function pointer")(ctx);
        return;
    } else {
        if (*node).step() as libc::c_int == 1 as libc::c_int {
            (*node).set_step(2 as libc::c_int as mln_u32_t);
            mln_lang_stack_node_get_ctx_ret_var(node, ctx);
            if ((*locate).right.exp).is_null() {
                let mut ret_var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
                ret_var = __mln_lang_var_create_nil(ctx, 0 as *mut mln_string_t);
                if ret_var.is_null() {
                    __mln_lang_errmsg(
                        ctx,
                        b"No memory.\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                    );
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                __mln_lang_ctx_set_ret_var(ctx, ret_var);
            } else {
                node = ({
                    let mut n: *mut mln_lang_stack_node_t = 0
                        as *mut mln_lang_stack_node_t;
                    if ((*ctx).run_stack_top).is_null() {
                        (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                        n = (*ctx).run_stack_top;
                    } else if (((*ctx).run_stack_top)
                        .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                        < 1024 as libc::c_int as libc::c_long
                    {
                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                        n = (*ctx).run_stack_top;
                    }
                    if !n.is_null() {
                        (*n).type_0 = M_LSNT_EXP;
                        (*n).pos = 0 as *mut libc::c_void;
                        (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                        (*n).ret_var = (*n).ret_var2;
                        (*n).set_step(0 as libc::c_int as mln_u32_t);
                        (*n).set_call(0 as libc::c_int as mln_u32_t);
                        match M_LSNT_EXP as libc::c_int {
                            0 => {
                                (*n).data.stm = (*locate).right.exp as *mut mln_lang_stm_t;
                            }
                            1 => {
                                (*n)
                                    .data
                                    .funcdef = (*locate).right.exp as *mut mln_lang_funcdef_t;
                            }
                            2 => {
                                (*n).data.set = (*locate).right.exp as *mut mln_lang_set_t;
                            }
                            3 => {
                                (*n)
                                    .data
                                    .set_stm = (*locate).right.exp as *mut mln_lang_setstm_t;
                            }
                            4 => {
                                (*n)
                                    .data
                                    .block = (*locate).right.exp as *mut mln_lang_block_t;
                            }
                            5 => {
                                (*n).data.w = (*locate).right.exp as *mut mln_lang_while_t;
                            }
                            6 => {
                                (*n)
                                    .data
                                    .sw = (*locate).right.exp as *mut mln_lang_switch_t;
                            }
                            7 => {
                                (*n)
                                    .data
                                    .sw_stm = (*locate).right.exp as *mut mln_lang_switchstm_t;
                            }
                            8 => {
                                (*n).data.f = (*locate).right.exp as *mut mln_lang_for_t;
                            }
                            9 => {
                                (*n).data.i = (*locate).right.exp as *mut mln_lang_if_t;
                            }
                            10 => {
                                (*n).data.exp = (*locate).right.exp;
                            }
                            11 => {
                                (*n)
                                    .data
                                    .assign = (*locate).right.exp as *mut mln_lang_assign_t;
                            }
                            12 => {
                                (*n)
                                    .data
                                    .logiclow = (*locate).right.exp as *mut mln_lang_logiclow_t;
                            }
                            13 => {
                                (*n)
                                    .data
                                    .logichigh = (*locate).right.exp
                                    as *mut mln_lang_logichigh_t;
                                (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                            }
                            14 => {
                                (*n)
                                    .data
                                    .relativelow = (*locate).right.exp
                                    as *mut mln_lang_relativelow_t;
                                (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                            }
                            15 => {
                                (*n)
                                    .data
                                    .relativehigh = (*locate).right.exp
                                    as *mut mln_lang_relativehigh_t;
                                (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                            }
                            16 => {
                                (*n)
                                    .data
                                    .move_0 = (*locate).right.exp as *mut mln_lang_move_t;
                                (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                            }
                            17 => {
                                (*n)
                                    .data
                                    .addsub = (*locate).right.exp as *mut mln_lang_addsub_t;
                                (*n).pos = (*n).data.addsub as *mut libc::c_void;
                            }
                            18 => {
                                (*n)
                                    .data
                                    .muldiv = (*locate).right.exp as *mut mln_lang_muldiv_t;
                                (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                            }
                            19 => {
                                (*n).data.not = (*locate).right.exp as *mut mln_lang_not_t;
                                (*n).pos = (*n).data.not as *mut libc::c_void;
                            }
                            20 => {
                                (*n)
                                    .data
                                    .suffix = (*locate).right.exp as *mut mln_lang_suffix_t;
                            }
                            21 => {
                                (*n)
                                    .data
                                    .locate = (*locate).right.exp as *mut mln_lang_locate_t;
                            }
                            22 => {
                                (*n)
                                    .data
                                    .spec = (*locate).right.exp as *mut mln_lang_spec_t;
                            }
                            23 => {
                                (*n)
                                    .data
                                    .factor = (*locate).right.exp as *mut mln_lang_factor_t;
                            }
                            _ => {
                                (*n)
                                    .data
                                    .elemlist = (*locate).right.exp as *mut mln_lang_elemlist_t;
                            }
                        }
                    }
                    n
                });
                if node.is_null() {
                    __mln_lang_errmsg(
                        ctx,
                        b"Stack is full.\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                    );
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                (mln_lang_stack_map[(*node).type_0 as usize])
                    .expect("non-null function pointer")(ctx);
                return;
            }
        } else {
            if (*node).step() as libc::c_int == 2 as libc::c_int {
                method = 0 as *mut mln_lang_method_t;
                method = mln_lang_methods[(*(*(*node).ret_var).val).type_0 as usize];
                if method.is_null() {
                    __mln_lang_errmsg(
                        ctx,
                        b"Operation NOT support.\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                    );
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                handler = (*method).index_handler;
                if handler.is_none() {
                    __mln_lang_errmsg(
                        ctx,
                        b"Operation NOT support.\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                    );
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                if handler
                    .expect(
                        "non-null function pointer",
                    )(ctx, &mut res, (*node).ret_var, (*ctx).ret_var) < 0 as libc::c_int
                {
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                __mln_lang_ctx_set_ret_var(ctx, res);
                if (*(*res).val).type_0 == 8 as libc::c_int {
                    current_block = 14372067307257457201;
                } else {
                    (*node).set_step(7 as libc::c_int as mln_u32_t);
                    current_block = 16835640586586273334;
                }
            } else if (*node).step() as libc::c_int == 3 as libc::c_int {
                if (*node).call() != 0 {
                    if mln_lang_withdraw_until_func(ctx) < 0 as libc::c_int {
                        (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                        return;
                    }
                    (*node).set_call(0 as libc::c_int as mln_u32_t);
                    res = (*ctx).ret_var;
                    if (*(*(*ctx).ret_var).val).type_0 == 8 as libc::c_int {
                        current_block = 14372067307257457201;
                    } else {
                        current_block = 5807581744382915773;
                    }
                } else {
                    current_block = 5807581744382915773;
                }
                match current_block {
                    14372067307257457201 => {}
                    _ => {
                        (*node).set_step(7 as libc::c_int as mln_u32_t);
                        current_block = 16835640586586273334;
                    }
                }
            } else {
                if (*node).step() as libc::c_int == 4 as libc::c_int {
                    if !((*node).ret_var2).is_null() {
                        __mln_lang_var_free((*node).ret_var2 as *mut libc::c_void);
                        (*node).ret_var2 = 0 as *mut mln_lang_var_t;
                    }
                    (*node).ret_var2 = (*ctx).ret_var;
                    method_0 = 0 as *mut mln_lang_method_t;
                    method_0 = mln_lang_methods[(*(*(*ctx).ret_var).val).type_0
                        as usize];
                    if method_0.is_null() || ((*method_0).property_handler).is_none() {
                        __mln_lang_errmsg(
                            ctx,
                            b"Operation NOT support.\0" as *const u8
                                as *const libc::c_char as *mut libc::c_char,
                        );
                        (*node).ret_var2 = 0 as *mut mln_lang_var_t;
                        (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                        return;
                    }
                    res_0 = 0 as *mut mln_lang_var_t;
                    var = 0 as *mut mln_lang_var_t;
                    var = mln_lang_var_create_string(
                        ctx,
                        (*locate).right.id,
                        0 as *mut mln_string_t,
                    );
                    if var.is_null() {
                        __mln_lang_errmsg(
                            ctx,
                            b"No memory.\0" as *const u8 as *const libc::c_char
                                as *mut libc::c_char,
                        );
                        (*node).ret_var2 = 0 as *mut mln_lang_var_t;
                        (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                        return;
                    }
                    if ((*method_0).property_handler)
                        .expect(
                            "non-null function pointer",
                        )(ctx, &mut res_0, (*ctx).ret_var, var) < 0 as libc::c_int
                    {
                        __mln_lang_var_free(var as *mut libc::c_void);
                        (*node).ret_var2 = 0 as *mut mln_lang_var_t;
                        (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                        return;
                    }
                    __mln_lang_var_free(var as *mut libc::c_void);
                    (*ctx).ret_var = 0 as *mut mln_lang_var_t;
                    __mln_lang_ctx_set_ret_var(ctx, res_0);
                    if (*(*res_0).val).type_0 == 8 as libc::c_int {
                        current_block = 8995598215817426579;
                    } else {
                        (*node).set_step(7 as libc::c_int as mln_u32_t);
                        current_block = 16835640586586273334;
                    }
                } else if (*node).step() as libc::c_int == 5 as libc::c_int {
                    let mut ret_var_0: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
                    let mut funccall: *mut mln_lang_funccall_val_t = 0
                        as *mut mln_lang_funccall_val_t;
                    if (*(*(*ctx).ret_var).val).type_0 != 6 as libc::c_int {
                        let mut s: *mut mln_string_t = 0 as *mut mln_string_t;
                        if (*(*(*ctx).ret_var).val).type_0 == 4 as libc::c_int {
                            s = (*(*(*ctx).ret_var).val).data.s;
                        } else if (*(*(*ctx).ret_var).val).type_0 == 0 as libc::c_int
                            && !((*(*ctx).ret_var).name).is_null()
                        {
                            s = (*(*ctx).ret_var).name;
                        } else {
                            __mln_lang_errmsg(
                                ctx,
                                b"Operation NOT support.\0" as *const u8
                                    as *const libc::c_char as *mut libc::c_char,
                            );
                            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                            return;
                        }
                        funccall = __mln_lang_funccall_val_new((*ctx).pool, s);
                        if funccall.is_null() {
                            __mln_lang_errmsg(
                                ctx,
                                b"No memory.\0" as *const u8 as *const libc::c_char
                                    as *mut libc::c_char,
                            );
                            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                            return;
                        }
                        (*funccall).prototype = 0 as *mut mln_lang_func_detail_t;
                        if !((*node).ret_var2).is_null() {
                            mln_lang_funccall_val_object_add(
                                funccall,
                                (*(*node).ret_var2).val,
                            );
                            __mln_lang_var_free((*node).ret_var2 as *mut libc::c_void);
                            (*node).ret_var2 = 0 as *mut mln_lang_var_t;
                        }
                        ret_var_0 = __mln_lang_var_create_call(ctx, funccall);
                        if ret_var_0.is_null() {
                            __mln_lang_errmsg(
                                ctx,
                                b"No memory.\0" as *const u8 as *const libc::c_char
                                    as *mut libc::c_char,
                            );
                            __mln_lang_funccall_val_free(funccall);
                            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                            return;
                        }
                        (*node).ret_var = ret_var_0;
                        mln_lang_ctx_reset_ret_var(ctx);
                    } else {
                        funccall = __mln_lang_funccall_val_new(
                            (*ctx).pool,
                            (*(*ctx).ret_var).name,
                        );
                        if funccall.is_null() {
                            __mln_lang_errmsg(
                                ctx,
                                b"No memory.\0" as *const u8 as *const libc::c_char
                                    as *mut libc::c_char,
                            );
                            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                            return;
                        }
                        (*funccall).prototype = (*(*(*ctx).ret_var).val).data.func;
                        if !((*node).ret_var2).is_null() {
                            mln_lang_funccall_val_object_add(
                                funccall,
                                (*(*node).ret_var2).val,
                            );
                            __mln_lang_var_free((*node).ret_var2 as *mut libc::c_void);
                            (*node).ret_var2 = 0 as *mut mln_lang_var_t;
                        }
                        ret_var_0 = __mln_lang_var_create_call(ctx, funccall);
                        if ret_var_0.is_null() {
                            __mln_lang_errmsg(
                                ctx,
                                b"No memory.\0" as *const u8 as *const libc::c_char
                                    as *mut libc::c_char,
                            );
                            __mln_lang_funccall_val_free(funccall);
                            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                            return;
                        }
                        (*node).ret_var = ret_var_0;
                        mln_lang_ctx_reset_ret_var(ctx);
                    }
                    (*node).pos = (*locate).right.exp as *mut libc::c_void;
                    (*node).set_step(8 as libc::c_int as mln_u32_t);
                    current_block = 5131379528150656272;
                } else if (*node).step() as libc::c_int == 8 as libc::c_int {
                    if !((*ctx).ret_var).is_null() {
                        (*(*ctx).ret_var)
                            .ref_0 = ((*(*ctx).ret_var).ref_0).wrapping_add(1);
                        (*(*ctx).ret_var).ref_0;
                        mln_lang_funccall_val_add_arg(
                            (*(*(*node).ret_var).val).data.call,
                            (*ctx).ret_var,
                        );
                        mln_lang_ctx_reset_ret_var(ctx);
                    }
                    if !((*node).pos).is_null() {
                        let mut exp: *mut mln_lang_exp_t = (*node).pos
                            as *mut mln_lang_exp_t;
                        (*node).pos = (*exp).next as *mut libc::c_void;
                        node = ({
                            let mut n: *mut mln_lang_stack_node_t = 0
                                as *mut mln_lang_stack_node_t;
                            if ((*ctx).run_stack_top).is_null() {
                                (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                                n = (*ctx).run_stack_top;
                            } else if (((*ctx).run_stack_top)
                                .offset_from(((*ctx).run_stack).as_mut_ptr())
                                as libc::c_long) < 1024 as libc::c_int as libc::c_long
                            {
                                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                                n = (*ctx).run_stack_top;
                            }
                            if !n.is_null() {
                                (*n).type_0 = M_LSNT_ASSIGN;
                                (*n).pos = 0 as *mut libc::c_void;
                                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                                (*n).ret_var = (*n).ret_var2;
                                (*n).set_step(0 as libc::c_int as mln_u32_t);
                                (*n).set_call(0 as libc::c_int as mln_u32_t);
                                match M_LSNT_ASSIGN as libc::c_int {
                                    0 => {
                                        (*n).data.stm = (*exp).assign as *mut mln_lang_stm_t;
                                    }
                                    1 => {
                                        (*n)
                                            .data
                                            .funcdef = (*exp).assign as *mut mln_lang_funcdef_t;
                                    }
                                    2 => {
                                        (*n).data.set = (*exp).assign as *mut mln_lang_set_t;
                                    }
                                    3 => {
                                        (*n).data.set_stm = (*exp).assign as *mut mln_lang_setstm_t;
                                    }
                                    4 => {
                                        (*n).data.block = (*exp).assign as *mut mln_lang_block_t;
                                    }
                                    5 => {
                                        (*n).data.w = (*exp).assign as *mut mln_lang_while_t;
                                    }
                                    6 => {
                                        (*n).data.sw = (*exp).assign as *mut mln_lang_switch_t;
                                    }
                                    7 => {
                                        (*n)
                                            .data
                                            .sw_stm = (*exp).assign as *mut mln_lang_switchstm_t;
                                    }
                                    8 => {
                                        (*n).data.f = (*exp).assign as *mut mln_lang_for_t;
                                    }
                                    9 => {
                                        (*n).data.i = (*exp).assign as *mut mln_lang_if_t;
                                    }
                                    10 => {
                                        (*n).data.exp = (*exp).assign as *mut mln_lang_exp_t;
                                    }
                                    11 => {
                                        (*n).data.assign = (*exp).assign;
                                    }
                                    12 => {
                                        (*n)
                                            .data
                                            .logiclow = (*exp).assign as *mut mln_lang_logiclow_t;
                                    }
                                    13 => {
                                        (*n)
                                            .data
                                            .logichigh = (*exp).assign as *mut mln_lang_logichigh_t;
                                        (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                                    }
                                    14 => {
                                        (*n)
                                            .data
                                            .relativelow = (*exp).assign as *mut mln_lang_relativelow_t;
                                        (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                                    }
                                    15 => {
                                        (*n)
                                            .data
                                            .relativehigh = (*exp).assign
                                            as *mut mln_lang_relativehigh_t;
                                        (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                                    }
                                    16 => {
                                        (*n).data.move_0 = (*exp).assign as *mut mln_lang_move_t;
                                        (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                                    }
                                    17 => {
                                        (*n).data.addsub = (*exp).assign as *mut mln_lang_addsub_t;
                                        (*n).pos = (*n).data.addsub as *mut libc::c_void;
                                    }
                                    18 => {
                                        (*n).data.muldiv = (*exp).assign as *mut mln_lang_muldiv_t;
                                        (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                                    }
                                    19 => {
                                        (*n).data.not = (*exp).assign as *mut mln_lang_not_t;
                                        (*n).pos = (*n).data.not as *mut libc::c_void;
                                    }
                                    20 => {
                                        (*n).data.suffix = (*exp).assign as *mut mln_lang_suffix_t;
                                    }
                                    21 => {
                                        (*n).data.locate = (*exp).assign as *mut mln_lang_locate_t;
                                    }
                                    22 => {
                                        (*n).data.spec = (*exp).assign as *mut mln_lang_spec_t;
                                    }
                                    23 => {
                                        (*n).data.factor = (*exp).assign as *mut mln_lang_factor_t;
                                    }
                                    _ => {
                                        (*n)
                                            .data
                                            .elemlist = (*exp).assign as *mut mln_lang_elemlist_t;
                                    }
                                }
                            }
                            n
                        });
                        if node.is_null() {
                            __mln_lang_errmsg(
                                ctx,
                                b"Stack is full.\0" as *const u8 as *const libc::c_char
                                    as *mut libc::c_char,
                            );
                            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                            return;
                        }
                        (mln_lang_stack_map[(*node).type_0 as usize])
                            .expect("non-null function pointer")(ctx);
                        return;
                    } else {
                        (*node).set_call(1 as libc::c_int as mln_u32_t);
                        (*node).set_step(6 as libc::c_int as mln_u32_t);
                        if mln_lang_stack_handler_funccall_run(
                            ctx,
                            node,
                            (*(*(*node).ret_var).val).data.call,
                        ) < 0 as libc::c_int
                        {
                            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                            return;
                        }
                    }
                    current_block = 5131379528150656272;
                } else if (*node).step() as libc::c_int == 6 as libc::c_int {
                    if (*node).call() != 0 {
                        if mln_lang_withdraw_until_func(ctx) < 0 as libc::c_int {
                            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                            return;
                        }
                        (*node).set_call(0 as libc::c_int as mln_u32_t);
                        res = (*ctx).ret_var;
                        if (*(*(*ctx).ret_var).val).type_0 == 8 as libc::c_int {
                            current_block = 8995598215817426579;
                        } else {
                            current_block = 2704538829018177290;
                        }
                    } else {
                        current_block = 2704538829018177290;
                    }
                    match current_block {
                        8995598215817426579 => {}
                        _ => {
                            (*node).set_step(7 as libc::c_int as mln_u32_t);
                            current_block = 16835640586586273334;
                        }
                    }
                } else if (*node).step() as libc::c_int == 7 as libc::c_int {
                    current_block = 16835640586586273334;
                } else {
                    let mut n: *mut mln_lang_stack_node_t = ({
                        let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                        if !n_0.is_null()
                            && {
                                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                                (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                            }
                        {
                            (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                        }
                        n_0
                    });
                    if !n.is_null() {
                        if !((*n).ret_var).is_null() {
                            __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                            (*n).ret_var = 0 as *mut mln_lang_var_t;
                        }
                        if !((*n).ret_var2).is_null() {
                            __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                            (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                        }
                    }
                    while !((*ctx).run_stack_top).is_null()
                        && (*(*ctx).run_stack_top).step() as libc::c_int
                            == -(1 as libc::c_int)
                    {
                        let mut n: *mut mln_lang_stack_node_t = ({
                            let mut n_0: *mut mln_lang_stack_node_t = (*ctx)
                                .run_stack_top;
                            if !n_0.is_null()
                                && {
                                    (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                                    (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                                }
                            {
                                (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                            }
                            n_0
                        });
                        if !n.is_null() {
                            if !((*n).ret_var).is_null() {
                                __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                                (*n).ret_var = 0 as *mut mln_lang_var_t;
                            }
                            if !((*n).ret_var2).is_null() {
                                __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                            }
                        }
                    }
                    current_block = 5131379528150656272;
                }
                match current_block {
                    5131379528150656272 => {}
                    16835640586586273334 => {}
                    _ => {
                        res_0 = (*ctx).ret_var;
                        (*node).set_call(1 as libc::c_int as mln_u32_t);
                        (*node).set_step(6 as libc::c_int as mln_u32_t);
                        if mln_lang_stack_handler_funccall_run(
                            ctx,
                            node,
                            (*(*res_0).val).data.call,
                        ) < 0 as libc::c_int
                        {
                            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                            return;
                        }
                        current_block = 5131379528150656272;
                    }
                }
            }
            match current_block {
                5131379528150656272 => {}
                _ => {
                    match current_block {
                        14372067307257457201 => {
                            (*node).set_call(1 as libc::c_int as mln_u32_t);
                            (*node).set_step(3 as libc::c_int as mln_u32_t);
                            if mln_lang_stack_handler_funccall_run(
                                ctx,
                                node,
                                (*(*res).val).data.call,
                            ) < 0 as libc::c_int
                            {
                                (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                                return;
                            }
                        }
                        _ => {
                            cur = ({
                                let mut n: *mut mln_lang_stack_node_t = (*ctx)
                                    .run_stack_top;
                                if !n.is_null()
                                    && {
                                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                                        (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                                    }
                                {
                                    (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                                }
                                n
                            });
                            tmp = *cur;
                            if !((*locate).next).is_null() {
                                node = ({
                                    let mut n: *mut mln_lang_stack_node_t = 0
                                        as *mut mln_lang_stack_node_t;
                                    if ((*ctx).run_stack_top).is_null() {
                                        (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                                        n = (*ctx).run_stack_top;
                                    } else if (((*ctx).run_stack_top)
                                        .offset_from(((*ctx).run_stack).as_mut_ptr())
                                        as libc::c_long) < 1024 as libc::c_int as libc::c_long
                                    {
                                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                                        n = (*ctx).run_stack_top;
                                    }
                                    if !n.is_null() {
                                        (*n).type_0 = M_LSNT_LOCATE;
                                        (*n).pos = 0 as *mut libc::c_void;
                                        (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                                        (*n).ret_var = (*n).ret_var2;
                                        (*n).set_step(0 as libc::c_int as mln_u32_t);
                                        (*n).set_call(0 as libc::c_int as mln_u32_t);
                                        match M_LSNT_LOCATE as libc::c_int {
                                            0 => {
                                                (*n).data.stm = (*locate).next as *mut mln_lang_stm_t;
                                            }
                                            1 => {
                                                (*n)
                                                    .data
                                                    .funcdef = (*locate).next as *mut mln_lang_funcdef_t;
                                            }
                                            2 => {
                                                (*n).data.set = (*locate).next as *mut mln_lang_set_t;
                                            }
                                            3 => {
                                                (*n)
                                                    .data
                                                    .set_stm = (*locate).next as *mut mln_lang_setstm_t;
                                            }
                                            4 => {
                                                (*n).data.block = (*locate).next as *mut mln_lang_block_t;
                                            }
                                            5 => {
                                                (*n).data.w = (*locate).next as *mut mln_lang_while_t;
                                            }
                                            6 => {
                                                (*n).data.sw = (*locate).next as *mut mln_lang_switch_t;
                                            }
                                            7 => {
                                                (*n)
                                                    .data
                                                    .sw_stm = (*locate).next as *mut mln_lang_switchstm_t;
                                            }
                                            8 => {
                                                (*n).data.f = (*locate).next as *mut mln_lang_for_t;
                                            }
                                            9 => {
                                                (*n).data.i = (*locate).next as *mut mln_lang_if_t;
                                            }
                                            10 => {
                                                (*n).data.exp = (*locate).next as *mut mln_lang_exp_t;
                                            }
                                            11 => {
                                                (*n).data.assign = (*locate).next as *mut mln_lang_assign_t;
                                            }
                                            12 => {
                                                (*n)
                                                    .data
                                                    .logiclow = (*locate).next as *mut mln_lang_logiclow_t;
                                            }
                                            13 => {
                                                (*n)
                                                    .data
                                                    .logichigh = (*locate).next as *mut mln_lang_logichigh_t;
                                                (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                                            }
                                            14 => {
                                                (*n)
                                                    .data
                                                    .relativelow = (*locate).next
                                                    as *mut mln_lang_relativelow_t;
                                                (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                                            }
                                            15 => {
                                                (*n)
                                                    .data
                                                    .relativehigh = (*locate).next
                                                    as *mut mln_lang_relativehigh_t;
                                                (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                                            }
                                            16 => {
                                                (*n).data.move_0 = (*locate).next as *mut mln_lang_move_t;
                                                (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                                            }
                                            17 => {
                                                (*n).data.addsub = (*locate).next as *mut mln_lang_addsub_t;
                                                (*n).pos = (*n).data.addsub as *mut libc::c_void;
                                            }
                                            18 => {
                                                (*n).data.muldiv = (*locate).next as *mut mln_lang_muldiv_t;
                                                (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                                            }
                                            19 => {
                                                (*n).data.not = (*locate).next as *mut mln_lang_not_t;
                                                (*n).pos = (*n).data.not as *mut libc::c_void;
                                            }
                                            20 => {
                                                (*n).data.suffix = (*locate).next as *mut mln_lang_suffix_t;
                                            }
                                            21 => {
                                                (*n).data.locate = (*locate).next;
                                            }
                                            22 => {
                                                (*n).data.spec = (*locate).next as *mut mln_lang_spec_t;
                                            }
                                            23 => {
                                                (*n).data.factor = (*locate).next as *mut mln_lang_factor_t;
                                            }
                                            _ => {
                                                (*n)
                                                    .data
                                                    .elemlist = (*locate).next as *mut mln_lang_elemlist_t;
                                            }
                                        }
                                    }
                                    n
                                });
                                if node.is_null() {
                                    __mln_lang_errmsg(
                                        ctx,
                                        b"Stack is full.\0" as *const u8 as *const libc::c_char
                                            as *mut libc::c_char,
                                    );
                                    let mut n: *mut mln_lang_stack_node_t = &mut tmp;
                                    if !n.is_null() {
                                        if !((*n).ret_var).is_null() {
                                            __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                                            (*n).ret_var = 0 as *mut mln_lang_var_t;
                                        }
                                        if !((*n).ret_var2).is_null() {
                                            __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                                            (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                                        }
                                    }
                                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                                    return;
                                }
                                if (*(*locate).next).op as libc::c_uint
                                    == M_LOCATE_NONE as libc::c_int as libc::c_uint
                                {
                                    (*node).set_step(7 as libc::c_int as mln_u32_t);
                                } else if (*(*locate).next).op as libc::c_uint
                                    == M_LOCATE_PROPERTY as libc::c_int as libc::c_uint
                                {
                                    (*node).set_step(4 as libc::c_int as mln_u32_t);
                                } else if (*(*locate).next).op as libc::c_uint
                                    == M_LOCATE_INDEX as libc::c_int as libc::c_uint
                                {
                                    (*node).set_step(1 as libc::c_int as mln_u32_t);
                                } else {
                                    (*node).set_step(5 as libc::c_int as mln_u32_t);
                                    if !(tmp.ret_var2).is_null() {
                                        (*node).ret_var2 = tmp.ret_var2;
                                        tmp.ret_var2 = 0 as *mut mln_lang_var_t;
                                    }
                                }
                            } else {
                                node = 0 as *mut mln_lang_stack_node_t;
                            }
                            let mut n: *mut mln_lang_stack_node_t = &mut tmp;
                            if !n.is_null() {
                                if !((*n).ret_var).is_null() {
                                    __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                                    (*n).ret_var = 0 as *mut mln_lang_var_t;
                                }
                                if !((*n).ret_var2).is_null() {
                                    __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                                }
                            }
                            if !node.is_null() {
                                (mln_lang_stack_map[(*node).type_0 as usize])
                                    .expect("non-null function pointer")(ctx);
                                return;
                            }
                        }
                    }
                }
            }
        }
        return;
    };
}
#[inline]
unsafe extern "C" fn mln_lang_stack_handler_funccall_run(
    mut ctx: *mut mln_lang_ctx_t,
    mut node: *mut mln_lang_stack_node_t,
    mut funccall: *mut mln_lang_funccall_val_t,
) -> libc::c_int {
    let mut scope: *mut mln_lang_scope_t = 0 as *mut mln_lang_scope_t;
    let mut prototype: *mut mln_lang_func_detail_t = (*funccall).prototype;
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut newvar: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut scan: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut _this: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"this\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    let mut i: mln_size_t = 0;
    let mut j: mln_size_t = 0;
    let mut n: mln_size_t = 0;
    let mut m: mln_size_t = 0;
    let mut type_0: mln_s32_t = 0;
    let mut funcname: *mut mln_string_t = (*funccall).name;
    let mut args_array: *mut mln_lang_array_t = 0 as *mut mln_lang_array_t;
    let mut sym: *mut mln_lang_symbol_node_t = 0 as *mut mln_lang_symbol_node_t;
    if prototype.is_null() {
        if ((*funccall).object).is_null() {
            loop {
                sym = __mln_lang_symbol_node_search(ctx, funcname, 0 as libc::c_int);
                if sym.is_null()
                    || (*sym).type_0 as libc::c_uint
                        != M_LANG_SYMBOL_VAR as libc::c_int as libc::c_uint
                {
                    __mln_lang_errmsg(
                        ctx,
                        b"Invalid function, No such prototype.\0" as *const u8
                            as *const libc::c_char as *mut libc::c_char,
                    );
                    return -(1 as libc::c_int);
                }
                var = (*sym).data.var;
                type_0 = (*(*var).val).type_0;
                if type_0 == 6 as libc::c_int {
                    (*funccall).prototype = (*(*var).val).data.func;
                    prototype = (*funccall).prototype;
                    break;
                } else {
                    if type_0 != 4 as libc::c_int {
                        __mln_lang_errmsg(
                            ctx,
                            b"Invalid function, No such prototype.\0" as *const u8
                                as *const libc::c_char as *mut libc::c_char,
                        );
                        return -(1 as libc::c_int);
                    }
                    funcname = (*(*var).val).data.s;
                }
            }
        } else {
            loop {
                var = __mln_lang_set_member_search(
                    (*(*(*funccall).object).data.obj).members,
                    funcname,
                );
                if var.is_null() {
                    sym = __mln_lang_symbol_node_search(ctx, funcname, 0 as libc::c_int);
                    if sym.is_null()
                        || (*sym).type_0 as libc::c_uint
                            != M_LANG_SYMBOL_VAR as libc::c_int as libc::c_uint
                    {
                        __mln_lang_errmsg(
                            ctx,
                            b"Invalid function, No such prototype.\0" as *const u8
                                as *const libc::c_char as *mut libc::c_char,
                        );
                        return -(1 as libc::c_int);
                    }
                    if (*(*(*sym).data.var).val).type_0 != 4 as libc::c_int {
                        __mln_lang_errmsg(
                            ctx,
                            b"Invalid function, No such prototype.\0" as *const u8
                                as *const libc::c_char as *mut libc::c_char,
                        );
                        return -(1 as libc::c_int);
                    }
                    funcname = (*(*(*sym).data.var).val).data.s;
                } else {
                    type_0 = (*(*var).val).type_0;
                    if type_0 == 6 as libc::c_int {
                        (*funccall).prototype = (*(*var).val).data.func;
                        prototype = (*funccall).prototype;
                        break;
                    } else {
                        if type_0 != 4 as libc::c_int {
                            __mln_lang_errmsg(
                                ctx,
                                b"Invalid function, No such prototype.\0" as *const u8
                                    as *const libc::c_char as *mut libc::c_char,
                            );
                            return -(1 as libc::c_int);
                        }
                        funcname = (*(*var).val).data.s;
                    }
                }
            }
        }
    }
    scope = ({
        let mut s: *mut mln_lang_scope_t = 0 as *mut mln_lang_scope_t;
        let mut last: *mut mln_lang_scope_t = 0 as *mut mln_lang_scope_t;
        last = (*ctx).scope_top;
        if last.is_null() {
            (*ctx).scope_top = ((*ctx).scopes).as_mut_ptr();
            s = (*ctx).scope_top;
        } else if (last.offset_from(((*ctx).scopes).as_mut_ptr()) as libc::c_long)
            < 1024 as libc::c_int as libc::c_long
        {
            (*ctx).scope_top = ((*ctx).scope_top).offset(1);
            s = (*ctx).scope_top;
        }
        if !s.is_null() {
            (*s).ctx = ctx;
            (*s).type_0 = M_LANG_SCOPE_TYPE_FUNC;
            if !funcname.is_null() {
                (*s)
                    .name = ({
                    let mut __s: *mut mln_string_t = funcname;
                    (*__s).set_ref_0((*__s).ref_0() + 1);
                    (*__s).ref_0();
                    __s
                });
            } else {
                (*s).name = 0 as *mut mln_string_t;
            }
            (*s).cur_stack = node;
            (*s).entry = 0 as *mut mln_lang_stm_t;
            (*s)
                .layer = if last.is_null() {
                1 as libc::c_int as libc::c_ulong
            } else {
                ((*last).layer).wrapping_add(1 as libc::c_int as libc::c_ulong)
            };
            (*s).sym_tail = 0 as *mut mln_lang_symbol_node_t;
            (*s).sym_head = (*s).sym_tail;
        }
        s
    });
    if scope.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"Scope stack is full.\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    if !((*funccall).object).is_null() {
        newvar = __mln_lang_var_new(
            ctx,
            &mut _this,
            M_LANG_VAR_NORMAL,
            (*funccall).object,
            0 as *mut mln_lang_set_detail_t,
        );
        if newvar.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            return -(1 as libc::c_int);
        }
        if __mln_lang_symbol_node_join(
            ctx,
            M_LANG_SYMBOL_VAR,
            newvar as *mut libc::c_void,
        ) < 0 as libc::c_int
        {
            __mln_lang_var_free(newvar as *mut libc::c_void);
            return -(1 as libc::c_int);
        }
    }
    n = (*prototype).args.nelts;
    m = (*funccall).args.nelts;
    i = 0 as libc::c_int as mln_size_t;
    j = 0 as libc::c_int as mln_size_t;
    while i < n {
        scan = *((*prototype).args.elts as *mut *mut mln_lang_var_t).offset(i as isize);
        var = if j >= m {
            0 as *mut mln_lang_var_t
        } else {
            *((*funccall).args.elts as *mut *mut mln_lang_var_t).offset(j as isize)
        };
        if var.is_null() {
            newvar = __mln_lang_var_create_nil(ctx, (*scan).name);
            if newvar.is_null() {
                __mln_lang_errmsg(
                    ctx,
                    b"No memory.\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                );
                return -(1 as libc::c_int);
            }
        } else {
            if (*var).ref_0 == 0 {
                (*var).ref_0 = ((*var).ref_0).wrapping_add(1);
                (*var).ref_0;
                newvar = var;
                (*newvar)
                    .name = ({
                    let mut __s: *mut mln_string_t = (*scan).name;
                    (*__s).set_ref_0((*__s).ref_0() + 1);
                    (*__s).ref_0();
                    __s
                });
            } else {
                newvar = mln_lang_var_transform(ctx, var, scan);
                if newvar.is_null() {
                    __mln_lang_errmsg(
                        ctx,
                        b"No memory.\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                    );
                    return -(1 as libc::c_int);
                }
            }
            j = j.wrapping_add(1);
            j;
        }
        if __mln_lang_symbol_node_join(
            ctx,
            M_LANG_SYMBOL_VAR,
            newvar as *mut libc::c_void,
        ) < 0 as libc::c_int
        {
            __mln_lang_var_free(newvar as *mut libc::c_void);
            return -(1 as libc::c_int);
        }
        i = i.wrapping_add(1);
        i;
    }
    if j < m {
        args_array = mln_lang_funccall_run_build_args(ctx);
        if args_array.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            return -(1 as libc::c_int);
        }
        while j < m {
            var = *((*funccall).args.elts as *mut *mut mln_lang_var_t)
                .offset(j as isize);
            if mln_lang_funcall_run_add_args(ctx, args_array, var) < 0 as libc::c_int {
                __mln_lang_errmsg(
                    ctx,
                    b"No memory.\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                );
                return -(1 as libc::c_int);
            }
            j = j.wrapping_add(1);
            j;
        }
    }
    n = (*prototype).closure.nelts;
    i = 0 as libc::c_int as mln_size_t;
    while i < n {
        scan = *((*prototype).closure.elts as *mut *mut mln_lang_var_t)
            .offset(i as isize);
        (*scan).ref_0 = ((*scan).ref_0).wrapping_add(1);
        (*scan).ref_0;
        newvar = scan;
        if __mln_lang_symbol_node_join(
            ctx,
            M_LANG_SYMBOL_VAR,
            newvar as *mut libc::c_void,
        ) < 0 as libc::c_int
        {
            __mln_lang_var_free(newvar as *mut libc::c_void);
            return -(1 as libc::c_int);
        }
        i = i.wrapping_add(1);
        i;
    }
    mln_lang_ctx_reset_ret_var(ctx);
    if (*prototype).type_0 as libc::c_uint
        == M_FUNC_INTERNAL as libc::c_int as libc::c_uint
    {
        if ((*prototype).data.process).is_none() {
            __mln_lang_errmsg(
                ctx,
                b"Not implemented.\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
            return -(1 as libc::c_int);
        }
        pthread_mutex_lock(&mut (*(*ctx).lang).lock);
        var = ((*prototype).data.process).expect("non-null function pointer")(ctx);
        if var.is_null() {
            pthread_mutex_unlock(&mut (*(*ctx).lang).lock);
            return -(1 as libc::c_int);
        }
        __mln_lang_ctx_set_ret_var(ctx, var);
        pthread_mutex_unlock(&mut (*(*ctx).lang).lock);
    } else if !((*prototype).data.stm).is_null() {
        (*scope).entry = (*prototype).data.stm;
        node = ({
            let mut n_0: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
            if ((*ctx).run_stack_top).is_null() {
                (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                n_0 = (*ctx).run_stack_top;
            } else if (((*ctx).run_stack_top)
                .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                < 1024 as libc::c_int as libc::c_long
            {
                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                n_0 = (*ctx).run_stack_top;
            }
            if !n_0.is_null() {
                (*n_0).type_0 = M_LSNT_STM;
                (*n_0).pos = 0 as *mut libc::c_void;
                (*n_0).ret_var2 = 0 as *mut mln_lang_var_t;
                (*n_0).ret_var = (*n_0).ret_var2;
                (*n_0).set_step(0 as libc::c_int as mln_u32_t);
                (*n_0).set_call(0 as libc::c_int as mln_u32_t);
                match M_LSNT_STM as libc::c_int {
                    0 => {
                        (*n_0).data.stm = (*prototype).data.stm;
                    }
                    1 => {
                        (*n_0)
                            .data
                            .funcdef = (*prototype).data.stm as *mut mln_lang_funcdef_t;
                    }
                    2 => {
                        (*n_0).data.set = (*prototype).data.stm as *mut mln_lang_set_t;
                    }
                    3 => {
                        (*n_0)
                            .data
                            .set_stm = (*prototype).data.stm as *mut mln_lang_setstm_t;
                    }
                    4 => {
                        (*n_0)
                            .data
                            .block = (*prototype).data.stm as *mut mln_lang_block_t;
                    }
                    5 => {
                        (*n_0).data.w = (*prototype).data.stm as *mut mln_lang_while_t;
                    }
                    6 => {
                        (*n_0).data.sw = (*prototype).data.stm as *mut mln_lang_switch_t;
                    }
                    7 => {
                        (*n_0)
                            .data
                            .sw_stm = (*prototype).data.stm as *mut mln_lang_switchstm_t;
                    }
                    8 => {
                        (*n_0).data.f = (*prototype).data.stm as *mut mln_lang_for_t;
                    }
                    9 => {
                        (*n_0).data.i = (*prototype).data.stm as *mut mln_lang_if_t;
                    }
                    10 => {
                        (*n_0).data.exp = (*prototype).data.stm as *mut mln_lang_exp_t;
                    }
                    11 => {
                        (*n_0)
                            .data
                            .assign = (*prototype).data.stm as *mut mln_lang_assign_t;
                    }
                    12 => {
                        (*n_0)
                            .data
                            .logiclow = (*prototype).data.stm
                            as *mut mln_lang_logiclow_t;
                    }
                    13 => {
                        (*n_0)
                            .data
                            .logichigh = (*prototype).data.stm
                            as *mut mln_lang_logichigh_t;
                        (*n_0).pos = (*n_0).data.logichigh as *mut libc::c_void;
                    }
                    14 => {
                        (*n_0)
                            .data
                            .relativelow = (*prototype).data.stm
                            as *mut mln_lang_relativelow_t;
                        (*n_0).pos = (*n_0).data.relativelow as *mut libc::c_void;
                    }
                    15 => {
                        (*n_0)
                            .data
                            .relativehigh = (*prototype).data.stm
                            as *mut mln_lang_relativehigh_t;
                        (*n_0).pos = (*n_0).data.relativehigh as *mut libc::c_void;
                    }
                    16 => {
                        (*n_0)
                            .data
                            .move_0 = (*prototype).data.stm as *mut mln_lang_move_t;
                        (*n_0).pos = (*n_0).data.move_0 as *mut libc::c_void;
                    }
                    17 => {
                        (*n_0)
                            .data
                            .addsub = (*prototype).data.stm as *mut mln_lang_addsub_t;
                        (*n_0).pos = (*n_0).data.addsub as *mut libc::c_void;
                    }
                    18 => {
                        (*n_0)
                            .data
                            .muldiv = (*prototype).data.stm as *mut mln_lang_muldiv_t;
                        (*n_0).pos = (*n_0).data.muldiv as *mut libc::c_void;
                    }
                    19 => {
                        (*n_0).data.not = (*prototype).data.stm as *mut mln_lang_not_t;
                        (*n_0).pos = (*n_0).data.not as *mut libc::c_void;
                    }
                    20 => {
                        (*n_0)
                            .data
                            .suffix = (*prototype).data.stm as *mut mln_lang_suffix_t;
                    }
                    21 => {
                        (*n_0)
                            .data
                            .locate = (*prototype).data.stm as *mut mln_lang_locate_t;
                    }
                    22 => {
                        (*n_0).data.spec = (*prototype).data.stm as *mut mln_lang_spec_t;
                    }
                    23 => {
                        (*n_0)
                            .data
                            .factor = (*prototype).data.stm as *mut mln_lang_factor_t;
                    }
                    _ => {
                        (*n_0)
                            .data
                            .elemlist = (*prototype).data.stm
                            as *mut mln_lang_elemlist_t;
                    }
                }
            }
            n_0
        });
        if node.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"Stack is full.\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
            return -(1 as libc::c_int);
        }
    }
    return 0 as libc::c_int;
}
#[inline]
unsafe extern "C" fn mln_lang_funcall_run_add_args(
    mut ctx: *mut mln_lang_ctx_t,
    mut array: *mut mln_lang_array_t,
    mut arg: *mut mln_lang_var_t,
) -> libc::c_int {
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    var = __mln_lang_array_get(ctx, array, 0 as *mut mln_lang_var_t);
    if var.is_null() {
        return -(1 as libc::c_int);
    }
    if mln_lang_var_value_set_string_ref(ctx, var, arg) < 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
#[inline]
unsafe extern "C" fn mln_lang_funccall_run_build_args(
    mut ctx: *mut mln_lang_ctx_t,
) -> *mut mln_lang_array_t {
    let mut name: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"args\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    let mut array: *mut mln_lang_array_t = 0 as *mut mln_lang_array_t;
    let mut val: *mut mln_lang_val_t = 0 as *mut mln_lang_val_t;
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    array = __mln_lang_array_new(ctx);
    if array.is_null() {
        return 0 as *mut mln_lang_array_t;
    }
    val = __mln_lang_val_new(ctx, 7 as libc::c_int, array as *mut libc::c_void);
    if val.is_null() {
        __mln_lang_array_free(array);
        return 0 as *mut mln_lang_array_t;
    }
    var = __mln_lang_var_new(
        ctx,
        &mut name,
        M_LANG_VAR_NORMAL,
        val,
        0 as *mut mln_lang_set_detail_t,
    );
    if var.is_null() {
        __mln_lang_val_free(val as *mut libc::c_void);
        return 0 as *mut mln_lang_array_t;
    }
    if __mln_lang_symbol_node_join(ctx, M_LANG_SYMBOL_VAR, var as *mut libc::c_void)
        < 0 as libc::c_int
    {
        __mln_lang_var_free(var as *mut libc::c_void);
        return 0 as *mut mln_lang_array_t;
    }
    return array;
}
unsafe extern "C" fn mln_lang_stack_handler_spec(mut ctx: *mut mln_lang_ctx_t) {
    let mut current_block: u64;
    let mut node: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
    let mut spec: *mut mln_lang_spec_t = (*node).data.spec;
    let mut ret_var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    if (*spec).op as libc::c_uint == M_SPEC_REFER as libc::c_int as libc::c_uint {
        __mln_lang_errmsg(
            ctx,
            b"'&' Not allowed.\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
        return;
    }
    if (*node).step() as libc::c_int == 0 as libc::c_int {
        (*node).set_step(1 as libc::c_int as mln_u32_t);
        let mut data: mln_u8ptr_t = 0 as mln_u8ptr_t;
        let mut type_0: mln_lang_stack_node_type_t = M_LSNT_STM;
        mln_lang_stack_node_reset_ret_val(node);
        mln_lang_ctx_reset_ret_var(ctx);
        match (*spec).op as libc::c_uint {
            0 | 1 | 2 | 3 | 4 => {
                data = (*spec).data.spec as mln_u8ptr_t;
                type_0 = M_LSNT_SPEC;
            }
            5 => {
                if mln_lang_stack_handler_spec_new(ctx, (*spec).data.set_name)
                    < 0 as libc::c_int
                {
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                (*node).set_step(2 as libc::c_int as mln_u32_t);
            }
            6 => {
                if ((*spec).data.exp).is_null() {
                    ret_var = __mln_lang_var_create_nil(ctx, 0 as *mut mln_string_t);
                    if ret_var.is_null() {
                        __mln_lang_errmsg(
                            ctx,
                            b"No memory.\0" as *const u8 as *const libc::c_char
                                as *mut libc::c_char,
                        );
                        (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                        return;
                    }
                } else {
                    data = (*spec).data.exp as mln_u8ptr_t;
                    type_0 = M_LSNT_EXP;
                }
                (*node).set_step(2 as libc::c_int as mln_u32_t);
            }
            _ => {
                data = (*spec).data.factor as mln_u8ptr_t;
                type_0 = M_LSNT_FACTOR;
                (*node).set_step(-(1 as libc::c_int) as mln_u32_t);
            }
        }
        if !data.is_null() {
            if (*spec).op as libc::c_uint == M_SPEC_FACTOR as libc::c_int as libc::c_uint
            {
                let mut n: *mut mln_lang_stack_node_t = ({
                    let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                    if !n_0.is_null()
                        && {
                            (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                            (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                        }
                    {
                        (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                    }
                    n_0
                });
                if !n.is_null() {
                    if !((*n).ret_var).is_null() {
                        __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                        (*n).ret_var = 0 as *mut mln_lang_var_t;
                    }
                    if !((*n).ret_var2).is_null() {
                        __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                        (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    }
                }
                while !((*ctx).run_stack_top).is_null()
                    && (*(*ctx).run_stack_top).step() as libc::c_int
                        == -(1 as libc::c_int)
                {
                    let mut n: *mut mln_lang_stack_node_t = ({
                        let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                        if !n_0.is_null()
                            && {
                                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                                (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                            }
                        {
                            (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                        }
                        n_0
                    });
                    if !n.is_null() {
                        if !((*n).ret_var).is_null() {
                            __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                            (*n).ret_var = 0 as *mut mln_lang_var_t;
                        }
                        if !((*n).ret_var2).is_null() {
                            __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                            (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                        }
                    }
                }
            }
            node = ({
                let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
                if ((*ctx).run_stack_top).is_null() {
                    (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                    n = (*ctx).run_stack_top;
                } else if (((*ctx).run_stack_top)
                    .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                    < 1024 as libc::c_int as libc::c_long
                {
                    (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                    n = (*ctx).run_stack_top;
                }
                if !n.is_null() {
                    (*n).type_0 = type_0;
                    (*n).pos = 0 as *mut libc::c_void;
                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    (*n).ret_var = (*n).ret_var2;
                    (*n).set_step(0 as libc::c_int as mln_u32_t);
                    (*n).set_call(0 as libc::c_int as mln_u32_t);
                    match type_0 as libc::c_uint {
                        0 => {
                            (*n).data.stm = data as *mut mln_lang_stm_t;
                        }
                        1 => {
                            (*n).data.funcdef = data as *mut mln_lang_funcdef_t;
                        }
                        2 => {
                            (*n).data.set = data as *mut mln_lang_set_t;
                        }
                        3 => {
                            (*n).data.set_stm = data as *mut mln_lang_setstm_t;
                        }
                        4 => {
                            (*n).data.block = data as *mut mln_lang_block_t;
                        }
                        5 => {
                            (*n).data.w = data as *mut mln_lang_while_t;
                        }
                        6 => {
                            (*n).data.sw = data as *mut mln_lang_switch_t;
                        }
                        7 => {
                            (*n).data.sw_stm = data as *mut mln_lang_switchstm_t;
                        }
                        8 => {
                            (*n).data.f = data as *mut mln_lang_for_t;
                        }
                        9 => {
                            (*n).data.i = data as *mut mln_lang_if_t;
                        }
                        10 => {
                            (*n).data.exp = data as *mut mln_lang_exp_t;
                        }
                        11 => {
                            (*n).data.assign = data as *mut mln_lang_assign_t;
                        }
                        12 => {
                            (*n).data.logiclow = data as *mut mln_lang_logiclow_t;
                        }
                        13 => {
                            (*n).data.logichigh = data as *mut mln_lang_logichigh_t;
                            (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                        }
                        14 => {
                            (*n).data.relativelow = data as *mut mln_lang_relativelow_t;
                            (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                        }
                        15 => {
                            (*n)
                                .data
                                .relativehigh = data as *mut mln_lang_relativehigh_t;
                            (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                        }
                        16 => {
                            (*n).data.move_0 = data as *mut mln_lang_move_t;
                            (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                        }
                        17 => {
                            (*n).data.addsub = data as *mut mln_lang_addsub_t;
                            (*n).pos = (*n).data.addsub as *mut libc::c_void;
                        }
                        18 => {
                            (*n).data.muldiv = data as *mut mln_lang_muldiv_t;
                            (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                        }
                        19 => {
                            (*n).data.not = data as *mut mln_lang_not_t;
                            (*n).pos = (*n).data.not as *mut libc::c_void;
                        }
                        20 => {
                            (*n).data.suffix = data as *mut mln_lang_suffix_t;
                        }
                        21 => {
                            (*n).data.locate = data as *mut mln_lang_locate_t;
                        }
                        22 => {
                            (*n).data.spec = data as *mut mln_lang_spec_t;
                        }
                        23 => {
                            (*n).data.factor = data as *mut mln_lang_factor_t;
                        }
                        _ => {
                            (*n).data.elemlist = data as *mut mln_lang_elemlist_t;
                        }
                    }
                }
                n
            });
            if node.is_null() {
                __mln_lang_errmsg(
                    ctx,
                    b"Stack is full.\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                );
                (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                return;
            }
            (mln_lang_stack_map[(*node).type_0 as usize])
                .expect("non-null function pointer")(ctx);
            return;
        }
    } else {
        if (*node).step() as libc::c_int == 1 as libc::c_int {
            (*node).set_step(2 as libc::c_int as mln_u32_t);
            ret_var = (*ctx).ret_var;
            if (*(*ret_var).val).type_0 == 8 as libc::c_int {
                current_block = 15775094679234918476;
            } else {
                let mut handler: mln_lang_op = None;
                let mut method: *mut mln_lang_method_t = 0 as *mut mln_lang_method_t;
                method = mln_lang_methods[(*(*ret_var).val).type_0 as usize];
                if method.is_null() {
                    __mln_lang_errmsg(
                        ctx,
                        b"Operation NOT support.\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                    );
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                match (*spec).op as libc::c_uint {
                    0 => {
                        handler = (*method).negative_handler;
                    }
                    1 => {
                        handler = (*method).reverse_handler;
                    }
                    3 => {
                        handler = (*method).pinc_handler;
                    }
                    4 => {
                        handler = (*method).pdec_handler;
                    }
                    _ => {}
                }
                if handler.is_none() {
                    __mln_lang_errmsg(
                        ctx,
                        b"Operation NOT support.\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                    );
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                ret_var = 0 as *mut mln_lang_var_t;
                if ((*spec).op as libc::c_uint
                    == M_SPEC_INC as libc::c_int as libc::c_uint
                    || (*spec).op as libc::c_uint
                        == M_SPEC_DEC as libc::c_int as libc::c_uint)
                    && (*(*(*ctx).ret_var).val).not_modify() as libc::c_int != 0
                {
                    __mln_lang_errmsg(
                        ctx,
                        b"Operand cannot be changed.\0" as *const u8
                            as *const libc::c_char as *mut libc::c_char,
                    );
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                if handler
                    .expect(
                        "non-null function pointer",
                    )(ctx, &mut ret_var, (*ctx).ret_var, 0 as *mut mln_lang_var_t)
                    < 0 as libc::c_int
                {
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                mln_lang_stack_node_get_ctx_ret_var(node, ctx);
                __mln_lang_ctx_set_ret_var(ctx, ret_var);
                if (*(*ret_var).val).type_0 == 8 as libc::c_int {
                    current_block = 15775094679234918476;
                } else {
                    current_block = 15290951409301300595;
                }
            }
        } else if (*node).step() as libc::c_int == 2 as libc::c_int {
            if (*node).call() != 0 {
                if mln_lang_withdraw_until_func(ctx) < 0 as libc::c_int {
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                (*node).set_call(0 as libc::c_int as mln_u32_t);
                ret_var = (*ctx).ret_var;
                if (*(*(*ctx).ret_var).val).type_0 == 8 as libc::c_int {
                    current_block = 15775094679234918476;
                } else {
                    current_block = 15290951409301300595;
                }
            } else {
                current_block = 15290951409301300595;
            }
        } else if (*node).step() as libc::c_int == 3 as libc::c_int {
            if (*node).call() != 0 {
                if mln_lang_withdraw_until_func(ctx) < 0 as libc::c_int {
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                (*node).set_call(0 as libc::c_int as mln_u32_t);
            }
            mln_lang_ctx_get_node_ret_val(ctx, node);
            let mut n: *mut mln_lang_stack_node_t = ({
                let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                if !n_0.is_null()
                    && {
                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                        (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                    }
                {
                    (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                }
                n_0
            });
            if !n.is_null() {
                if !((*n).ret_var).is_null() {
                    __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                    (*n).ret_var = 0 as *mut mln_lang_var_t;
                }
                if !((*n).ret_var2).is_null() {
                    __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                }
            }
            while !((*ctx).run_stack_top).is_null()
                && (*(*ctx).run_stack_top).step() as libc::c_int == -(1 as libc::c_int)
            {
                let mut n: *mut mln_lang_stack_node_t = ({
                    let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                    if !n_0.is_null()
                        && {
                            (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                            (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                        }
                    {
                        (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                    }
                    n_0
                });
                if !n.is_null() {
                    if !((*n).ret_var).is_null() {
                        __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                        (*n).ret_var = 0 as *mut mln_lang_var_t;
                    }
                    if !((*n).ret_var2).is_null() {
                        __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                        (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    }
                }
            }
            current_block = 11674240781755647963;
        } else {
            current_block = 5132690516430580669;
        }
        match current_block {
            11674240781755647963 => {}
            _ => {
                match current_block {
                    15290951409301300595 => {
                        (*node).set_step(3 as libc::c_int as mln_u32_t);
                        if ((*spec).op as libc::c_uint
                            == M_SPEC_INC as libc::c_int as libc::c_uint
                            || (*spec).op as libc::c_uint
                                == M_SPEC_DEC as libc::c_int as libc::c_uint)
                            && !((*node).ret_var).is_null()
                            && !((*(*(*node).ret_var).val).func).is_null()
                        {
                            if mln_lang_watch_func_build(
                                ctx,
                                node,
                                (*(*(*node).ret_var).val).func,
                                (*(*(*node).ret_var).val).udata,
                                (*(*node).ret_var).val,
                            ) < 0 as libc::c_int
                            {
                                (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                                return;
                            }
                            mln_lang_stack_node_get_ctx_ret_var(node, ctx);
                            mln_lang_ctx_reset_ret_var(ctx);
                            current_block = 11674240781755647963;
                        } else {
                            current_block = 5132690516430580669;
                        }
                    }
                    15775094679234918476 => {
                        (*node).set_call(1 as libc::c_int as mln_u32_t);
                        if mln_lang_stack_handler_funccall_run(
                            ctx,
                            node,
                            (*(*ret_var).val).data.call,
                        ) < 0 as libc::c_int
                        {
                            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                            return;
                        }
                        current_block = 11674240781755647963;
                    }
                    _ => {}
                }
                match current_block {
                    11674240781755647963 => {}
                    _ => {
                        let mut n: *mut mln_lang_stack_node_t = ({
                            let mut n_0: *mut mln_lang_stack_node_t = (*ctx)
                                .run_stack_top;
                            if !n_0.is_null()
                                && {
                                    (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                                    (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                                }
                            {
                                (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                            }
                            n_0
                        });
                        if !n.is_null() {
                            if !((*n).ret_var).is_null() {
                                __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                                (*n).ret_var = 0 as *mut mln_lang_var_t;
                            }
                            if !((*n).ret_var2).is_null() {
                                __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                            }
                        }
                        while !((*ctx).run_stack_top).is_null()
                            && (*(*ctx).run_stack_top).step() as libc::c_int
                                == -(1 as libc::c_int)
                        {
                            let mut n: *mut mln_lang_stack_node_t = ({
                                let mut n_0: *mut mln_lang_stack_node_t = (*ctx)
                                    .run_stack_top;
                                if !n_0.is_null()
                                    && {
                                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                                        (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                                    }
                                {
                                    (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                                }
                                n_0
                            });
                            if !n.is_null() {
                                if !((*n).ret_var).is_null() {
                                    __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                                    (*n).ret_var = 0 as *mut mln_lang_var_t;
                                }
                                if !((*n).ret_var2).is_null() {
                                    __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                                }
                            }
                        }
                    }
                }
            }
        }
    };
}
#[inline]
unsafe extern "C" fn mln_lang_stack_handler_spec_new(
    mut ctx: *mut mln_lang_ctx_t,
    mut name: *mut mln_string_t,
) -> libc::c_int {
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut val: *mut mln_lang_val_t = 0 as *mut mln_lang_val_t;
    let mut obj: *mut mln_lang_object_t = 0 as *mut mln_lang_object_t;
    let mut sym: *mut mln_lang_symbol_node_t = 0 as *mut mln_lang_symbol_node_t;
    loop {
        sym = __mln_lang_symbol_node_search(ctx, name, 0 as libc::c_int);
        if sym.is_null() {
            sym = mln_lang_symbol_node_id_search(ctx, name);
            if sym.is_null() {
                break;
            }
            if (*sym).type_0 as libc::c_uint
                != M_LANG_SYMBOL_VAR as libc::c_int as libc::c_uint
            {
                break;
            }
            if (*(*(*sym).data.var).val).type_0 != 4 as libc::c_int {
                break;
            }
            name = (*(*(*sym).data.var).val).data.s;
            if name.is_null() {
                break;
            }
        } else if (*sym).type_0 as libc::c_uint
            == M_LANG_SYMBOL_SET as libc::c_int as libc::c_uint
        {
            obj = mln_lang_object_new(ctx, (*sym).data.set);
            if obj.is_null() {
                __mln_lang_errmsg(
                    ctx,
                    b"No memory.\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                );
                return -(1 as libc::c_int);
            }
            val = __mln_lang_val_new(ctx, 5 as libc::c_int, obj as *mut libc::c_void);
            if val.is_null() {
                __mln_lang_errmsg(
                    ctx,
                    b"No memory.\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                );
                mln_lang_object_free(obj);
                return -(1 as libc::c_int);
            }
            var = __mln_lang_var_new(
                ctx,
                0 as *mut mln_string_t,
                M_LANG_VAR_NORMAL,
                val,
                0 as *mut mln_lang_set_detail_t,
            );
            if var.is_null() {
                __mln_lang_errmsg(
                    ctx,
                    b"No memory.\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                );
                __mln_lang_val_free(val as *mut libc::c_void);
                return -(1 as libc::c_int);
            }
            __mln_lang_ctx_set_ret_var(ctx, var);
            return 0 as libc::c_int;
        } else {
            sym = mln_lang_symbol_node_id_search(ctx, name);
            if sym.is_null() {
                break;
            }
            if (*sym).type_0 as libc::c_uint
                != M_LANG_SYMBOL_VAR as libc::c_int as libc::c_uint
            {
                break;
            }
            if (*(*(*sym).data.var).val).type_0 != 4 as libc::c_int {
                break;
            }
            name = (*(*(*sym).data.var).val).data.s;
            if name.is_null() {
                break;
            }
        }
    }
    var = __mln_lang_var_create_nil(ctx, 0 as *mut mln_string_t);
    if var.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    __mln_lang_ctx_set_ret_var(ctx, var);
    return 0 as libc::c_int;
}
unsafe extern "C" fn mln_lang_stack_handler_factor(mut ctx: *mut mln_lang_ctx_t) {
    let mut node: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
    let mut factor: *mut mln_lang_factor_t = (*node).data.factor;
    let mut name: *mut mln_string_t = 0 as *mut mln_string_t;
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    if (*node).step() as libc::c_int == 0 as libc::c_int {
        (*node).set_step(1 as libc::c_int as mln_u32_t);
        match (*factor).type_0 as libc::c_uint {
            5 => {
                let mut sym: *mut mln_lang_symbol_node_t = 0
                    as *mut mln_lang_symbol_node_t;
                sym = mln_lang_symbol_node_id_search(ctx, (*factor).data.s_id);
                if !sym.is_null() {
                    if (*sym).type_0 as libc::c_uint
                        == M_LANG_SYMBOL_VAR as libc::c_int as libc::c_uint
                    {
                        (*(*sym).data.var)
                            .ref_0 = ((*(*sym).data.var).ref_0).wrapping_add(1);
                        (*(*sym).data.var).ref_0;
                        __mln_lang_ctx_set_ret_var(ctx, (*sym).data.var);
                    } else {
                        __mln_lang_errmsg(
                            ctx,
                            b"Invalid token. Token is a SET name, not a value or function.\0"
                                as *const u8 as *const libc::c_char as *mut libc::c_char,
                        );
                        (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                        return;
                    }
                } else {
                    name = mln_string_pool_dup((*ctx).pool, (*factor).data.s_id);
                    if name.is_null() {
                        __mln_lang_errmsg(
                            ctx,
                            b"No memory.\0" as *const u8 as *const libc::c_char
                                as *mut libc::c_char,
                        );
                        (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                        return;
                    }
                    var = __mln_lang_var_create_nil(ctx, name);
                    if var.is_null() {
                        __mln_lang_errmsg(
                            ctx,
                            b"No memory.\0" as *const u8 as *const libc::c_char
                                as *mut libc::c_char,
                        );
                        let mut __s: *mut mln_string_t = name;
                        if !__s.is_null() {
                            let ref mut fresh39 = (*__s).ref_0();
                            let fresh40 = *fresh39;
                            *fresh39 = (*fresh39).wrapping_sub(1);
                            if fresh40 <= 1 as libc::c_int as libc::c_ulong {
                                if (*__s).data_ref() == 0 && !((*__s).data).is_null() {
                                    if (*__s).pool() != 0 {
                                        mln_alloc_free((*__s).data as *mut libc::c_void);
                                    } else {
                                        free((*__s).data as *mut libc::c_void);
                                    }
                                }
                                if (*__s).pool() != 0 {
                                    mln_alloc_free(__s as *mut libc::c_void);
                                } else {
                                    free(__s as *mut libc::c_void);
                                }
                            }
                        }
                        (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                        return;
                    }
                    let mut __s: *mut mln_string_t = name;
                    if !__s.is_null() {
                        let ref mut fresh41 = (*__s).ref_0();
                        let fresh42 = *fresh41;
                        *fresh41 = (*fresh41).wrapping_sub(1);
                        if fresh42 <= 1 as libc::c_int as libc::c_ulong {
                            if (*__s).data_ref() == 0 && !((*__s).data).is_null() {
                                if (*__s).pool() != 0 {
                                    mln_alloc_free((*__s).data as *mut libc::c_void);
                                } else {
                                    free((*__s).data as *mut libc::c_void);
                                }
                            }
                            if (*__s).pool() != 0 {
                                mln_alloc_free(__s as *mut libc::c_void);
                            } else {
                                free(__s as *mut libc::c_void);
                            }
                        }
                    }
                    if __mln_lang_symbol_node_join(
                        ctx,
                        M_LANG_SYMBOL_VAR,
                        var as *mut libc::c_void,
                    ) < 0 as libc::c_int
                    {
                        __mln_lang_errmsg(
                            ctx,
                            b"No memory.\0" as *const u8 as *const libc::c_char
                                as *mut libc::c_char,
                        );
                        __mln_lang_var_free(var as *mut libc::c_void);
                        (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                        return;
                    }
                    (*var).ref_0 = ((*var).ref_0).wrapping_add(1);
                    (*var).ref_0;
                    __mln_lang_ctx_set_ret_var(ctx, var);
                }
            }
            2 => {
                var = __mln_lang_var_create_int(
                    ctx,
                    (*factor).data.i,
                    0 as *mut mln_string_t,
                );
                if var.is_null() {
                    __mln_lang_errmsg(
                        ctx,
                        b"No memory.\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                    );
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                __mln_lang_ctx_set_ret_var(ctx, var);
            }
            0 => {
                var = __mln_lang_var_create_bool(
                    ctx,
                    (*factor).data.b,
                    0 as *mut mln_string_t,
                );
                if var.is_null() {
                    __mln_lang_errmsg(
                        ctx,
                        b"No memory.\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                    );
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                __mln_lang_ctx_set_ret_var(ctx, var);
            }
            1 => {
                var = mln_lang_var_create_string(
                    ctx,
                    (*factor).data.s_id,
                    0 as *mut mln_string_t,
                );
                if var.is_null() {
                    __mln_lang_errmsg(
                        ctx,
                        b"No memory.\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                    );
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                __mln_lang_ctx_set_ret_var(ctx, var);
            }
            3 => {
                var = __mln_lang_var_create_real(
                    ctx,
                    (*factor).data.f,
                    0 as *mut mln_string_t,
                );
                if var.is_null() {
                    __mln_lang_errmsg(
                        ctx,
                        b"No memory.\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                    );
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                __mln_lang_ctx_set_ret_var(ctx, var);
            }
            4 => {
                var = __mln_lang_var_create_array(ctx, 0 as *mut mln_string_t);
                if var.is_null() {
                    __mln_lang_errmsg(
                        ctx,
                        b"No memory.\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                    );
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                mln_lang_stack_node_set_ret_var(node, var);
                if !((*factor).data.array).is_null() {
                    node = ({
                        let mut n: *mut mln_lang_stack_node_t = 0
                            as *mut mln_lang_stack_node_t;
                        if ((*ctx).run_stack_top).is_null() {
                            (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                            n = (*ctx).run_stack_top;
                        } else if (((*ctx).run_stack_top)
                            .offset_from(((*ctx).run_stack).as_mut_ptr())
                            as libc::c_long) < 1024 as libc::c_int as libc::c_long
                        {
                            (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                            n = (*ctx).run_stack_top;
                        }
                        if !n.is_null() {
                            (*n).type_0 = M_LSNT_ELEMLIST;
                            (*n).pos = 0 as *mut libc::c_void;
                            (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                            (*n).ret_var = (*n).ret_var2;
                            (*n).set_step(0 as libc::c_int as mln_u32_t);
                            (*n).set_call(0 as libc::c_int as mln_u32_t);
                            match M_LSNT_ELEMLIST as libc::c_int {
                                0 => {
                                    (*n).data.stm = (*factor).data.array as *mut mln_lang_stm_t;
                                }
                                1 => {
                                    (*n)
                                        .data
                                        .funcdef = (*factor).data.array as *mut mln_lang_funcdef_t;
                                }
                                2 => {
                                    (*n).data.set = (*factor).data.array as *mut mln_lang_set_t;
                                }
                                3 => {
                                    (*n)
                                        .data
                                        .set_stm = (*factor).data.array as *mut mln_lang_setstm_t;
                                }
                                4 => {
                                    (*n)
                                        .data
                                        .block = (*factor).data.array as *mut mln_lang_block_t;
                                }
                                5 => {
                                    (*n).data.w = (*factor).data.array as *mut mln_lang_while_t;
                                }
                                6 => {
                                    (*n)
                                        .data
                                        .sw = (*factor).data.array as *mut mln_lang_switch_t;
                                }
                                7 => {
                                    (*n)
                                        .data
                                        .sw_stm = (*factor).data.array as *mut mln_lang_switchstm_t;
                                }
                                8 => {
                                    (*n).data.f = (*factor).data.array as *mut mln_lang_for_t;
                                }
                                9 => {
                                    (*n).data.i = (*factor).data.array as *mut mln_lang_if_t;
                                }
                                10 => {
                                    (*n).data.exp = (*factor).data.array as *mut mln_lang_exp_t;
                                }
                                11 => {
                                    (*n)
                                        .data
                                        .assign = (*factor).data.array as *mut mln_lang_assign_t;
                                }
                                12 => {
                                    (*n)
                                        .data
                                        .logiclow = (*factor).data.array
                                        as *mut mln_lang_logiclow_t;
                                }
                                13 => {
                                    (*n)
                                        .data
                                        .logichigh = (*factor).data.array
                                        as *mut mln_lang_logichigh_t;
                                    (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                                }
                                14 => {
                                    (*n)
                                        .data
                                        .relativelow = (*factor).data.array
                                        as *mut mln_lang_relativelow_t;
                                    (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                                }
                                15 => {
                                    (*n)
                                        .data
                                        .relativehigh = (*factor).data.array
                                        as *mut mln_lang_relativehigh_t;
                                    (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                                }
                                16 => {
                                    (*n)
                                        .data
                                        .move_0 = (*factor).data.array as *mut mln_lang_move_t;
                                    (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                                }
                                17 => {
                                    (*n)
                                        .data
                                        .addsub = (*factor).data.array as *mut mln_lang_addsub_t;
                                    (*n).pos = (*n).data.addsub as *mut libc::c_void;
                                }
                                18 => {
                                    (*n)
                                        .data
                                        .muldiv = (*factor).data.array as *mut mln_lang_muldiv_t;
                                    (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                                }
                                19 => {
                                    (*n).data.not = (*factor).data.array as *mut mln_lang_not_t;
                                    (*n).pos = (*n).data.not as *mut libc::c_void;
                                }
                                20 => {
                                    (*n)
                                        .data
                                        .suffix = (*factor).data.array as *mut mln_lang_suffix_t;
                                }
                                21 => {
                                    (*n)
                                        .data
                                        .locate = (*factor).data.array as *mut mln_lang_locate_t;
                                }
                                22 => {
                                    (*n)
                                        .data
                                        .spec = (*factor).data.array as *mut mln_lang_spec_t;
                                }
                                23 => {
                                    (*n)
                                        .data
                                        .factor = (*factor).data.array as *mut mln_lang_factor_t;
                                }
                                _ => {
                                    (*n).data.elemlist = (*factor).data.array;
                                }
                            }
                        }
                        n
                    });
                    if node.is_null() {
                        __mln_lang_errmsg(
                            ctx,
                            b"Stack is full.\0" as *const u8 as *const libc::c_char
                                as *mut libc::c_char,
                        );
                        (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                        return;
                    }
                }
            }
            _ => {
                var = __mln_lang_var_create_nil(ctx, 0 as *mut mln_string_t);
                if var.is_null() {
                    __mln_lang_errmsg(
                        ctx,
                        b"No memory.\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                    );
                    (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                    return;
                }
                __mln_lang_ctx_set_ret_var(ctx, var);
            }
        }
        if (*factor).type_0 as libc::c_uint
            != M_FACTOR_ARRAY as libc::c_int as libc::c_uint
        {
            let mut n: *mut mln_lang_stack_node_t = ({
                let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                if !n_0.is_null()
                    && {
                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                        (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                    }
                {
                    (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                }
                n_0
            });
            if !n.is_null() {
                if !((*n).ret_var).is_null() {
                    __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                    (*n).ret_var = 0 as *mut mln_lang_var_t;
                }
                if !((*n).ret_var2).is_null() {
                    __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                }
            }
            while !((*ctx).run_stack_top).is_null()
                && (*(*ctx).run_stack_top).step() as libc::c_int == -(1 as libc::c_int)
            {
                let mut n: *mut mln_lang_stack_node_t = ({
                    let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                    if !n_0.is_null()
                        && {
                            (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                            (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                        }
                    {
                        (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                    }
                    n_0
                });
                if !n.is_null() {
                    if !((*n).ret_var).is_null() {
                        __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                        (*n).ret_var = 0 as *mut mln_lang_var_t;
                    }
                    if !((*n).ret_var2).is_null() {
                        __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                        (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    }
                }
            }
        }
    } else {
        if (*factor).type_0 as libc::c_uint
            == M_FACTOR_ARRAY as libc::c_int as libc::c_uint
        {
            mln_lang_ctx_get_node_ret_val(ctx, node);
        }
        let mut n: *mut mln_lang_stack_node_t = ({
            let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
            if !n_0.is_null()
                && {
                    (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                    (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                }
            {
                (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
            }
            n_0
        });
        if !n.is_null() {
            if !((*n).ret_var).is_null() {
                __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                (*n).ret_var = 0 as *mut mln_lang_var_t;
            }
            if !((*n).ret_var2).is_null() {
                __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
            }
        }
        while !((*ctx).run_stack_top).is_null()
            && (*(*ctx).run_stack_top).step() as libc::c_int == -(1 as libc::c_int)
        {
            let mut n: *mut mln_lang_stack_node_t = ({
                let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
                if !n_0.is_null()
                    && {
                        (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                        (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                    }
                {
                    (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
                }
                n_0
            });
            if !n.is_null() {
                if !((*n).ret_var).is_null() {
                    __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                    (*n).ret_var = 0 as *mut mln_lang_var_t;
                }
                if !((*n).ret_var2).is_null() {
                    __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                }
            }
        }
    };
}
unsafe extern "C" fn mln_lang_stack_handler_elemlist(mut ctx: *mut mln_lang_ctx_t) {
    let mut node: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
    let mut elem: *mut mln_lang_elemlist_t = (*node).data.elemlist;
    if (*node).step() as libc::c_int == 0 as libc::c_int {
        (*node).set_step(1 as libc::c_int as mln_u32_t);
        mln_lang_stack_node_reset_ret_val(node);
        mln_lang_ctx_reset_ret_var(ctx);
        if !((*elem).key).is_null() {
            node = ({
                let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
                if ((*ctx).run_stack_top).is_null() {
                    (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                    n = (*ctx).run_stack_top;
                } else if (((*ctx).run_stack_top)
                    .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                    < 1024 as libc::c_int as libc::c_long
                {
                    (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                    n = (*ctx).run_stack_top;
                }
                if !n.is_null() {
                    (*n).type_0 = M_LSNT_ASSIGN;
                    (*n).pos = 0 as *mut libc::c_void;
                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    (*n).ret_var = (*n).ret_var2;
                    (*n).set_step(0 as libc::c_int as mln_u32_t);
                    (*n).set_call(0 as libc::c_int as mln_u32_t);
                    match M_LSNT_ASSIGN as libc::c_int {
                        0 => {
                            (*n).data.stm = (*elem).key as *mut mln_lang_stm_t;
                        }
                        1 => {
                            (*n).data.funcdef = (*elem).key as *mut mln_lang_funcdef_t;
                        }
                        2 => {
                            (*n).data.set = (*elem).key as *mut mln_lang_set_t;
                        }
                        3 => {
                            (*n).data.set_stm = (*elem).key as *mut mln_lang_setstm_t;
                        }
                        4 => {
                            (*n).data.block = (*elem).key as *mut mln_lang_block_t;
                        }
                        5 => {
                            (*n).data.w = (*elem).key as *mut mln_lang_while_t;
                        }
                        6 => {
                            (*n).data.sw = (*elem).key as *mut mln_lang_switch_t;
                        }
                        7 => {
                            (*n).data.sw_stm = (*elem).key as *mut mln_lang_switchstm_t;
                        }
                        8 => {
                            (*n).data.f = (*elem).key as *mut mln_lang_for_t;
                        }
                        9 => {
                            (*n).data.i = (*elem).key as *mut mln_lang_if_t;
                        }
                        10 => {
                            (*n).data.exp = (*elem).key as *mut mln_lang_exp_t;
                        }
                        11 => {
                            (*n).data.assign = (*elem).key;
                        }
                        12 => {
                            (*n).data.logiclow = (*elem).key as *mut mln_lang_logiclow_t;
                        }
                        13 => {
                            (*n)
                                .data
                                .logichigh = (*elem).key as *mut mln_lang_logichigh_t;
                            (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                        }
                        14 => {
                            (*n)
                                .data
                                .relativelow = (*elem).key as *mut mln_lang_relativelow_t;
                            (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                        }
                        15 => {
                            (*n)
                                .data
                                .relativehigh = (*elem).key as *mut mln_lang_relativehigh_t;
                            (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                        }
                        16 => {
                            (*n).data.move_0 = (*elem).key as *mut mln_lang_move_t;
                            (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                        }
                        17 => {
                            (*n).data.addsub = (*elem).key as *mut mln_lang_addsub_t;
                            (*n).pos = (*n).data.addsub as *mut libc::c_void;
                        }
                        18 => {
                            (*n).data.muldiv = (*elem).key as *mut mln_lang_muldiv_t;
                            (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                        }
                        19 => {
                            (*n).data.not = (*elem).key as *mut mln_lang_not_t;
                            (*n).pos = (*n).data.not as *mut libc::c_void;
                        }
                        20 => {
                            (*n).data.suffix = (*elem).key as *mut mln_lang_suffix_t;
                        }
                        21 => {
                            (*n).data.locate = (*elem).key as *mut mln_lang_locate_t;
                        }
                        22 => {
                            (*n).data.spec = (*elem).key as *mut mln_lang_spec_t;
                        }
                        23 => {
                            (*n).data.factor = (*elem).key as *mut mln_lang_factor_t;
                        }
                        _ => {
                            (*n).data.elemlist = (*elem).key as *mut mln_lang_elemlist_t;
                        }
                    }
                }
                n
            });
            if node.is_null() {
                __mln_lang_errmsg(
                    ctx,
                    b"Stack is full.\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                );
                (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                return;
            }
            (mln_lang_stack_map[(*node).type_0 as usize])
                .expect("non-null function pointer")(ctx);
            return;
        }
    } else if (*node).step() as libc::c_int == 1 as libc::c_int {
        (*node).set_step(2 as libc::c_int as mln_u32_t);
        if !((*ctx).ret_var).is_null() {
            mln_lang_stack_node_get_ctx_ret_var(node, ctx);
        }
        node = ({
            let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
            if ((*ctx).run_stack_top).is_null() {
                (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                n = (*ctx).run_stack_top;
            } else if (((*ctx).run_stack_top)
                .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                < 1024 as libc::c_int as libc::c_long
            {
                (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                n = (*ctx).run_stack_top;
            }
            if !n.is_null() {
                (*n).type_0 = M_LSNT_ASSIGN;
                (*n).pos = 0 as *mut libc::c_void;
                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                (*n).ret_var = (*n).ret_var2;
                (*n).set_step(0 as libc::c_int as mln_u32_t);
                (*n).set_call(0 as libc::c_int as mln_u32_t);
                match M_LSNT_ASSIGN as libc::c_int {
                    0 => {
                        (*n).data.stm = (*elem).val as *mut mln_lang_stm_t;
                    }
                    1 => {
                        (*n).data.funcdef = (*elem).val as *mut mln_lang_funcdef_t;
                    }
                    2 => {
                        (*n).data.set = (*elem).val as *mut mln_lang_set_t;
                    }
                    3 => {
                        (*n).data.set_stm = (*elem).val as *mut mln_lang_setstm_t;
                    }
                    4 => {
                        (*n).data.block = (*elem).val as *mut mln_lang_block_t;
                    }
                    5 => {
                        (*n).data.w = (*elem).val as *mut mln_lang_while_t;
                    }
                    6 => {
                        (*n).data.sw = (*elem).val as *mut mln_lang_switch_t;
                    }
                    7 => {
                        (*n).data.sw_stm = (*elem).val as *mut mln_lang_switchstm_t;
                    }
                    8 => {
                        (*n).data.f = (*elem).val as *mut mln_lang_for_t;
                    }
                    9 => {
                        (*n).data.i = (*elem).val as *mut mln_lang_if_t;
                    }
                    10 => {
                        (*n).data.exp = (*elem).val as *mut mln_lang_exp_t;
                    }
                    11 => {
                        (*n).data.assign = (*elem).val;
                    }
                    12 => {
                        (*n).data.logiclow = (*elem).val as *mut mln_lang_logiclow_t;
                    }
                    13 => {
                        (*n).data.logichigh = (*elem).val as *mut mln_lang_logichigh_t;
                        (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                    }
                    14 => {
                        (*n)
                            .data
                            .relativelow = (*elem).val as *mut mln_lang_relativelow_t;
                        (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                    }
                    15 => {
                        (*n)
                            .data
                            .relativehigh = (*elem).val as *mut mln_lang_relativehigh_t;
                        (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                    }
                    16 => {
                        (*n).data.move_0 = (*elem).val as *mut mln_lang_move_t;
                        (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                    }
                    17 => {
                        (*n).data.addsub = (*elem).val as *mut mln_lang_addsub_t;
                        (*n).pos = (*n).data.addsub as *mut libc::c_void;
                    }
                    18 => {
                        (*n).data.muldiv = (*elem).val as *mut mln_lang_muldiv_t;
                        (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                    }
                    19 => {
                        (*n).data.not = (*elem).val as *mut mln_lang_not_t;
                        (*n).pos = (*n).data.not as *mut libc::c_void;
                    }
                    20 => {
                        (*n).data.suffix = (*elem).val as *mut mln_lang_suffix_t;
                    }
                    21 => {
                        (*n).data.locate = (*elem).val as *mut mln_lang_locate_t;
                    }
                    22 => {
                        (*n).data.spec = (*elem).val as *mut mln_lang_spec_t;
                    }
                    23 => {
                        (*n).data.factor = (*elem).val as *mut mln_lang_factor_t;
                    }
                    _ => {
                        (*n).data.elemlist = (*elem).val as *mut mln_lang_elemlist_t;
                    }
                }
            }
            n
        });
        if node.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"Stack is full.\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
            return;
        }
        (mln_lang_stack_map[(*node).type_0 as usize])
            .expect("non-null function pointer")(ctx);
        return;
    } else if (*node).step() as libc::c_int == 2 as libc::c_int {
        let mut key: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
        let mut val: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
        let mut array_node: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
        let mut array: *mut mln_lang_array_t = 0 as *mut mln_lang_array_t;
        node = ({
            let mut n: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
            if !n.is_null()
                && {
                    (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                    (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                }
            {
                (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
            }
            n
        });
        array_node = (*ctx).run_stack_top;
        if ((*ctx).run_stack_top).is_null() {
            (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
        } else if (((*ctx).run_stack_top).offset_from(((*ctx).run_stack).as_mut_ptr())
            as libc::c_long) < 1024 as libc::c_int as libc::c_long
        {
            (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
            (*ctx).run_stack_top;
        }
        array = (*(*(*array_node).ret_var).val).data.array;
        key = (*node).ret_var;
        val = __mln_lang_array_get(ctx, array, key);
        if val.is_null() {
            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
            return;
        }
        if mln_lang_var_value_set_string_ref(ctx, val, (*ctx).ret_var) < 0 as libc::c_int
        {
            __mln_lang_errmsg(
                ctx,
                b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
            return;
        }
        let mut n: *mut mln_lang_stack_node_t = ({
            let mut n_0: *mut mln_lang_stack_node_t = (*ctx).run_stack_top;
            if !n_0.is_null()
                && {
                    (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(-1);
                    (*ctx).run_stack_top < ((*ctx).run_stack).as_mut_ptr()
                }
            {
                (*ctx).run_stack_top = 0 as *mut mln_lang_stack_node_t;
            }
            n_0
        });
        if !n.is_null() {
            if !((*n).ret_var).is_null() {
                __mln_lang_var_free((*n).ret_var as *mut libc::c_void);
                (*n).ret_var = 0 as *mut mln_lang_var_t;
            }
            if !((*n).ret_var2).is_null() {
                __mln_lang_var_free((*n).ret_var2 as *mut libc::c_void);
                (*n).ret_var2 = 0 as *mut mln_lang_var_t;
            }
        }
        mln_lang_ctx_reset_ret_var(ctx);
        if !((*elem).next).is_null() {
            node = ({
                let mut n: *mut mln_lang_stack_node_t = 0 as *mut mln_lang_stack_node_t;
                if ((*ctx).run_stack_top).is_null() {
                    (*ctx).run_stack_top = ((*ctx).run_stack).as_mut_ptr();
                    n = (*ctx).run_stack_top;
                } else if (((*ctx).run_stack_top)
                    .offset_from(((*ctx).run_stack).as_mut_ptr()) as libc::c_long)
                    < 1024 as libc::c_int as libc::c_long
                {
                    (*ctx).run_stack_top = ((*ctx).run_stack_top).offset(1);
                    n = (*ctx).run_stack_top;
                }
                if !n.is_null() {
                    (*n).type_0 = M_LSNT_ELEMLIST;
                    (*n).pos = 0 as *mut libc::c_void;
                    (*n).ret_var2 = 0 as *mut mln_lang_var_t;
                    (*n).ret_var = (*n).ret_var2;
                    (*n).set_step(0 as libc::c_int as mln_u32_t);
                    (*n).set_call(0 as libc::c_int as mln_u32_t);
                    match M_LSNT_ELEMLIST as libc::c_int {
                        0 => {
                            (*n).data.stm = (*elem).next as *mut mln_lang_stm_t;
                        }
                        1 => {
                            (*n).data.funcdef = (*elem).next as *mut mln_lang_funcdef_t;
                        }
                        2 => {
                            (*n).data.set = (*elem).next as *mut mln_lang_set_t;
                        }
                        3 => {
                            (*n).data.set_stm = (*elem).next as *mut mln_lang_setstm_t;
                        }
                        4 => {
                            (*n).data.block = (*elem).next as *mut mln_lang_block_t;
                        }
                        5 => {
                            (*n).data.w = (*elem).next as *mut mln_lang_while_t;
                        }
                        6 => {
                            (*n).data.sw = (*elem).next as *mut mln_lang_switch_t;
                        }
                        7 => {
                            (*n).data.sw_stm = (*elem).next as *mut mln_lang_switchstm_t;
                        }
                        8 => {
                            (*n).data.f = (*elem).next as *mut mln_lang_for_t;
                        }
                        9 => {
                            (*n).data.i = (*elem).next as *mut mln_lang_if_t;
                        }
                        10 => {
                            (*n).data.exp = (*elem).next as *mut mln_lang_exp_t;
                        }
                        11 => {
                            (*n).data.assign = (*elem).next as *mut mln_lang_assign_t;
                        }
                        12 => {
                            (*n)
                                .data
                                .logiclow = (*elem).next as *mut mln_lang_logiclow_t;
                        }
                        13 => {
                            (*n)
                                .data
                                .logichigh = (*elem).next as *mut mln_lang_logichigh_t;
                            (*n).pos = (*n).data.logichigh as *mut libc::c_void;
                        }
                        14 => {
                            (*n)
                                .data
                                .relativelow = (*elem).next as *mut mln_lang_relativelow_t;
                            (*n).pos = (*n).data.relativelow as *mut libc::c_void;
                        }
                        15 => {
                            (*n)
                                .data
                                .relativehigh = (*elem).next
                                as *mut mln_lang_relativehigh_t;
                            (*n).pos = (*n).data.relativehigh as *mut libc::c_void;
                        }
                        16 => {
                            (*n).data.move_0 = (*elem).next as *mut mln_lang_move_t;
                            (*n).pos = (*n).data.move_0 as *mut libc::c_void;
                        }
                        17 => {
                            (*n).data.addsub = (*elem).next as *mut mln_lang_addsub_t;
                            (*n).pos = (*n).data.addsub as *mut libc::c_void;
                        }
                        18 => {
                            (*n).data.muldiv = (*elem).next as *mut mln_lang_muldiv_t;
                            (*n).pos = (*n).data.muldiv as *mut libc::c_void;
                        }
                        19 => {
                            (*n).data.not = (*elem).next as *mut mln_lang_not_t;
                            (*n).pos = (*n).data.not as *mut libc::c_void;
                        }
                        20 => {
                            (*n).data.suffix = (*elem).next as *mut mln_lang_suffix_t;
                        }
                        21 => {
                            (*n).data.locate = (*elem).next as *mut mln_lang_locate_t;
                        }
                        22 => {
                            (*n).data.spec = (*elem).next as *mut mln_lang_spec_t;
                        }
                        23 => {
                            (*n).data.factor = (*elem).next as *mut mln_lang_factor_t;
                        }
                        _ => {
                            (*n).data.elemlist = (*elem).next;
                        }
                    }
                }
                n
            });
            if node.is_null() {
                __mln_lang_errmsg(
                    ctx,
                    b"Stack is full.\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                );
                (*ctx).set_quit(1 as libc::c_int as mln_u32_t);
                return;
            }
            (mln_lang_stack_map[(*node).type_0 as usize])
                .expect("non-null function pointer")(ctx);
            return;
        }
    }
}
unsafe extern "C" fn mln_lang_dump_symbol(
    mut ctx: *mut mln_lang_ctx_t,
    mut key: *mut libc::c_void,
    mut val: *mut libc::c_void,
    mut udata: *mut libc::c_void,
) -> libc::c_int {
    let mut title: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut sym: *mut mln_lang_symbol_node_t = val as *mut mln_lang_symbol_node_t;
    let mut rbattr: mln_rbtree_attr = mln_rbtree_attr {
        pool: 0 as *mut libc::c_void,
        pool_alloc: None,
        pool_free: None,
        cmp: None,
        data_free: None,
    };
    let mut check: *mut mln_rbtree_t = 0 as *mut mln_rbtree_t;
    rbattr.pool = (*ctx).pool as *mut libc::c_void;
    rbattr
        .pool_alloc = ::core::mem::transmute::<
        Option::<
            unsafe extern "C" fn(*mut mln_alloc_t, mln_size_t) -> *mut libc::c_void,
        >,
        rbtree_pool_alloc_handler,
    >(
        Some(
            mln_alloc_m
                as unsafe extern "C" fn(
                    *mut mln_alloc_t,
                    mln_size_t,
                ) -> *mut libc::c_void,
        ),
    );
    rbattr
        .pool_free = ::core::mem::transmute::<
        Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
        rbtree_pool_free_handler,
    >(Some(mln_alloc_free as unsafe extern "C" fn(*mut libc::c_void) -> ()));
    rbattr
        .cmp = Some(
        mln_lang_dump_check_cmp
            as unsafe extern "C" fn(
                *const libc::c_void,
                *const libc::c_void,
            ) -> libc::c_int,
    );
    rbattr.data_free = None;
    check = mln_rbtree_new(&mut rbattr);
    if check.is_null() {
        return -(1 as libc::c_int);
    }
    match (*sym).type_0 as libc::c_uint {
        0 => {
            title = b"Var\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
        }
        1 => {
            title = b"Set\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
        }
        _ => {
            title = b"Label\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
        }
    }
    _mln_sys_log(
        none,
        b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
        (*::core::mem::transmute::<
            &[u8; 21],
            &[libc::c_char; 21],
        >(b"mln_lang_dump_symbol\0"))
            .as_ptr(),
        6369 as libc::c_int,
        b"  %S <%s>\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        (*sym).symbol,
        title,
    );
    match (*sym).type_0 as libc::c_uint {
        0 => {
            mln_lang_dump_var((*sym).data.var, 4 as libc::c_int, check);
        }
        _ => {
            mln_lang_dump_set((*sym).data.set);
        }
    }
    mln_rbtree_free(check);
    return 0 as libc::c_int;
}
unsafe extern "C" fn mln_lang_dump_check_cmp(
    mut addr1: *const libc::c_void,
    mut addr2: *const libc::c_void,
) -> libc::c_int {
    return (addr1 as mln_s8ptr_t).offset_from(addr2 as mln_s8ptr_t) as libc::c_long
        as libc::c_int;
}
unsafe extern "C" fn mln_lang_dump_var(
    mut var: *mut mln_lang_var_t,
    mut cnt: libc::c_int,
    mut check: *mut mln_rbtree_t,
) {
    let mut tmpi: libc::c_int = 0;
    tmpi = 0 as libc::c_int;
    while tmpi < cnt {
        _mln_sys_log(
            none,
            b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 18],
                &[libc::c_char; 18],
            >(b"mln_lang_dump_var\0"))
                .as_ptr(),
            6392 as libc::c_int,
            b" \0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        tmpi += 1;
        tmpi;
    }
    _mln_sys_log(
        none,
        b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
        (*::core::mem::transmute::<
            &[u8; 18],
            &[libc::c_char; 18],
        >(b"mln_lang_dump_var\0"))
            .as_ptr(),
        6393 as libc::c_int,
        b"%s\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        if (*var).type_0 as libc::c_uint
            == M_LANG_VAR_NORMAL as libc::c_int as libc::c_uint
        {
            b"Normal\0" as *const u8 as *const libc::c_char
        } else {
            b"Refer\0" as *const u8 as *const libc::c_char
        },
    );
    if !((*var).name).is_null() {
        _mln_sys_log(
            none,
            b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 18],
                &[libc::c_char; 18],
            >(b"mln_lang_dump_var\0"))
                .as_ptr(),
            6395 as libc::c_int,
            b"  Alias name: %S\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            (*var).name,
        );
    }
    if ((*var).val).is_null() {
        _mln_sys_log(
            none,
            b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 18],
                &[libc::c_char; 18],
            >(b"mln_lang_dump_var\0"))
                .as_ptr(),
            6398 as libc::c_int,
            b"  No value.\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        return;
    }
    if !((*var).in_set).is_null() {
        _mln_sys_log(
            none,
            b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 18],
                &[libc::c_char; 18],
            >(b"mln_lang_dump_var\0"))
                .as_ptr(),
            6402 as libc::c_int,
            b"  In Set '%S'  setRef: %l\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            (*(*var).in_set).name,
            (*(*var).in_set).ref_0,
        );
    }
    _mln_sys_log(
        none,
        b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
        (*::core::mem::transmute::<
            &[u8; 18],
            &[libc::c_char; 18],
        >(b"mln_lang_dump_var\0"))
            .as_ptr(),
        6408 as libc::c_int,
        b"  valueRef: %u, udata <0x%X>, func <0x%X>, not_modify: %s\n\0" as *const u8
            as *const libc::c_char as *mut libc::c_char,
        (*(*var).val).ref_0,
        (*(*var).val).udata,
        (*(*var).val).func,
        if (*(*var).val).not_modify() as libc::c_int != 0 {
            b"true\0" as *const u8 as *const libc::c_char
        } else {
            b"false\0" as *const u8 as *const libc::c_char
        },
    );
    let mut type_0: mln_s32_t = (*(*var).val).type_0;
    match type_0 {
        0 => {
            let mut tmpi_0: libc::c_int = 0;
            tmpi_0 = 0 as libc::c_int;
            while tmpi_0 < cnt {
                _mln_sys_log(
                    none,
                    b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
                    (*::core::mem::transmute::<
                        &[u8; 18],
                        &[libc::c_char; 18],
                    >(b"mln_lang_dump_var\0"))
                        .as_ptr(),
                    6412 as libc::c_int,
                    b" \0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
                tmpi_0 += 1;
                tmpi_0;
            }
            _mln_sys_log(
                none,
                b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<
                    &[u8; 18],
                    &[libc::c_char; 18],
                >(b"mln_lang_dump_var\0"))
                    .as_ptr(),
                6413 as libc::c_int,
                b"<NIL>\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
        }
        1 => {
            let mut tmpi_1: libc::c_int = 0;
            tmpi_1 = 0 as libc::c_int;
            while tmpi_1 < cnt {
                _mln_sys_log(
                    none,
                    b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
                    (*::core::mem::transmute::<
                        &[u8; 18],
                        &[libc::c_char; 18],
                    >(b"mln_lang_dump_var\0"))
                        .as_ptr(),
                    6416 as libc::c_int,
                    b" \0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
                tmpi_1 += 1;
                tmpi_1;
            }
            _mln_sys_log(
                none,
                b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<
                    &[u8; 18],
                    &[libc::c_char; 18],
                >(b"mln_lang_dump_var\0"))
                    .as_ptr(),
                6417 as libc::c_int,
                b"<INT> %i\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                (*(*var).val).data.i,
            );
        }
        2 => {
            let mut tmpi_2: libc::c_int = 0;
            tmpi_2 = 0 as libc::c_int;
            while tmpi_2 < cnt {
                _mln_sys_log(
                    none,
                    b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
                    (*::core::mem::transmute::<
                        &[u8; 18],
                        &[libc::c_char; 18],
                    >(b"mln_lang_dump_var\0"))
                        .as_ptr(),
                    6420 as libc::c_int,
                    b" \0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
                tmpi_2 += 1;
                tmpi_2;
            }
            _mln_sys_log(
                none,
                b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<
                    &[u8; 18],
                    &[libc::c_char; 18],
                >(b"mln_lang_dump_var\0"))
                    .as_ptr(),
                6421 as libc::c_int,
                b"<BOOL> %s\n\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                if (*(*var).val).data.b as libc::c_int != 0 {
                    b"true\0" as *const u8 as *const libc::c_char
                } else {
                    b"false\0" as *const u8 as *const libc::c_char
                },
            );
        }
        3 => {
            let mut tmpi_3: libc::c_int = 0;
            tmpi_3 = 0 as libc::c_int;
            while tmpi_3 < cnt {
                _mln_sys_log(
                    none,
                    b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
                    (*::core::mem::transmute::<
                        &[u8; 18],
                        &[libc::c_char; 18],
                    >(b"mln_lang_dump_var\0"))
                        .as_ptr(),
                    6424 as libc::c_int,
                    b" \0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
                tmpi_3 += 1;
                tmpi_3;
            }
            _mln_sys_log(
                none,
                b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<
                    &[u8; 18],
                    &[libc::c_char; 18],
                >(b"mln_lang_dump_var\0"))
                    .as_ptr(),
                6425 as libc::c_int,
                b"<REAL> %f\n\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                (*(*var).val).data.f,
            );
        }
        4 => {
            let mut tmpi_4: libc::c_int = 0;
            tmpi_4 = 0 as libc::c_int;
            while tmpi_4 < cnt {
                _mln_sys_log(
                    none,
                    b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
                    (*::core::mem::transmute::<
                        &[u8; 18],
                        &[libc::c_char; 18],
                    >(b"mln_lang_dump_var\0"))
                        .as_ptr(),
                    6428 as libc::c_int,
                    b" \0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
                tmpi_4 += 1;
                tmpi_4;
            }
            _mln_sys_log(
                none,
                b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<
                    &[u8; 18],
                    &[libc::c_char; 18],
                >(b"mln_lang_dump_var\0"))
                    .as_ptr(),
                6429 as libc::c_int,
                b"<STRING> '%S'\n\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                (*(*var).val).data.s,
            );
        }
        5 => {
            mln_lang_dump_object((*(*var).val).data.obj, cnt, check);
        }
        6 => {
            mln_lang_dump_function((*(*var).val).data.func, cnt);
        }
        7 => {
            mln_lang_dump_array((*(*var).val).data.array, cnt, check);
        }
        _ => {
            let mut tmpi_5: libc::c_int = 0;
            tmpi_5 = 0 as libc::c_int;
            while tmpi_5 < cnt {
                _mln_sys_log(
                    none,
                    b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
                    (*::core::mem::transmute::<
                        &[u8; 18],
                        &[libc::c_char; 18],
                    >(b"mln_lang_dump_var\0"))
                        .as_ptr(),
                    6441 as libc::c_int,
                    b" \0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
                tmpi_5 += 1;
                tmpi_5;
            }
            _mln_sys_log(
                none,
                b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<
                    &[u8; 18],
                    &[libc::c_char; 18],
                >(b"mln_lang_dump_var\0"))
                    .as_ptr(),
                6442 as libc::c_int,
                b"<CALL>\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            if !((*(*(*var).val).data.call).prototype).is_null() {
                mln_lang_dump_function(
                    (*(*(*var).val).data.call).prototype,
                    cnt + 2 as libc::c_int,
                );
            }
        }
    };
}
unsafe extern "C" fn mln_lang_dump_object(
    mut obj: *mut mln_lang_object_t,
    mut cnt: libc::c_int,
    mut check: *mut mln_rbtree_t,
) {
    let mut rn: *mut mln_rbtree_node_t = 0 as *mut mln_rbtree_node_t;
    let mut ls: mln_lang_scan_s = mln_lang_scan_s {
        cnt: 0 as *mut libc::c_int,
        tree: 0 as *mut mln_rbtree_t,
        tree2: 0 as *mut mln_rbtree_t,
        ctx: 0 as *mut mln_lang_ctx_t,
    };
    ls.cnt = &mut cnt;
    ls.tree = check;
    ls.tree2 = 0 as *mut mln_rbtree_t;
    ls.ctx = 0 as *mut mln_lang_ctx_t;
    let mut tmpi: libc::c_int = 0;
    tmpi = 0 as libc::c_int;
    while tmpi < cnt {
        _mln_sys_log(
            none,
            b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 21],
                &[libc::c_char; 21],
            >(b"mln_lang_dump_object\0"))
                .as_ptr(),
            6461 as libc::c_int,
            b" \0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        tmpi += 1;
        tmpi;
    }
    if !((*obj).in_set).is_null() {
        _mln_sys_log(
            none,
            b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 21],
                &[libc::c_char; 21],
            >(b"mln_lang_dump_object\0"))
                .as_ptr(),
            6464 as libc::c_int,
            b"<OBJECT><%X> In Set '%S'  setRef: %I objRef: %I\n\0" as *const u8
                as *const libc::c_char as *mut libc::c_char,
            obj,
            (*(*obj).in_set).name,
            (*(*obj).in_set).ref_0,
            (*obj).ref_0,
        );
    } else {
        _mln_sys_log(
            none,
            b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 21],
                &[libc::c_char; 21],
            >(b"mln_lang_dump_object\0"))
                .as_ptr(),
            6466 as libc::c_int,
            b"<OBJECT><%X> In Set '<anonymous>'  setRef: <unknown> objRef: %I\n\0"
                as *const u8 as *const libc::c_char as *mut libc::c_char,
            obj,
            (*obj).ref_0,
        );
    }
    if !check.is_null() {
        rn = mln_rbtree_search(check, obj as *mut libc::c_void);
        if !(rn == &mut (*check).nil as *mut mln_rbtree_node_t) {
            return;
        }
        rn = mln_rbtree_node_new(check, obj as *mut libc::c_void);
        if rn.is_null() {
            return;
        }
        mln_rbtree_insert(check, rn);
    }
    mln_rbtree_iterate(
        (*obj).members,
        Some(
            mln_lang_dump_var_iterate_handler
                as unsafe extern "C" fn(
                    *mut mln_rbtree_node_t,
                    *mut libc::c_void,
                ) -> libc::c_int,
        ),
        &mut ls as *mut mln_lang_scan_s as *mut libc::c_void,
    );
}
unsafe extern "C" fn mln_lang_dump_var_iterate_handler(
    mut node: *mut mln_rbtree_node_t,
    mut udata: *mut libc::c_void,
) -> libc::c_int {
    let mut ls: *mut mln_lang_scan_s = udata as *mut mln_lang_scan_s;
    mln_lang_dump_var(
        (*node).data as *mut mln_lang_var_t,
        *(*ls).cnt + 2 as libc::c_int,
        (*ls).tree,
    );
    return 0 as libc::c_int;
}
unsafe extern "C" fn mln_lang_dump_function(
    mut func: *mut mln_lang_func_detail_t,
    mut cnt: libc::c_int,
) {
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut i: mln_size_t = 0;
    let mut n: mln_size_t = 0;
    let mut file: *mut mln_string_t = 0 as *mut mln_string_t;
    let mut cfunc: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"<C Function>\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 13]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    let mut unknown: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"<Empty Function>\0" as *const u8 as *const libc::c_char
                as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 17]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    let mut line: mln_u64_t = 0 as libc::c_int as mln_u64_t;
    file = &mut cfunc;
    let mut tmpi: libc::c_int = 0;
    tmpi = 0 as libc::c_int;
    while tmpi < cnt {
        _mln_sys_log(
            none,
            b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 23],
                &[libc::c_char; 23],
            >(b"mln_lang_dump_function\0"))
                .as_ptr(),
            6497 as libc::c_int,
            b" \0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        tmpi += 1;
        tmpi;
    }
    if (*func).type_0 as libc::c_uint == M_FUNC_EXTERNAL as libc::c_int as libc::c_uint {
        if !((*func).data.stm).is_null() {
            file = (*(*func).data.stm).file;
            line = (*(*func).data.stm).line;
        } else {
            file = &mut unknown;
        }
    }
    n = (*func).args.nelts;
    _mln_sys_log(
        none,
        b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
        (*::core::mem::transmute::<
            &[u8; 23],
            &[libc::c_char; 23],
        >(b"mln_lang_dump_function\0"))
            .as_ptr(),
        6509 as libc::c_int,
        b"<FUNCTION> %S:%I NARGS:%I\n\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
        file,
        line,
        n,
    );
    i = 0 as libc::c_int as mln_size_t;
    while i < n {
        var = *((*func).args.elts as *mut *mut mln_lang_var_t).offset(i as isize);
        mln_lang_dump_var(var, cnt + 2 as libc::c_int, 0 as *mut mln_rbtree_t);
        i = i.wrapping_add(1);
        i;
    }
}
unsafe extern "C" fn mln_lang_dump_set(mut set: *mut mln_lang_set_detail_t) {
    let mut cnt: libc::c_int = 4 as libc::c_int;
    _mln_sys_log(
        none,
        b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
        (*::core::mem::transmute::<
            &[u8; 18],
            &[libc::c_char; 18],
        >(b"mln_lang_dump_set\0"))
            .as_ptr(),
        6518 as libc::c_int,
        b"    Name: %S  ref:%I\n\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
        (*set).name,
        (*set).ref_0,
    );
    mln_rbtree_iterate(
        (*set).members,
        Some(
            mln_lang_dump_var_iterate_handler
                as unsafe extern "C" fn(
                    *mut mln_rbtree_node_t,
                    *mut libc::c_void,
                ) -> libc::c_int,
        ),
        &mut cnt as *mut libc::c_int as *mut libc::c_void,
    );
}
unsafe extern "C" fn mln_lang_dump_array(
    mut array: *mut mln_lang_array_t,
    mut cnt: libc::c_int,
    mut check: *mut mln_rbtree_t,
) {
    let mut rn: *mut mln_rbtree_node_t = 0 as *mut mln_rbtree_node_t;
    let mut tmp: libc::c_int = cnt + 2 as libc::c_int;
    let mut ls: mln_lang_scan_s = mln_lang_scan_s {
        cnt: 0 as *mut libc::c_int,
        tree: 0 as *mut mln_rbtree_t,
        tree2: 0 as *mut mln_rbtree_t,
        ctx: 0 as *mut mln_lang_ctx_t,
    };
    ls.cnt = &mut tmp;
    ls.tree = check;
    ls.tree2 = 0 as *mut mln_rbtree_t;
    ls.ctx = 0 as *mut mln_lang_ctx_t;
    let mut tmpi: libc::c_int = 0;
    tmpi = 0 as libc::c_int;
    while tmpi < cnt {
        _mln_sys_log(
            none,
            b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 20],
                &[libc::c_char; 20],
            >(b"mln_lang_dump_array\0"))
                .as_ptr(),
            6532 as libc::c_int,
            b" \0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        tmpi += 1;
        tmpi;
    }
    _mln_sys_log(
        none,
        b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
        (*::core::mem::transmute::<
            &[u8; 20],
            &[libc::c_char; 20],
        >(b"mln_lang_dump_array\0"))
            .as_ptr(),
        6533 as libc::c_int,
        b"<ARRAY><%X>\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        array,
    );
    if !check.is_null() {
        rn = mln_rbtree_search(check, array as *mut libc::c_void);
        if !(rn == &mut (*check).nil as *mut mln_rbtree_node_t) {
            return;
        }
        rn = mln_rbtree_node_new(check, array as *mut libc::c_void);
        if rn.is_null() {
            return;
        }
        mln_rbtree_insert(check, rn);
    }
    let mut tmpi_0: libc::c_int = 0;
    tmpi_0 = 0 as libc::c_int;
    while tmpi_0 < cnt {
        _mln_sys_log(
            none,
            b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 20],
                &[libc::c_char; 20],
            >(b"mln_lang_dump_array\0"))
                .as_ptr(),
            6542 as libc::c_int,
            b" \0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        tmpi_0 += 1;
        tmpi_0;
    }
    _mln_sys_log(
        none,
        b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
        (*::core::mem::transmute::<
            &[u8; 20],
            &[libc::c_char; 20],
        >(b"mln_lang_dump_array\0"))
            .as_ptr(),
        6543 as libc::c_int,
        b"ALL ELEMENTS:\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    mln_rbtree_iterate(
        (*array).elems_index,
        Some(
            mln_lang_dump_array_elem
                as unsafe extern "C" fn(
                    *mut mln_rbtree_node_t,
                    *mut libc::c_void,
                ) -> libc::c_int,
        ),
        &mut ls as *mut mln_lang_scan_s as *mut libc::c_void,
    );
    let mut tmpi_1: libc::c_int = 0;
    tmpi_1 = 0 as libc::c_int;
    while tmpi_1 < cnt {
        _mln_sys_log(
            none,
            b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 20],
                &[libc::c_char; 20],
            >(b"mln_lang_dump_array\0"))
                .as_ptr(),
            6545 as libc::c_int,
            b" \0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        tmpi_1 += 1;
        tmpi_1;
    }
    _mln_sys_log(
        none,
        b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
        (*::core::mem::transmute::<
            &[u8; 20],
            &[libc::c_char; 20],
        >(b"mln_lang_dump_array\0"))
            .as_ptr(),
        6546 as libc::c_int,
        b"KEY ELEMENTS:\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    mln_rbtree_iterate(
        (*array).elems_key,
        Some(
            mln_lang_dump_array_elem
                as unsafe extern "C" fn(
                    *mut mln_rbtree_node_t,
                    *mut libc::c_void,
                ) -> libc::c_int,
        ),
        &mut ls as *mut mln_lang_scan_s as *mut libc::c_void,
    );
    let mut tmpi_2: libc::c_int = 0;
    tmpi_2 = 0 as libc::c_int;
    while tmpi_2 < cnt {
        _mln_sys_log(
            none,
            b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 20],
                &[libc::c_char; 20],
            >(b"mln_lang_dump_array\0"))
                .as_ptr(),
            6548 as libc::c_int,
            b" \0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        tmpi_2 += 1;
        tmpi_2;
    }
    _mln_sys_log(
        none,
        b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
        (*::core::mem::transmute::<
            &[u8; 20],
            &[libc::c_char; 20],
        >(b"mln_lang_dump_array\0"))
            .as_ptr(),
        6549 as libc::c_int,
        b"Refs: %I\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        (*array).ref_0,
    );
}
unsafe extern "C" fn mln_lang_dump_array_elem(
    mut node: *mut mln_rbtree_node_t,
    mut udata: *mut libc::c_void,
) -> libc::c_int {
    let mut elem: *mut mln_lang_array_elem_t = (*node).data
        as *mut mln_lang_array_elem_t;
    let mut ls: *mut mln_lang_scan_s = udata as *mut mln_lang_scan_s;
    let mut cnt: libc::c_int = *(*ls).cnt;
    let mut tmpi: libc::c_int = 0;
    tmpi = 0 as libc::c_int;
    while tmpi < cnt {
        _mln_sys_log(
            none,
            b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 25],
                &[libc::c_char; 25],
            >(b"mln_lang_dump_array_elem\0"))
                .as_ptr(),
            6558 as libc::c_int,
            b" \0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        tmpi += 1;
        tmpi;
    }
    _mln_sys_log(
        none,
        b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
        (*::core::mem::transmute::<
            &[u8; 25],
            &[libc::c_char; 25],
        >(b"mln_lang_dump_array_elem\0"))
            .as_ptr(),
        6559 as libc::c_int,
        b"Index: %I\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        (*elem).index,
    );
    if !((*elem).key).is_null() {
        let mut tmpi_0: libc::c_int = 0;
        tmpi_0 = 0 as libc::c_int;
        while tmpi_0 < cnt {
            _mln_sys_log(
                none,
                b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<
                    &[u8; 25],
                    &[libc::c_char; 25],
                >(b"mln_lang_dump_array_elem\0"))
                    .as_ptr(),
                6561 as libc::c_int,
                b" \0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            tmpi_0 += 1;
            tmpi_0;
        }
        _mln_sys_log(
            none,
            b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 25],
                &[libc::c_char; 25],
            >(b"mln_lang_dump_array_elem\0"))
                .as_ptr(),
            6562 as libc::c_int,
            b"Key:\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        mln_lang_dump_var((*elem).key, cnt + 2 as libc::c_int, (*ls).tree);
    }
    let mut tmpi_1: libc::c_int = 0;
    tmpi_1 = 0 as libc::c_int;
    while tmpi_1 < cnt {
        _mln_sys_log(
            none,
            b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 25],
                &[libc::c_char; 25],
            >(b"mln_lang_dump_array_elem\0"))
                .as_ptr(),
            6565 as libc::c_int,
            b" \0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        tmpi_1 += 1;
        tmpi_1;
    }
    _mln_sys_log(
        none,
        b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
        (*::core::mem::transmute::<
            &[u8; 25],
            &[libc::c_char; 25],
        >(b"mln_lang_dump_array_elem\0"))
            .as_ptr(),
        6566 as libc::c_int,
        b"Value:\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    mln_lang_dump_var((*elem).value, cnt + 2 as libc::c_int, (*ls).tree);
    return 0 as libc::c_int;
}
unsafe extern "C" fn mln_lang_func_watch(mut ctx: *mut mln_lang_ctx_t) -> libc::c_int {
    let mut val: *mut mln_lang_val_t = 0 as *mut mln_lang_val_t;
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut func: *mut mln_lang_func_detail_t = 0 as *mut mln_lang_func_detail_t;
    let mut funcname: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"Watch\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    let mut v1: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"var\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    let mut v2: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"func\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    let mut v3: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"data\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    func = __mln_lang_func_detail_new(
        ctx,
        M_FUNC_INTERNAL,
        ::core::mem::transmute::<
            Option::<unsafe extern "C" fn(*mut mln_lang_ctx_t) -> *mut mln_lang_var_t>,
            *mut libc::c_void,
        >(
            Some(
                mln_lang_func_watch_process
                    as unsafe extern "C" fn(*mut mln_lang_ctx_t) -> *mut mln_lang_var_t,
            ),
        ),
        0 as *mut mln_lang_exp_t,
        0 as *mut mln_lang_exp_t,
    );
    if func.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    val = __mln_lang_val_new(ctx, 0 as libc::c_int, 0 as *mut libc::c_void);
    if val.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        __mln_lang_func_detail_free(func);
        return -(1 as libc::c_int);
    }
    var = __mln_lang_var_new(
        ctx,
        &mut v1,
        M_LANG_VAR_REFER,
        val,
        0 as *mut mln_lang_set_detail_t,
    );
    if var.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        __mln_lang_val_free(val as *mut libc::c_void);
        __mln_lang_func_detail_free(func);
        return -(1 as libc::c_int);
    }
    mln_lang_func_detail_arg_append(func, var);
    val = __mln_lang_val_new(ctx, 0 as libc::c_int, 0 as *mut libc::c_void);
    if val.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        __mln_lang_func_detail_free(func);
        return -(1 as libc::c_int);
    }
    var = __mln_lang_var_new(
        ctx,
        &mut v2,
        M_LANG_VAR_REFER,
        val,
        0 as *mut mln_lang_set_detail_t,
    );
    if var.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        __mln_lang_val_free(val as *mut libc::c_void);
        __mln_lang_func_detail_free(func);
        return -(1 as libc::c_int);
    }
    mln_lang_func_detail_arg_append(func, var);
    val = __mln_lang_val_new(ctx, 0 as libc::c_int, 0 as *mut libc::c_void);
    if val.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        __mln_lang_func_detail_free(func);
        return -(1 as libc::c_int);
    }
    var = __mln_lang_var_new(
        ctx,
        &mut v3,
        M_LANG_VAR_REFER,
        val,
        0 as *mut mln_lang_set_detail_t,
    );
    if var.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        __mln_lang_val_free(val as *mut libc::c_void);
        __mln_lang_func_detail_free(func);
        return -(1 as libc::c_int);
    }
    mln_lang_func_detail_arg_append(func, var);
    val = __mln_lang_val_new(ctx, 6 as libc::c_int, func as *mut libc::c_void);
    if val.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        __mln_lang_func_detail_free(func);
        return -(1 as libc::c_int);
    }
    var = __mln_lang_var_new(
        ctx,
        &mut funcname,
        M_LANG_VAR_NORMAL,
        val,
        0 as *mut mln_lang_set_detail_t,
    );
    if var.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        __mln_lang_val_free(val as *mut libc::c_void);
        return -(1 as libc::c_int);
    }
    if __mln_lang_symbol_node_join(ctx, M_LANG_SYMBOL_VAR, var as *mut libc::c_void)
        < 0 as libc::c_int
    {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        __mln_lang_var_free(var as *mut libc::c_void);
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn mln_lang_func_watch_process(
    mut ctx: *mut mln_lang_ctx_t,
) -> *mut mln_lang_var_t {
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut v1: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"var\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    let mut v2: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"func\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    let mut v3: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"data\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    let mut sym: *mut mln_lang_symbol_node_t = 0 as *mut mln_lang_symbol_node_t;
    let mut val1: *mut mln_lang_val_t = 0 as *mut mln_lang_val_t;
    let mut func: *mut mln_lang_func_detail_t = 0 as *mut mln_lang_func_detail_t;
    let mut dup: *mut mln_lang_func_detail_t = 0 as *mut mln_lang_func_detail_t;
    sym = __mln_lang_symbol_node_search(ctx, &mut v1, 1 as libc::c_int);
    if sym.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"Argument missing.\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        return 0 as *mut mln_lang_var_t;
    }
    val1 = (*(*sym).data.var).val;
    sym = __mln_lang_symbol_node_search(ctx, &mut v2, 1 as libc::c_int);
    if sym.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"Argument missing.\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        return 0 as *mut mln_lang_var_t;
    }
    if (*(*(*sym).data.var).val).type_0 != 6 as libc::c_int {
        var = mln_lang_var_create_false(ctx, 0 as *mut mln_string_t);
        if var.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            return 0 as *mut mln_lang_var_t;
        }
    } else {
        let mut val3: *mut mln_lang_val_t = 0 as *mut mln_lang_val_t;
        func = (*(*(*sym).data.var).val).data.func;
        sym = __mln_lang_symbol_node_search(ctx, &mut v3, 1 as libc::c_int);
        if sym.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"Argument missing.\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
            return 0 as *mut mln_lang_var_t;
        }
        val3 = (*(*sym).data.var).val;
        dup = mln_lang_func_detail_dup(ctx, func);
        if dup.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            return 0 as *mut mln_lang_var_t;
        }
        if !((*val1).func).is_null() {
            mln_lang_func_detail_free((*val1).func);
        }
        if !((*val1).udata).is_null() {
            __mln_lang_val_free((*val1).udata as *mut libc::c_void);
        }
        (*val1).func = dup;
        (*val1).udata = val3;
        (*val3).ref_0 = ((*val3).ref_0).wrapping_add(1);
        (*val3).ref_0;
        var = mln_lang_var_create_true(ctx, 0 as *mut mln_string_t);
        if var.is_null() {
            __mln_lang_errmsg(
                ctx,
                b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            return 0 as *mut mln_lang_var_t;
        }
    }
    return var;
}
unsafe extern "C" fn mln_lang_func_unwatch(mut ctx: *mut mln_lang_ctx_t) -> libc::c_int {
    let mut val: *mut mln_lang_val_t = 0 as *mut mln_lang_val_t;
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut func: *mut mln_lang_func_detail_t = 0 as *mut mln_lang_func_detail_t;
    let mut funcname: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"Unwatch\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    let mut v1: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"var\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    func = __mln_lang_func_detail_new(
        ctx,
        M_FUNC_INTERNAL,
        ::core::mem::transmute::<
            Option::<unsafe extern "C" fn(*mut mln_lang_ctx_t) -> *mut mln_lang_var_t>,
            *mut libc::c_void,
        >(
            Some(
                mln_lang_func_unwatch_process
                    as unsafe extern "C" fn(*mut mln_lang_ctx_t) -> *mut mln_lang_var_t,
            ),
        ),
        0 as *mut mln_lang_exp_t,
        0 as *mut mln_lang_exp_t,
    );
    if func.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    val = __mln_lang_val_new(ctx, 0 as libc::c_int, 0 as *mut libc::c_void);
    if val.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        __mln_lang_func_detail_free(func);
        return -(1 as libc::c_int);
    }
    var = __mln_lang_var_new(
        ctx,
        &mut v1,
        M_LANG_VAR_REFER,
        val,
        0 as *mut mln_lang_set_detail_t,
    );
    if var.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        __mln_lang_val_free(val as *mut libc::c_void);
        __mln_lang_func_detail_free(func);
        return -(1 as libc::c_int);
    }
    mln_lang_func_detail_arg_append(func, var);
    val = __mln_lang_val_new(ctx, 6 as libc::c_int, func as *mut libc::c_void);
    if val.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        __mln_lang_func_detail_free(func);
        return -(1 as libc::c_int);
    }
    var = __mln_lang_var_new(
        ctx,
        &mut funcname,
        M_LANG_VAR_NORMAL,
        val,
        0 as *mut mln_lang_set_detail_t,
    );
    if var.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        __mln_lang_val_free(val as *mut libc::c_void);
        return -(1 as libc::c_int);
    }
    if __mln_lang_symbol_node_join(ctx, M_LANG_SYMBOL_VAR, var as *mut libc::c_void)
        < 0 as libc::c_int
    {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        __mln_lang_var_free(var as *mut libc::c_void);
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn mln_lang_func_unwatch_process(
    mut ctx: *mut mln_lang_ctx_t,
) -> *mut mln_lang_var_t {
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut v1: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"var\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    let mut sym: *mut mln_lang_symbol_node_t = 0 as *mut mln_lang_symbol_node_t;
    let mut val1: *mut mln_lang_val_t = 0 as *mut mln_lang_val_t;
    sym = __mln_lang_symbol_node_search(ctx, &mut v1, 1 as libc::c_int);
    if sym.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"Argument missing.\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        return 0 as *mut mln_lang_var_t;
    }
    val1 = (*(*sym).data.var).val;
    if !((*val1).func).is_null() {
        mln_lang_func_detail_free((*val1).func);
    }
    if !((*val1).udata).is_null() {
        __mln_lang_val_free((*val1).udata as *mut libc::c_void);
    }
    (*val1).func = 0 as *mut mln_lang_func_detail_t;
    (*val1).udata = 0 as *mut mln_lang_val_t;
    var = mln_lang_var_create_nil(ctx, 0 as *mut mln_string_t);
    if var.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        return 0 as *mut mln_lang_var_t;
    }
    return var;
}
unsafe extern "C" fn mln_lang_watch_func_build(
    mut ctx: *mut mln_lang_ctx_t,
    mut node: *mut mln_lang_stack_node_t,
    mut funcdef: *mut mln_lang_func_detail_t,
    mut udata: *mut mln_lang_val_t,
    mut newval: *mut mln_lang_val_t,
) -> libc::c_int {
    let mut func: *mut mln_lang_funccall_val_t = 0 as *mut mln_lang_funccall_val_t;
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    func = __mln_lang_funccall_val_new((*ctx).pool, 0 as *mut mln_string_t);
    if func.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    (*func).prototype = funcdef;
    var = __mln_lang_var_new(
        ctx,
        0 as *mut mln_string_t,
        M_LANG_VAR_REFER,
        newval,
        0 as *mut mln_lang_set_detail_t,
    );
    if var.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        __mln_lang_funccall_val_free(func);
        return -(1 as libc::c_int);
    }
    mln_lang_funccall_val_add_arg(func, var);
    var = __mln_lang_var_new(
        ctx,
        0 as *mut mln_string_t,
        M_LANG_VAR_REFER,
        udata,
        0 as *mut mln_lang_set_detail_t,
    );
    if var.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        __mln_lang_funccall_val_free(func);
        return -(1 as libc::c_int);
    }
    mln_lang_funccall_val_add_arg(func, var);
    if mln_lang_stack_handler_funccall_run(ctx, node, func) < 0 as libc::c_int {
        __mln_lang_funccall_val_free(func);
        return -(1 as libc::c_int);
    }
    (*node).set_call(1 as libc::c_int as mln_u32_t);
    __mln_lang_funccall_val_free(func);
    return 0 as libc::c_int;
}
unsafe extern "C" fn mln_lang_func_dump(mut ctx: *mut mln_lang_ctx_t) -> libc::c_int {
    let mut val: *mut mln_lang_val_t = 0 as *mut mln_lang_val_t;
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut func: *mut mln_lang_func_detail_t = 0 as *mut mln_lang_func_detail_t;
    let mut funcname: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"Dump\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    let mut v1: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"var\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    func = __mln_lang_func_detail_new(
        ctx,
        M_FUNC_INTERNAL,
        ::core::mem::transmute::<
            Option::<unsafe extern "C" fn(*mut mln_lang_ctx_t) -> *mut mln_lang_var_t>,
            *mut libc::c_void,
        >(
            Some(
                mln_lang_func_dump_process
                    as unsafe extern "C" fn(*mut mln_lang_ctx_t) -> *mut mln_lang_var_t,
            ),
        ),
        0 as *mut mln_lang_exp_t,
        0 as *mut mln_lang_exp_t,
    );
    if func.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    val = __mln_lang_val_new(ctx, 0 as libc::c_int, 0 as *mut libc::c_void);
    if val.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        __mln_lang_func_detail_free(func);
        return -(1 as libc::c_int);
    }
    var = __mln_lang_var_new(
        ctx,
        &mut v1,
        M_LANG_VAR_REFER,
        val,
        0 as *mut mln_lang_set_detail_t,
    );
    if var.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        __mln_lang_val_free(val as *mut libc::c_void);
        __mln_lang_func_detail_free(func);
        return -(1 as libc::c_int);
    }
    mln_lang_func_detail_arg_append(func, var);
    val = __mln_lang_val_new(ctx, 6 as libc::c_int, func as *mut libc::c_void);
    if val.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        __mln_lang_func_detail_free(func);
        return -(1 as libc::c_int);
    }
    var = __mln_lang_var_new(
        ctx,
        &mut funcname,
        M_LANG_VAR_NORMAL,
        val,
        0 as *mut mln_lang_set_detail_t,
    );
    if var.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        __mln_lang_val_free(val as *mut libc::c_void);
        return -(1 as libc::c_int);
    }
    if __mln_lang_symbol_node_join(ctx, M_LANG_SYMBOL_VAR, var as *mut libc::c_void)
        < 0 as libc::c_int
    {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        __mln_lang_var_free(var as *mut libc::c_void);
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn mln_lang_func_dump_process(
    mut ctx: *mut mln_lang_ctx_t,
) -> *mut mln_lang_var_t {
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut v1: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"var\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    let mut sym: *mut mln_lang_symbol_node_t = 0 as *mut mln_lang_symbol_node_t;
    sym = __mln_lang_symbol_node_search(ctx, &mut v1, 1 as libc::c_int);
    if sym.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"Argument missing.\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        return 0 as *mut mln_lang_var_t;
    }
    mln_lang_dump_symbol(
        ctx,
        0 as *mut libc::c_void,
        sym as *mut libc::c_void,
        0 as *mut libc::c_void,
    );
    var = mln_lang_var_create_nil(ctx, 0 as *mut mln_string_t);
    if var.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        return 0 as *mut mln_lang_var_t;
    }
    return var;
}
unsafe extern "C" fn mln_lang_internal_func_installer(
    mut ctx: *mut mln_lang_ctx_t,
) -> libc::c_int {
    if mln_lang_func_resource_register(ctx) < 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    if mln_lang_func_import_handler(ctx) < 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    if mln_lang_func_dump(ctx) < 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    if mln_lang_func_stack(ctx) < 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    if mln_lang_func_watch(ctx) < 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    if mln_lang_func_unwatch(ctx) < 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    if mln_lang_func_eval(ctx) < 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    if mln_lang_func_kill(ctx) < 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    if mln_lang_func_pipe(ctx) < 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn mln_lang_func_resource_register(
    mut ctx: *mut mln_lang_ctx_t,
) -> libc::c_int {
    let mut tree: *mut mln_rbtree_t = 0 as *mut mln_rbtree_t;
    let mut rbattr: mln_rbtree_attr = mln_rbtree_attr {
        pool: 0 as *mut libc::c_void,
        pool_alloc: None,
        pool_free: None,
        cmp: None,
        data_free: None,
    };
    tree = mln_lang_resource_fetch(
        (*ctx).lang,
        b"import\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    ) as *mut mln_rbtree_t;
    if tree.is_null() {
        rbattr.pool = (*(*ctx).lang).pool as *mut libc::c_void;
        rbattr
            .pool_alloc = ::core::mem::transmute::<
            Option::<
                unsafe extern "C" fn(*mut mln_alloc_t, mln_size_t) -> *mut libc::c_void,
            >,
            rbtree_pool_alloc_handler,
        >(
            Some(
                mln_alloc_m
                    as unsafe extern "C" fn(
                        *mut mln_alloc_t,
                        mln_size_t,
                    ) -> *mut libc::c_void,
            ),
        );
        rbattr
            .pool_free = ::core::mem::transmute::<
            Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
            rbtree_pool_free_handler,
        >(Some(mln_alloc_free as unsafe extern "C" fn(*mut libc::c_void) -> ()));
        rbattr
            .cmp = ::core::mem::transmute::<
            Option::<
                unsafe extern "C" fn(
                    *const mln_lang_import_t,
                    *const mln_lang_import_t,
                ) -> libc::c_int,
            >,
            rbtree_cmp,
        >(
            Some(
                mln_lang_func_import_cmp
                    as unsafe extern "C" fn(
                        *const mln_lang_import_t,
                        *const mln_lang_import_t,
                    ) -> libc::c_int,
            ),
        );
        rbattr
            .data_free = ::core::mem::transmute::<
            Option::<unsafe extern "C" fn(*mut mln_lang_import_t) -> ()>,
            rbtree_free_data,
        >(
            Some(
                mln_lang_func_import_free
                    as unsafe extern "C" fn(*mut mln_lang_import_t) -> (),
            ),
        );
        tree = mln_rbtree_new(&mut rbattr);
        if tree.is_null() {
            mln_lang_errmsg(
                ctx,
                b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            return -(1 as libc::c_int);
        }
        if mln_lang_resource_register(
            (*ctx).lang,
            b"import\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            tree as *mut libc::c_void,
            ::core::mem::transmute::<
                Option::<unsafe extern "C" fn(*mut mln_rbtree_t) -> ()>,
                mln_lang_resource_free,
            >(Some(mln_rbtree_free as unsafe extern "C" fn(*mut mln_rbtree_t) -> ())),
        ) < 0 as libc::c_int
        {
            mln_rbtree_free(tree);
            mln_lang_errmsg(
                ctx,
                b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            return -(1 as libc::c_int);
        }
    }
    tree = mln_lang_ctx_resource_fetch(
        ctx,
        b"import\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    ) as *mut mln_rbtree_t;
    if tree.is_null() {
        rbattr.pool = (*ctx).pool as *mut libc::c_void;
        rbattr
            .pool_alloc = ::core::mem::transmute::<
            Option::<
                unsafe extern "C" fn(*mut mln_alloc_t, mln_size_t) -> *mut libc::c_void,
            >,
            rbtree_pool_alloc_handler,
        >(
            Some(
                mln_alloc_m
                    as unsafe extern "C" fn(
                        *mut mln_alloc_t,
                        mln_size_t,
                    ) -> *mut libc::c_void,
            ),
        );
        rbattr
            .pool_free = ::core::mem::transmute::<
            Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
            rbtree_pool_free_handler,
        >(Some(mln_alloc_free as unsafe extern "C" fn(*mut libc::c_void) -> ()));
        rbattr
            .cmp = ::core::mem::transmute::<
            Option::<
                unsafe extern "C" fn(
                    *mut mln_lang_ctx_import_t,
                    *mut mln_lang_ctx_import_t,
                ) -> libc::c_int,
            >,
            rbtree_cmp,
        >(
            Some(
                mln_lang_func_ctx_import_cmp
                    as unsafe extern "C" fn(
                        *mut mln_lang_ctx_import_t,
                        *mut mln_lang_ctx_import_t,
                    ) -> libc::c_int,
            ),
        );
        rbattr
            .data_free = ::core::mem::transmute::<
            Option::<unsafe extern "C" fn(*mut mln_lang_ctx_import_t) -> ()>,
            rbtree_free_data,
        >(
            Some(
                mln_lang_func_ctx_import_free
                    as unsafe extern "C" fn(*mut mln_lang_ctx_import_t) -> (),
            ),
        );
        tree = mln_rbtree_new(&mut rbattr);
        if tree.is_null() {
            mln_lang_errmsg(
                ctx,
                b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            return -(1 as libc::c_int);
        }
        if mln_lang_ctx_resource_register(
            ctx,
            b"import\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            tree as *mut libc::c_void,
            ::core::mem::transmute::<
                Option::<unsafe extern "C" fn(*mut mln_rbtree_t) -> ()>,
                mln_lang_resource_free,
            >(Some(mln_rbtree_free as unsafe extern "C" fn(*mut mln_rbtree_t) -> ())),
        ) < 0 as libc::c_int
        {
            mln_rbtree_free(tree);
            mln_lang_errmsg(
                ctx,
                b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            return -(1 as libc::c_int);
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn mln_lang_func_stack(mut ctx: *mut mln_lang_ctx_t) -> libc::c_int {
    let mut val: *mut mln_lang_val_t = 0 as *mut mln_lang_val_t;
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut func: *mut mln_lang_func_detail_t = 0 as *mut mln_lang_func_detail_t;
    let mut funcname: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"Stack\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    func = __mln_lang_func_detail_new(
        ctx,
        M_FUNC_INTERNAL,
        ::core::mem::transmute::<
            Option::<unsafe extern "C" fn(*mut mln_lang_ctx_t) -> *mut mln_lang_var_t>,
            *mut libc::c_void,
        >(
            Some(
                mln_lang_func_stack_process
                    as unsafe extern "C" fn(*mut mln_lang_ctx_t) -> *mut mln_lang_var_t,
            ),
        ),
        0 as *mut mln_lang_exp_t,
        0 as *mut mln_lang_exp_t,
    );
    if func.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    val = __mln_lang_val_new(ctx, 6 as libc::c_int, func as *mut libc::c_void);
    if val.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        __mln_lang_func_detail_free(func);
        return -(1 as libc::c_int);
    }
    var = __mln_lang_var_new(
        ctx,
        &mut funcname,
        M_LANG_VAR_NORMAL,
        val,
        0 as *mut mln_lang_set_detail_t,
    );
    if var.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        __mln_lang_val_free(val as *mut libc::c_void);
        return -(1 as libc::c_int);
    }
    if __mln_lang_symbol_node_join(ctx, M_LANG_SYMBOL_VAR, var as *mut libc::c_void)
        < 0 as libc::c_int
    {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        __mln_lang_var_free(var as *mut libc::c_void);
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn mln_lang_func_stack_process(
    mut ctx: *mut mln_lang_ctx_t,
) -> *mut mln_lang_var_t {
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut name: *mut mln_string_t = 0 as *mut mln_string_t;
    let mut anony: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"<anonymous>\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    let mut file: *mut mln_string_t = 0 as *mut mln_string_t;
    let mut line: mln_u64_t = 0;
    let mut s: *mut mln_lang_scope_t = (*ctx).scope_top;
    let mut i: libc::c_int = 0;
    i = 1 as libc::c_int;
    s = s.offset(-1);
    s;
    while s >= ((*ctx).scopes).as_mut_ptr() {
        name = if ((*s).name).is_null() { &mut anony } else { (*s).name };
        file = if ((*s).entry).is_null() { &mut anony } else { (*(*s).entry).file };
        line = if ((*s).entry).is_null() {
            0 as libc::c_int as libc::c_ulong
        } else {
            (*(*s).entry).line
        };
        _mln_sys_log(
            none,
            b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 28],
                &[libc::c_char; 28],
            >(b"mln_lang_func_stack_process\0"))
                .as_ptr(),
            6944 as libc::c_int,
            b"%d: %S %S:%I\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            i,
            name,
            file,
            line,
        );
        s = s.offset(-1);
        s;
        i += 1;
        i;
    }
    var = mln_lang_var_create_nil(ctx, 0 as *mut mln_string_t);
    if var.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        return 0 as *mut mln_lang_var_t;
    }
    return var;
}
unsafe extern "C" fn mln_lang_func_import_new(
    mut ctx: *mut mln_lang_ctx_t,
    mut name: *mut mln_string_t,
    mut handle: *mut libc::c_void,
) -> *mut mln_lang_import_t {
    let mut i: *mut mln_lang_import_t = 0 as *mut mln_lang_import_t;
    i = mln_alloc_m(
        (*(*ctx).lang).pool,
        ::core::mem::size_of::<mln_lang_import_t>() as libc::c_ulong,
    ) as *mut mln_lang_import_t;
    if i.is_null() {
        return 0 as *mut mln_lang_import_t;
    }
    (*i).name = mln_string_pool_dup((*(*ctx).lang).pool, name);
    if ((*i).name).is_null() {
        mln_alloc_free(i as *mut libc::c_void);
        return 0 as *mut mln_lang_import_t;
    }
    (*i).ref_0 = 0 as libc::c_int as mln_size_t;
    (*i).count = 65535 as libc::c_int as mln_size_t;
    (*i).handle = handle;
    (*i).node = 0 as *mut mln_rbtree_node_t;
    (*i).lang = (*ctx).lang;
    return i;
}
unsafe extern "C" fn mln_lang_func_import_cmp(
    mut i1: *const mln_lang_import_t,
    mut i2: *const mln_lang_import_t,
) -> libc::c_int {
    return mln_string_strcmp((*i1).name, (*i2).name);
}
unsafe extern "C" fn mln_lang_func_import_free(mut i: *mut mln_lang_import_t) {
    let mut destroy: import_destroy_t = None;
    if i.is_null() {
        return;
    }
    destroy = ::core::mem::transmute::<
        *mut libc::c_void,
        import_destroy_t,
    >(dlsym((*i).handle, b"destroy\0" as *const u8 as *const libc::c_char));
    if destroy.is_some() {
        destroy.expect("non-null function pointer")((*i).lang);
    }
    if !((*i).name).is_null() {
        let mut __s: *mut mln_string_t = (*i).name;
        if !__s.is_null() {
            let ref mut fresh43 = (*__s).ref_0();
            let fresh44 = *fresh43;
            *fresh43 = (*fresh43).wrapping_sub(1);
            if fresh44 <= 1 as libc::c_int as libc::c_ulong {
                if (*__s).data_ref() == 0 && !((*__s).data).is_null() {
                    if (*__s).pool() != 0 {
                        mln_alloc_free((*__s).data as *mut libc::c_void);
                    } else {
                        free((*__s).data as *mut libc::c_void);
                    }
                }
                if (*__s).pool() != 0 {
                    mln_alloc_free(__s as *mut libc::c_void);
                } else {
                    free(__s as *mut libc::c_void);
                }
            }
        }
    }
    if !((*i).handle).is_null() {
        dlclose((*i).handle);
    }
    mln_alloc_free(i as *mut libc::c_void);
}
unsafe extern "C" fn mln_lang_func_ctx_import_new(
    mut ctx: *mut mln_lang_ctx_t,
    mut i: *mut mln_lang_import_t,
) -> *mut mln_lang_ctx_import_t {
    let mut ci: *mut mln_lang_ctx_import_t = 0 as *mut mln_lang_ctx_import_t;
    ci = mln_alloc_m(
        (*ctx).pool,
        ::core::mem::size_of::<mln_lang_ctx_import_t>() as libc::c_ulong,
    ) as *mut mln_lang_ctx_import_t;
    if ci.is_null() {
        return 0 as *mut mln_lang_ctx_import_t;
    }
    (*ci).i = i;
    (*ci).ctx = ctx;
    (*(*ci).i).ref_0 = ((*(*ci).i).ref_0).wrapping_add(1);
    (*(*ci).i).ref_0;
    return ci;
}
unsafe extern "C" fn mln_lang_func_ctx_import_cmp(
    mut ci1: *mut mln_lang_ctx_import_t,
    mut ci2: *mut mln_lang_ctx_import_t,
) -> libc::c_int {
    return mln_string_strcmp((*(*ci1).i).name, (*(*ci2).i).name);
}
unsafe extern "C" fn mln_lang_func_ctx_import_free(mut ci: *mut mln_lang_ctx_import_t) {
    let mut tree: *mut mln_rbtree_t = 0 as *mut mln_rbtree_t;
    if ci.is_null() {
        return;
    }
    let mut i: *mut mln_lang_import_t = (*ci).i;
    let mut ctx: *mut mln_lang_ctx_t = (*ci).ctx;
    mln_alloc_free(ci as *mut libc::c_void);
    let fresh45 = (*i).ref_0;
    (*i).ref_0 = ((*i).ref_0).wrapping_sub(1);
    if fresh45 > 1 as libc::c_int as libc::c_ulong {
        return;
    }
    let fresh46 = (*i).count;
    (*i).count = ((*i).count).wrapping_sub(1);
    if fresh46 > 0 as libc::c_int as libc::c_ulong {
        return;
    }
    tree = mln_lang_resource_fetch(
        (*ctx).lang,
        b"import\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    ) as *mut mln_rbtree_t;
    if !tree.is_null() {
        mln_rbtree_delete(tree, (*i).node);
        mln_rbtree_node_free(tree, (*i).node);
    }
}
unsafe extern "C" fn mln_lang_func_import_handler(
    mut ctx: *mut mln_lang_ctx_t,
) -> libc::c_int {
    let mut val: *mut mln_lang_val_t = 0 as *mut mln_lang_val_t;
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut func: *mut mln_lang_func_detail_t = 0 as *mut mln_lang_func_detail_t;
    let mut funcname: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"Import\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    let mut v1: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"name\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    func = mln_lang_func_detail_new(
        ctx,
        M_FUNC_INTERNAL,
        ::core::mem::transmute::<
            Option::<unsafe extern "C" fn(*mut mln_lang_ctx_t) -> *mut mln_lang_var_t>,
            *mut libc::c_void,
        >(
            Some(
                mln_lang_func_import_process
                    as unsafe extern "C" fn(*mut mln_lang_ctx_t) -> *mut mln_lang_var_t,
            ),
        ),
        0 as *mut mln_lang_exp_t,
        0 as *mut mln_lang_exp_t,
    );
    if func.is_null() {
        mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    val = mln_lang_val_new(ctx, 0 as libc::c_int, 0 as *mut libc::c_void);
    if val.is_null() {
        mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        mln_lang_func_detail_free(func);
        return -(1 as libc::c_int);
    }
    var = mln_lang_var_new(
        ctx,
        &mut v1,
        M_LANG_VAR_NORMAL,
        val,
        0 as *mut mln_lang_set_detail_t,
    );
    if var.is_null() {
        mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        mln_lang_val_free(val);
        mln_lang_func_detail_free(func);
        return -(1 as libc::c_int);
    }
    mln_lang_func_detail_arg_append(func, var);
    val = mln_lang_val_new(ctx, 6 as libc::c_int, func as *mut libc::c_void);
    if val.is_null() {
        mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        mln_lang_func_detail_free(func);
        return -(1 as libc::c_int);
    }
    var = mln_lang_var_new(
        ctx,
        &mut funcname,
        M_LANG_VAR_NORMAL,
        val,
        0 as *mut mln_lang_set_detail_t,
    );
    if var.is_null() {
        mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        mln_lang_val_free(val);
        return -(1 as libc::c_int);
    }
    if mln_lang_symbol_node_join(ctx, M_LANG_SYMBOL_VAR, var as *mut libc::c_void)
        < 0 as libc::c_int
    {
        mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        mln_lang_var_free(var as *mut libc::c_void);
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn mln_lang_func_import_process(
    mut ctx: *mut mln_lang_ctx_t,
) -> *mut mln_lang_var_t {
    let mut ret_var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut v1: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"name\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    let mut ci: mln_lang_ctx_import_t = mln_lang_ctx_import_t {
        i: 0 as *mut mln_lang_import_t,
        ctx: 0 as *mut mln_lang_ctx_t,
    };
    let mut pci: *mut mln_lang_ctx_import_t = 0 as *mut mln_lang_ctx_import_t;
    let mut sym: *mut mln_lang_symbol_node_t = 0 as *mut mln_lang_symbol_node_t;
    let mut i: mln_lang_import_t = mln_lang_import_t {
        name: 0 as *mut mln_string_t,
        ref_0: 0,
        count: 0,
        handle: 0 as *mut libc::c_void,
        node: 0 as *mut mln_rbtree_node_t,
        lang: 0 as *mut mln_lang_t,
    };
    let mut pi: *mut mln_lang_import_t = 0 as *mut mln_lang_import_t;
    let mut name: *mut mln_string_t = 0 as *mut mln_string_t;
    let mut rn: *mut mln_rbtree_node_t = 0 as *mut mln_rbtree_node_t;
    let mut ctx_rn: *mut mln_rbtree_node_t = 0 as *mut mln_rbtree_node_t;
    let mut tree: *mut mln_rbtree_t = 0 as *mut mln_rbtree_t;
    let mut ctx_tree: *mut mln_rbtree_t = 0 as *mut mln_rbtree_t;
    let mut path: [libc::c_char; 1024] = [0; 1024];
    let mut tmp_path: [libc::c_char; 1024] = [0; 1024];
    let mut melang_dy_path: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut init: import_init_t = None;
    let mut handle: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut n: libc::c_int = 0;
    sym = mln_lang_symbol_node_search(ctx, &mut v1, 1 as libc::c_int);
    if sym.is_null() {
        mln_lang_errmsg(
            ctx,
            b"Argument 1 missing.\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        return 0 as *mut mln_lang_var_t;
    }
    if (*sym).type_0 as libc::c_uint != M_LANG_SYMBOL_VAR as libc::c_int as libc::c_uint
        || (*(*(*sym).data.var).val).type_0 != 4 as libc::c_int
    {
        mln_lang_errmsg(
            ctx,
            b"Invalid type of argument 1.\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        return 0 as *mut mln_lang_var_t;
    }
    name = (*(*(*sym).data.var).val).data.s;
    i.name = name;
    tree = mln_lang_resource_fetch(
        (*ctx).lang,
        b"import\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    ) as *mut mln_rbtree_t;
    rn = mln_rbtree_search(tree, &mut i as *mut mln_lang_import_t as *mut libc::c_void);
    if !(rn == &mut (*tree).nil as *mut mln_rbtree_node_t) {
        pi = (*rn).data as *mut mln_lang_import_t;
    } else {
        if *((*name).data).offset(0 as libc::c_int as isize) as libc::c_int == '/' as i32
        {
            n = snprintf(
                path.as_mut_ptr(),
                (::core::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                b"%s.so\0" as *const u8 as *const libc::c_char,
                (*name).data as *mut libc::c_char,
            );
            path[n as usize] = 0 as libc::c_int as libc::c_char;
        } else {
            if (*name).len > 0 as libc::c_int as libc::c_ulong
                && *((*name).data).offset(0 as libc::c_int as isize) as libc::c_int
                    != '.' as i32
            {
                n = snprintf(
                    path.as_mut_ptr(),
                    (::core::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong)
                        .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                    b"./%s.so\0" as *const u8 as *const libc::c_char,
                    (*name).data as *mut libc::c_char,
                );
            } else {
                n = snprintf(
                    path.as_mut_ptr(),
                    (::core::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong)
                        .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                    b"%s.so\0" as *const u8 as *const libc::c_char,
                    (*name).data as *mut libc::c_char,
                );
            }
            path[n as usize] = 0 as libc::c_int as libc::c_char;
            if !(access(path.as_mut_ptr(), 0 as libc::c_int) == 0) {
                let mut current_block_41: u64;
                melang_dy_path = getenv(
                    b"MELANG_DYNAMIC_PATH\0" as *const u8 as *const libc::c_char,
                );
                if !melang_dy_path.is_null() {
                    let mut end: *mut libc::c_char = strchr(melang_dy_path, ';' as i32);
                    let mut found: libc::c_int = 0 as libc::c_int;
                    while !end.is_null() {
                        *end = 0 as libc::c_int as libc::c_char;
                        n = snprintf(
                            tmp_path.as_mut_ptr(),
                            (::core::mem::size_of::<[libc::c_char; 1024]>()
                                as libc::c_ulong)
                                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                            b"%s/%s\0" as *const u8 as *const libc::c_char,
                            melang_dy_path,
                            path.as_mut_ptr(),
                        );
                        if access(tmp_path.as_mut_ptr(), 0 as libc::c_int) == 0 {
                            memcpy(
                                path.as_mut_ptr() as *mut libc::c_void,
                                tmp_path.as_mut_ptr() as *const libc::c_void,
                                n as libc::c_ulong,
                            );
                            path[n as usize] = 0 as libc::c_int as libc::c_char;
                            found = 1 as libc::c_int;
                            break;
                        } else {
                            tmp_path[n as usize] = 0 as libc::c_int as libc::c_char;
                            melang_dy_path = end.offset(1 as libc::c_int as isize);
                            end = strchr(melang_dy_path, ';' as i32);
                        }
                    }
                    if found == 0 {
                        if *melang_dy_path != 0 {
                            n = snprintf(
                                tmp_path.as_mut_ptr(),
                                (::core::mem::size_of::<[libc::c_char; 1024]>()
                                    as libc::c_ulong)
                                    .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                                b"%s/%s\0" as *const u8 as *const libc::c_char,
                                melang_dy_path,
                                path.as_mut_ptr(),
                            );
                            memcpy(
                                path.as_mut_ptr() as *mut libc::c_void,
                                tmp_path.as_mut_ptr() as *const libc::c_void,
                                n as libc::c_ulong,
                            );
                            path[n as usize] = 0 as libc::c_int as libc::c_char;
                            current_block_41 = 721385680381463314;
                        } else {
                            current_block_41 = 1969822975410276084;
                        }
                    } else {
                        current_block_41 = 721385680381463314;
                    }
                } else {
                    current_block_41 = 1969822975410276084;
                }
                match current_block_41 {
                    1969822975410276084 => {
                        n = snprintf(
                            tmp_path.as_mut_ptr(),
                            (::core::mem::size_of::<[libc::c_char; 1024]>()
                                as libc::c_ulong)
                                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                            b"%s/%s\0" as *const u8 as *const libc::c_char,
                            mln_path_melang_dylib(),
                            path.as_mut_ptr(),
                        );
                        memcpy(
                            path.as_mut_ptr() as *mut libc::c_void,
                            tmp_path.as_mut_ptr() as *const libc::c_void,
                            n as libc::c_ulong,
                        );
                        path[n as usize] = 0 as libc::c_int as libc::c_char;
                    }
                    _ => {}
                }
            }
        }
        handle = dlopen(path.as_mut_ptr(), 0x1 as libc::c_int);
        if handle.is_null() {
            n = snprintf(
                tmp_path.as_mut_ptr(),
                (::core::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                b"Load dynamic library [%s] failed.\0" as *const u8
                    as *const libc::c_char,
                path.as_mut_ptr(),
            );
            tmp_path[n as usize] = 0 as libc::c_int as libc::c_char;
            mln_lang_errmsg(ctx, tmp_path.as_mut_ptr());
            return 0 as *mut mln_lang_var_t;
        }
        pi = mln_lang_func_import_new(ctx, name, handle);
        if pi.is_null() {
            dlclose((*pi).handle);
            mln_lang_errmsg(
                ctx,
                b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            return 0 as *mut mln_lang_var_t;
        }
        rn = mln_rbtree_node_new(tree, pi as *mut libc::c_void);
        if rn.is_null() {
            mln_lang_func_import_free(pi);
            mln_lang_errmsg(
                ctx,
                b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            return 0 as *mut mln_lang_var_t;
        }
        mln_rbtree_insert(tree, rn);
        (*pi).node = rn;
    }
    ctx_tree = mln_lang_ctx_resource_fetch(
        ctx,
        b"import\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    ) as *mut mln_rbtree_t;
    ci.i = pi;
    ctx_rn = mln_rbtree_search(
        ctx_tree,
        &mut ci as *mut mln_lang_ctx_import_t as *mut libc::c_void,
    );
    if ctx_rn == &mut (*ctx_tree).nil as *mut mln_rbtree_node_t {
        pci = mln_lang_func_ctx_import_new(ctx, pi);
        if pci.is_null() {
            if (*pi).ref_0 == 0 {
                mln_rbtree_delete(tree, rn);
                mln_rbtree_node_free(tree, rn);
            }
            mln_lang_errmsg(
                ctx,
                b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            return 0 as *mut mln_lang_var_t;
        }
        ctx_rn = mln_rbtree_node_new(ctx_tree, pci as *mut libc::c_void);
        if ctx_rn.is_null() {
            mln_lang_func_ctx_import_free(pci);
            mln_lang_errmsg(
                ctx,
                b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            return 0 as *mut mln_lang_var_t;
        }
        mln_rbtree_insert(ctx_tree, ctx_rn);
    }
    init = ::core::mem::transmute::<
        *mut libc::c_void,
        import_init_t,
    >(dlsym((*pi).handle, b"init\0" as *const u8 as *const libc::c_char));
    if init.is_none() {
        n = snprintf(
            tmp_path.as_mut_ptr(),
            (::core::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
            b"No 'init' found in dynamic library [%s].\0" as *const u8
                as *const libc::c_char,
            path.as_mut_ptr(),
        );
        tmp_path[n as usize] = 0 as libc::c_int as libc::c_char;
        mln_lang_errmsg(ctx, tmp_path.as_mut_ptr());
        return 0 as *mut mln_lang_var_t;
    }
    ret_var = init.expect("non-null function pointer")(ctx, mln_conf());
    if ret_var.is_null() {
        n = snprintf(
            tmp_path.as_mut_ptr(),
            (::core::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
            b"Init dynamic library [%s] failed.\0" as *const u8 as *const libc::c_char,
            path.as_mut_ptr(),
        );
        tmp_path[n as usize] = 0 as libc::c_int as libc::c_char;
        mln_lang_errmsg(ctx, tmp_path.as_mut_ptr());
        return 0 as *mut mln_lang_var_t;
    }
    return ret_var;
}
unsafe extern "C" fn mln_lang_func_eval(mut ctx: *mut mln_lang_ctx_t) -> libc::c_int {
    let mut val: *mut mln_lang_val_t = 0 as *mut mln_lang_val_t;
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut func: *mut mln_lang_func_detail_t = 0 as *mut mln_lang_func_detail_t;
    let mut funcname: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"Eval\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    let mut v1: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"val\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    let mut v2: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"data\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    let mut v3: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"in_string\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 10]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    let mut v4: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"alias\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    func = mln_lang_func_detail_new(
        ctx,
        M_FUNC_INTERNAL,
        ::core::mem::transmute::<
            Option::<unsafe extern "C" fn(*mut mln_lang_ctx_t) -> *mut mln_lang_var_t>,
            *mut libc::c_void,
        >(
            Some(
                mln_lang_func_eval_process
                    as unsafe extern "C" fn(*mut mln_lang_ctx_t) -> *mut mln_lang_var_t,
            ),
        ),
        0 as *mut mln_lang_exp_t,
        0 as *mut mln_lang_exp_t,
    );
    if func.is_null() {
        mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    val = mln_lang_val_new(ctx, 0 as libc::c_int, 0 as *mut libc::c_void);
    if val.is_null() {
        mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        mln_lang_func_detail_free(func);
        return -(1 as libc::c_int);
    }
    var = mln_lang_var_new(
        ctx,
        &mut v1,
        M_LANG_VAR_NORMAL,
        val,
        0 as *mut mln_lang_set_detail_t,
    );
    if var.is_null() {
        mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        mln_lang_val_free(val);
        mln_lang_func_detail_free(func);
        return -(1 as libc::c_int);
    }
    mln_lang_func_detail_arg_append(func, var);
    val = mln_lang_val_new(ctx, 0 as libc::c_int, 0 as *mut libc::c_void);
    if val.is_null() {
        mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        mln_lang_func_detail_free(func);
        return -(1 as libc::c_int);
    }
    var = mln_lang_var_new(
        ctx,
        &mut v2,
        M_LANG_VAR_NORMAL,
        val,
        0 as *mut mln_lang_set_detail_t,
    );
    if var.is_null() {
        mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        mln_lang_val_free(val);
        mln_lang_func_detail_free(func);
        return -(1 as libc::c_int);
    }
    mln_lang_func_detail_arg_append(func, var);
    val = mln_lang_val_new(ctx, 0 as libc::c_int, 0 as *mut libc::c_void);
    if val.is_null() {
        mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        mln_lang_func_detail_free(func);
        return -(1 as libc::c_int);
    }
    var = mln_lang_var_new(
        ctx,
        &mut v3,
        M_LANG_VAR_NORMAL,
        val,
        0 as *mut mln_lang_set_detail_t,
    );
    if var.is_null() {
        mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        mln_lang_val_free(val);
        mln_lang_func_detail_free(func);
        return -(1 as libc::c_int);
    }
    mln_lang_func_detail_arg_append(func, var);
    val = mln_lang_val_new(ctx, 0 as libc::c_int, 0 as *mut libc::c_void);
    if val.is_null() {
        mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        mln_lang_func_detail_free(func);
        return -(1 as libc::c_int);
    }
    var = mln_lang_var_new(
        ctx,
        &mut v4,
        M_LANG_VAR_NORMAL,
        val,
        0 as *mut mln_lang_set_detail_t,
    );
    if var.is_null() {
        mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        mln_lang_val_free(val);
        mln_lang_func_detail_free(func);
        return -(1 as libc::c_int);
    }
    mln_lang_func_detail_arg_append(func, var);
    val = mln_lang_val_new(ctx, 6 as libc::c_int, func as *mut libc::c_void);
    if val.is_null() {
        mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        mln_lang_func_detail_free(func);
        return -(1 as libc::c_int);
    }
    var = mln_lang_var_new(
        ctx,
        &mut funcname,
        M_LANG_VAR_NORMAL,
        val,
        0 as *mut mln_lang_set_detail_t,
    );
    if var.is_null() {
        mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        mln_lang_val_free(val);
        return -(1 as libc::c_int);
    }
    if mln_lang_symbol_node_join(ctx, M_LANG_SYMBOL_VAR, var as *mut libc::c_void)
        < 0 as libc::c_int
    {
        mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        mln_lang_var_free(var as *mut libc::c_void);
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn mln_lang_func_eval_process(
    mut ctx: *mut mln_lang_ctx_t,
) -> *mut mln_lang_var_t {
    let mut ret_var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut v1: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"val\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    let mut v2: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"data\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    let mut v3: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"in_string\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 10]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    let mut v4: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"alias\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    let mut data_name: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"EVAL_DATA\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 10]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    let mut dup: *mut mln_string_t = 0 as *mut mln_string_t;
    let mut alias: *mut mln_string_t = 0 as *mut mln_string_t;
    let mut path: *mut mln_string_t = 0 as *mut mln_string_t;
    let mut tmp: mln_string_t = mln_string_t {
        data: 0 as *mut libc::c_uchar,
        len: 0,
        data_ref_pool_ref_0: [0; 4],
        c2rust_padding: [0; 4],
    };
    let mut sym: *mut mln_lang_symbol_node_t = 0 as *mut mln_lang_symbol_node_t;
    let mut val1: *mut mln_lang_val_t = 0 as *mut mln_lang_val_t;
    let mut val2: *mut mln_lang_val_t = 0 as *mut mln_lang_val_t;
    let mut type_0: mln_s32_t = 0;
    let mut type3: mln_s32_t = 0;
    let mut job_type: mln_u32_t = 0;
    let mut data: mln_u8ptr_t = 0 as *mut libc::c_uchar;
    let mut newctx: *mut mln_lang_ctx_t = 0 as *mut mln_lang_ctx_t;
    let mut buf: [libc::c_char; 1024] = [0; 1024];
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut n: libc::c_int = 0;
    sym = mln_lang_symbol_node_search(ctx, &mut v1, 1 as libc::c_int);
    if sym.is_null() {
        mln_lang_errmsg(
            ctx,
            b"Argument 1 missing.\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        return 0 as *mut mln_lang_var_t;
    }
    if (*sym).type_0 as libc::c_uint != M_LANG_SYMBOL_VAR as libc::c_int as libc::c_uint
    {
        mln_lang_errmsg(
            ctx,
            b"Invalid type of argument 1.\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        return 0 as *mut mln_lang_var_t;
    }
    if (*(*(*sym).data.var).val).type_0 == 0 as libc::c_int {
        return mln_lang_func_eval_process_list(ctx);
    }
    if (*(*(*sym).data.var).val).type_0 != 4 as libc::c_int {
        mln_lang_errmsg(
            ctx,
            b"Invalid type of argument 1.\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        return 0 as *mut mln_lang_var_t;
    }
    val1 = (*(*sym).data.var).val;
    sym = mln_lang_symbol_node_search(ctx, &mut v2, 1 as libc::c_int);
    if sym.is_null() {
        mln_lang_errmsg(
            ctx,
            b"Argument 2 missing.\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        return 0 as *mut mln_lang_var_t;
    }
    if (*sym).type_0 as libc::c_uint != M_LANG_SYMBOL_VAR as libc::c_int as libc::c_uint
    {
        mln_lang_errmsg(
            ctx,
            b"Invalid type of argument 2.\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        return 0 as *mut mln_lang_var_t;
    }
    val2 = (*(*sym).data.var).val;
    type_0 = (*(*(*sym).data.var).val).type_0;
    if type_0 < 0 as libc::c_int || type_0 >= 5 as libc::c_int {
        mln_lang_errmsg(
            ctx,
            b"Invalid type of argument 2, only support nil, int, real, boolean, string.\0"
                as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        return 0 as *mut mln_lang_var_t;
    }
    sym = mln_lang_symbol_node_search(ctx, &mut v3, 1 as libc::c_int);
    if sym.is_null() {
        mln_lang_errmsg(
            ctx,
            b"Argument 3 missing.\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        return 0 as *mut mln_lang_var_t;
    }
    if (*sym).type_0 as libc::c_uint != M_LANG_SYMBOL_VAR as libc::c_int as libc::c_uint
    {
        mln_lang_errmsg(
            ctx,
            b"Invalid type of argument 3.\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        return 0 as *mut mln_lang_var_t;
    }
    type3 = (*(*(*sym).data.var).val).type_0;
    if type3 == 2 as libc::c_int && (*(*(*sym).data.var).val).data.b as libc::c_int != 0
    {
        job_type = 0 as libc::c_int as mln_u32_t;
    } else {
        job_type = 1 as libc::c_int as mln_u32_t;
    }
    sym = mln_lang_symbol_node_search(ctx, &mut v4, 1 as libc::c_int);
    if sym.is_null() {
        mln_lang_errmsg(
            ctx,
            b"Argument 4 missing.\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        return 0 as *mut mln_lang_var_t;
    }
    if (*sym).type_0 as libc::c_uint != M_LANG_SYMBOL_VAR as libc::c_int as libc::c_uint
    {
        mln_lang_errmsg(
            ctx,
            b"Invalid type of argument 4.\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        return 0 as *mut mln_lang_var_t;
    }
    if (*(*(*sym).data.var).val).type_0 == 0 as libc::c_int {
        alias = 0 as *mut mln_string_t;
    } else if (*(*(*sym).data.var).val).type_0 == 4 as libc::c_int {
        alias = (*(*(*sym).data.var).val).data.s;
    } else {
        mln_lang_errmsg(
            ctx,
            b"Invalid type of argument 4.\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        return 0 as *mut mln_lang_var_t;
    }
    path = (*val1).data.s;
    if (*path).len != 0
        && *((*path).data).offset(0 as libc::c_int as isize) as libc::c_int == '@' as i32
        && !((*ctx).filename).is_null()
    {
        p = strrchr((*(*ctx).filename).data as *const libc::c_char, '/' as i32);
        if p.is_null() {
            if (*path).len > 1 as libc::c_int as libc::c_ulong
                && *((*path).data).offset(1 as libc::c_int as isize) as libc::c_int
                    == '/' as i32
            {
                tmp.data = ((*path).data).offset(2 as libc::c_int as isize);
                tmp.len = ((*path).len).wrapping_sub(2 as libc::c_int as libc::c_ulong);
            } else {
                tmp.data = ((*path).data).offset(1 as libc::c_int as isize);
                tmp.len = ((*path).len).wrapping_sub(1 as libc::c_int as libc::c_ulong);
            }
        } else {
            n = (::core::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_int;
            if n as libc::c_long
                > p.offset_from((*(*ctx).filename).data as *mut libc::c_char)
                    as libc::c_long
            {
                n = p.offset_from((*(*ctx).filename).data as *mut libc::c_char)
                    as libc::c_long as libc::c_int;
            }
            memcpy(
                buf.as_mut_ptr() as *mut libc::c_void,
                (*(*ctx).filename).data as *const libc::c_void,
                n as libc::c_ulong,
            );
            n
                += snprintf(
                    buf.as_mut_ptr().offset(n as isize),
                    (::core::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong)
                        .wrapping_sub(n as libc::c_ulong)
                        .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                    b"/%s\0" as *const u8 as *const libc::c_char,
                    &mut *((*path).data).offset(1 as libc::c_int as isize)
                        as *mut libc::c_uchar as *mut libc::c_char,
                );
            buf[n as usize] = 0 as libc::c_int as libc::c_char;
            ({
                tmp.data = buf.as_mut_ptr() as mln_u8ptr_t;
                tmp.len = n as mln_u64_t;
                tmp.set_data_ref(1 as libc::c_int as mln_uauto_t);
                tmp.set_pool(0 as libc::c_int as mln_uauto_t);
                tmp.set_ref_0(1 as libc::c_int as mln_uauto_t);
                &mut tmp;
                &mut tmp
            });
        }
        path = &mut tmp;
    }
    newctx = __mln_lang_job_new(
        (*ctx).lang,
        alias,
        job_type,
        path,
        0 as *mut libc::c_void,
        None,
    );
    if newctx.is_null() {
        ret_var = mln_lang_var_create_false(ctx, 0 as *mut mln_string_t);
        if ret_var.is_null() {
            mln_lang_errmsg(
                ctx,
                b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            return 0 as *mut mln_lang_var_t;
        }
        return ret_var;
    }
    match type_0 {
        0 => {
            data = 0 as mln_u8ptr_t;
        }
        1 => {
            data = &mut (*val2).data.i as *mut mln_s64_t as mln_u8ptr_t;
        }
        2 => {
            data = &mut (*val2).data.b as *mut mln_u8_t as mln_u8ptr_t;
        }
        3 => {
            data = &mut (*val2).data.f as *mut libc::c_double as mln_u8ptr_t;
        }
        4 => {
            data = mln_string_pool_dup((*newctx).pool, (*val2).data.s) as mln_u8ptr_t;
            if data.is_null() {
                mln_lang_errmsg(
                    ctx,
                    b"No memory.\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                );
                __mln_lang_job_free(newctx);
                return 0 as *mut mln_lang_var_t;
            }
        }
        _ => {
            mln_lang_errmsg(
                ctx,
                b"Invalid type of argument 2\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
            return 0 as *mut mln_lang_var_t;
        }
    }
    dup = mln_string_pool_dup((*newctx).pool, &mut data_name);
    if dup.is_null() {
        mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if type_0 == 4 as libc::c_int {
            let mut __s: *mut mln_string_t = data as *mut mln_string_t;
            if !__s.is_null() {
                let ref mut fresh47 = (*__s).ref_0();
                let fresh48 = *fresh47;
                *fresh47 = (*fresh47).wrapping_sub(1);
                if fresh48 <= 1 as libc::c_int as libc::c_ulong {
                    if (*__s).data_ref() == 0 && !((*__s).data).is_null() {
                        if (*__s).pool() != 0 {
                            mln_alloc_free((*__s).data as *mut libc::c_void);
                        } else {
                            free((*__s).data as *mut libc::c_void);
                        }
                    }
                    if (*__s).pool() != 0 {
                        mln_alloc_free(__s as *mut libc::c_void);
                    } else {
                        free(__s as *mut libc::c_void);
                    }
                }
            }
        }
        __mln_lang_job_free(newctx);
        return 0 as *mut mln_lang_var_t;
    }
    if mln_lang_ctx_global_var_add(
        newctx,
        dup,
        data as *mut libc::c_void,
        type_0 as mln_u32_t,
    ) < 0 as libc::c_int
    {
        mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        let mut __s: *mut mln_string_t = dup;
        if !__s.is_null() {
            let ref mut fresh49 = (*__s).ref_0();
            let fresh50 = *fresh49;
            *fresh49 = (*fresh49).wrapping_sub(1);
            if fresh50 <= 1 as libc::c_int as libc::c_ulong {
                if (*__s).data_ref() == 0 && !((*__s).data).is_null() {
                    if (*__s).pool() != 0 {
                        mln_alloc_free((*__s).data as *mut libc::c_void);
                    } else {
                        free((*__s).data as *mut libc::c_void);
                    }
                }
                if (*__s).pool() != 0 {
                    mln_alloc_free(__s as *mut libc::c_void);
                } else {
                    free(__s as *mut libc::c_void);
                }
            }
        }
        if type_0 == 4 as libc::c_int {
            let mut __s: *mut mln_string_t = data as *mut mln_string_t;
            if !__s.is_null() {
                let ref mut fresh51 = (*__s).ref_0();
                let fresh52 = *fresh51;
                *fresh51 = (*fresh51).wrapping_sub(1);
                if fresh52 <= 1 as libc::c_int as libc::c_ulong {
                    if (*__s).data_ref() == 0 && !((*__s).data).is_null() {
                        if (*__s).pool() != 0 {
                            mln_alloc_free((*__s).data as *mut libc::c_void);
                        } else {
                            free((*__s).data as *mut libc::c_void);
                        }
                    }
                    if (*__s).pool() != 0 {
                        mln_alloc_free(__s as *mut libc::c_void);
                    } else {
                        free(__s as *mut libc::c_void);
                    }
                }
            }
        }
        __mln_lang_job_free(newctx);
        return 0 as *mut mln_lang_var_t;
    }
    let mut __s: *mut mln_string_t = dup;
    if !__s.is_null() {
        let ref mut fresh53 = (*__s).ref_0();
        let fresh54 = *fresh53;
        *fresh53 = (*fresh53).wrapping_sub(1);
        if fresh54 <= 1 as libc::c_int as libc::c_ulong {
            if (*__s).data_ref() == 0 && !((*__s).data).is_null() {
                if (*__s).pool() != 0 {
                    mln_alloc_free((*__s).data as *mut libc::c_void);
                } else {
                    free((*__s).data as *mut libc::c_void);
                }
            }
            if (*__s).pool() != 0 {
                mln_alloc_free(__s as *mut libc::c_void);
            } else {
                free(__s as *mut libc::c_void);
            }
        }
    }
    ret_var = mln_lang_var_create_nil(ctx, 0 as *mut mln_string_t);
    if ret_var.is_null() {
        mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        __mln_lang_job_free(newctx);
        return 0 as *mut mln_lang_var_t;
    }
    return ret_var;
}
#[inline]
unsafe extern "C" fn mln_lang_func_eval_process_list(
    mut ctx: *mut mln_lang_ctx_t,
) -> *mut mln_lang_var_t {
    let mut c: *mut mln_lang_ctx_t = 0 as *mut mln_lang_ctx_t;
    let mut ret_var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut key: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut arr: *mut mln_lang_array_t = 0 as *mut mln_lang_array_t;
    ret_var = mln_lang_var_create_array(ctx, 0 as *mut mln_string_t);
    if ret_var.is_null() {
        __mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        return 0 as *mut mln_lang_var_t;
    }
    arr = (*(*ret_var).val).data.array;
    c = (*(*ctx).lang).run_head;
    while !c.is_null() {
        if !((*c).alias).is_null() {
            key = mln_lang_var_create_ref_string(
                ctx,
                (*c).alias,
                0 as *mut mln_string_t,
            );
            if key.is_null() {
                __mln_lang_var_free(ret_var as *mut libc::c_void);
                __mln_lang_errmsg(
                    ctx,
                    b"No memory.\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                );
                return 0 as *mut mln_lang_var_t;
            }
            var = mln_lang_array_get(ctx, arr, key);
            if var.is_null() {
                __mln_lang_var_free(key as *mut libc::c_void);
                __mln_lang_var_free(ret_var as *mut libc::c_void);
                __mln_lang_errmsg(
                    ctx,
                    b"No memory.\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                );
                return 0 as *mut mln_lang_var_t;
            }
            __mln_lang_var_free(key as *mut libc::c_void);
            mln_lang_var_set_string(
                var,
                ({
                    let mut __s: *mut mln_string_t = (*c).alias;
                    (*__s).set_ref_0((*__s).ref_0() + 1);
                    (*__s).ref_0();
                    __s
                }),
            );
        }
        c = (*c).next;
    }
    c = (*(*ctx).lang).wait_head;
    while !c.is_null() {
        if !((*c).alias).is_null() {
            key = mln_lang_var_create_ref_string(
                ctx,
                (*c).alias,
                0 as *mut mln_string_t,
            );
            if key.is_null() {
                __mln_lang_var_free(ret_var as *mut libc::c_void);
                __mln_lang_errmsg(
                    ctx,
                    b"No memory.\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                );
                return 0 as *mut mln_lang_var_t;
            }
            var = mln_lang_array_get(ctx, arr, key);
            if var.is_null() {
                __mln_lang_var_free(key as *mut libc::c_void);
                __mln_lang_var_free(ret_var as *mut libc::c_void);
                __mln_lang_errmsg(
                    ctx,
                    b"No memory.\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                );
                return 0 as *mut mln_lang_var_t;
            }
            __mln_lang_var_free(key as *mut libc::c_void);
            mln_lang_var_set_string(
                var,
                ({
                    let mut __s: *mut mln_string_t = (*c).alias;
                    (*__s).set_ref_0((*__s).ref_0() + 1);
                    (*__s).ref_0();
                    __s
                }),
            );
        }
        c = (*c).next;
    }
    return ret_var;
}
unsafe extern "C" fn mln_lang_func_kill(mut ctx: *mut mln_lang_ctx_t) -> libc::c_int {
    let mut val: *mut mln_lang_val_t = 0 as *mut mln_lang_val_t;
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut func: *mut mln_lang_func_detail_t = 0 as *mut mln_lang_func_detail_t;
    let mut funcname: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"Kill\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    let mut v1: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"alias\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    func = mln_lang_func_detail_new(
        ctx,
        M_FUNC_INTERNAL,
        ::core::mem::transmute::<
            Option::<unsafe extern "C" fn(*mut mln_lang_ctx_t) -> *mut mln_lang_var_t>,
            *mut libc::c_void,
        >(
            Some(
                mln_lang_func_kill_process
                    as unsafe extern "C" fn(*mut mln_lang_ctx_t) -> *mut mln_lang_var_t,
            ),
        ),
        0 as *mut mln_lang_exp_t,
        0 as *mut mln_lang_exp_t,
    );
    if func.is_null() {
        mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    val = mln_lang_val_new(ctx, 0 as libc::c_int, 0 as *mut libc::c_void);
    if val.is_null() {
        mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        mln_lang_func_detail_free(func);
        return -(1 as libc::c_int);
    }
    var = mln_lang_var_new(
        ctx,
        &mut v1,
        M_LANG_VAR_NORMAL,
        val,
        0 as *mut mln_lang_set_detail_t,
    );
    if var.is_null() {
        mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        mln_lang_val_free(val);
        mln_lang_func_detail_free(func);
        return -(1 as libc::c_int);
    }
    mln_lang_func_detail_arg_append(func, var);
    val = mln_lang_val_new(ctx, 6 as libc::c_int, func as *mut libc::c_void);
    if val.is_null() {
        mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        mln_lang_func_detail_free(func);
        return -(1 as libc::c_int);
    }
    var = mln_lang_var_new(
        ctx,
        &mut funcname,
        M_LANG_VAR_NORMAL,
        val,
        0 as *mut mln_lang_set_detail_t,
    );
    if var.is_null() {
        mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        mln_lang_val_free(val);
        return -(1 as libc::c_int);
    }
    if mln_lang_symbol_node_join(ctx, M_LANG_SYMBOL_VAR, var as *mut libc::c_void)
        < 0 as libc::c_int
    {
        mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        mln_lang_var_free(var as *mut libc::c_void);
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn mln_lang_func_kill_process(
    mut ctx: *mut mln_lang_ctx_t,
) -> *mut mln_lang_var_t {
    let mut ret_var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut v1: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"alias\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    let mut sym: *mut mln_lang_symbol_node_t = 0 as *mut mln_lang_symbol_node_t;
    let mut killed_ctx: *mut mln_lang_ctx_t = 0 as *mut mln_lang_ctx_t;
    let mut tmp: mln_lang_ctx_t = mln_lang_ctx_t {
        lang: 0 as *mut mln_lang_t,
        pool: 0 as *mut mln_alloc_t,
        fset: 0 as *mut mln_fileset_t,
        data: 0 as *mut libc::c_void,
        stm: 0 as *mut mln_lang_stm_t,
        run_stack: [mln_lang_stack_node_t {
            ctx: 0 as *mut mln_lang_ctx_t,
            type_0: M_LSNT_STM,
            step_call: [0; 4],
            data: C2RustUnnamed_10 {
                stm: 0 as *mut mln_lang_stm_t,
            },
            ret_var: 0 as *mut mln_lang_var_t,
            ret_var2: 0 as *mut mln_lang_var_t,
            pos: 0 as *mut libc::c_void,
        }; 1025],
        run_stack_top: 0 as *mut mln_lang_stack_node_t,
        scopes: [mln_lang_scope_t {
            type_0: M_LANG_SCOPE_TYPE_SET,
            name: 0 as *mut mln_string_t,
            ctx: 0 as *mut mln_lang_ctx_t,
            cur_stack: 0 as *mut mln_lang_stack_node_t,
            entry: 0 as *mut mln_lang_stm_t,
            layer: 0,
            sym_head: 0 as *mut mln_lang_symbol_node_t,
            sym_tail: 0 as *mut mln_lang_symbol_node_t,
        }; 1025],
        scope_top: 0 as *mut mln_lang_scope_t,
        ref_0: 0,
        filename: 0 as *mut mln_string_t,
        resource_set: 0 as *mut mln_rbtree_t,
        ret_var: 0 as *mut mln_lang_var_t,
        return_handler: None,
        cache: 0 as *mut mln_lang_ast_cache_t,
        gc: 0 as *mut mln_gc_t,
        symbols: 0 as *mut mln_lang_hash_t,
        prev: 0 as *mut mln_lang_ctx_s,
        next: 0 as *mut mln_lang_ctx_s,
        sym_head: 0 as *mut mln_lang_symbol_node_t,
        sym_tail: 0 as *mut mln_lang_symbol_node_t,
        owner: 0,
        alias: 0 as *mut mln_string_t,
        sym_count_ret_flag_op_array_flag_op_bool_flag_op_func_flag_op_int_flag_op_nil_flag_op_obj_flag_op_real_flag_op_str_flag_quit_padding: [0; 4],
        c2rust_padding: [0; 4],
    };
    let mut rn: *mut mln_rbtree_node_t = 0 as *mut mln_rbtree_node_t;
    sym = mln_lang_symbol_node_search(ctx, &mut v1, 1 as libc::c_int);
    if sym.is_null() {
        mln_lang_errmsg(
            ctx,
            b"Argument 1 missing.\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        return 0 as *mut mln_lang_var_t;
    }
    if (*sym).type_0 as libc::c_uint != M_LANG_SYMBOL_VAR as libc::c_int as libc::c_uint
        || (*(*(*sym).data.var).val).type_0 != 4 as libc::c_int
    {
        mln_lang_errmsg(
            ctx,
            b"Invalid type of argument 1.\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        return 0 as *mut mln_lang_var_t;
    }
    tmp.alias = (*(*(*sym).data.var).val).data.s;
    rn = mln_rbtree_search(
        (*(*ctx).lang).alias_set,
        &mut tmp as *mut mln_lang_ctx_t as *mut libc::c_void,
    );
    if !(rn == &mut (*(*(*ctx).lang).alias_set).nil as *mut mln_rbtree_node_t) {
        killed_ctx = (*rn).data as *mut mln_lang_ctx_t;
        __mln_lang_job_free(killed_ctx);
    }
    ret_var = mln_lang_var_create_nil(ctx, 0 as *mut mln_string_t);
    if ret_var.is_null() {
        mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        return 0 as *mut mln_lang_var_t;
    }
    return ret_var;
}
#[inline]
unsafe extern "C" fn mln_lang_gc_item_new(
    mut pool: *mut mln_alloc_t,
    mut gc: *mut mln_gc_t,
    mut type_0: mln_lang_gc_type_t,
    mut data: *mut libc::c_void,
) -> libc::c_int {
    let mut gi: *mut mln_lang_gc_item_t = 0 as *mut mln_lang_gc_item_t;
    gi = mln_alloc_m(pool, ::core::mem::size_of::<mln_lang_gc_item_t>() as libc::c_ulong)
        as *mut mln_lang_gc_item_t;
    if gi.is_null() {
        return -(1 as libc::c_int);
    }
    (*gi).gc = gc;
    (*gi).type_0 = type_0;
    match type_0 as libc::c_uint {
        0 => {
            (*gi).data.obj = data as *mut mln_lang_object_t;
            (*(*gi).data.obj).gc_item = gi;
        }
        _ => {
            (*gi).data.array = data as *mut mln_lang_array_t;
            (*(*gi).data.array).gc_item = gi;
        }
    }
    (*gi).gc_data = 0 as *mut libc::c_void;
    if mln_gc_add(gc, gi as *mut libc::c_void) < 0 as libc::c_int {
        mln_alloc_free(gi as *mut libc::c_void);
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn mln_lang_gc_item_free(mut gc_item: *mut mln_lang_gc_item_t) {
    if gc_item.is_null() {
        return;
    }
    match (*gc_item).type_0 as libc::c_uint {
        0 => {
            (*(*gc_item).data.obj).gc_item = 0 as *mut mln_lang_gc_item_t;
            mln_lang_object_free((*gc_item).data.obj);
        }
        _ => {
            (*(*gc_item).data.array).gc_item = 0 as *mut mln_lang_gc_item_t;
            __mln_lang_array_free((*gc_item).data.array);
        }
    }
    mln_alloc_free(gc_item as *mut libc::c_void);
}
#[inline]
unsafe extern "C" fn mln_lang_gc_item_free_immediatly(
    mut gc_item: *mut mln_lang_gc_item_t,
) {
    if gc_item.is_null() {
        return;
    }
    mln_alloc_free(gc_item as *mut libc::c_void);
}
unsafe extern "C" fn mln_lang_gc_item_getter(
    mut gc_item: *mut mln_lang_gc_item_t,
) -> *mut libc::c_void {
    return (*gc_item).gc_data;
}
unsafe extern "C" fn mln_lang_gc_item_setter(
    mut gc_item: *mut mln_lang_gc_item_t,
    mut gc_data: *mut libc::c_void,
) {
    (*gc_item).gc_data = gc_data;
}
unsafe extern "C" fn mln_lang_gc_item_member_setter(
    mut gc: *mut mln_gc_t,
    mut gc_item: *mut mln_lang_gc_item_t,
) {
    let mut lgs: mln_lang_gc_setter_s = mln_lang_gc_setter_s {
        visited: 0 as *mut mln_rbtree_t,
        gc: 0 as *mut mln_gc_t,
    };
    let mut rbattr: mln_rbtree_attr = mln_rbtree_attr {
        pool: 0 as *mut libc::c_void,
        pool_alloc: None,
        pool_free: None,
        cmp: None,
        data_free: None,
    };
    rbattr
        .pool = (if (*gc_item).type_0 as libc::c_uint
        == M_GC_OBJ as libc::c_int as libc::c_uint
    {
        (*(*(*gc_item).data.obj).ctx).pool
    } else {
        (*(*(*gc_item).data.array).ctx).pool
    }) as *mut libc::c_void;
    rbattr
        .pool_alloc = ::core::mem::transmute::<
        Option::<
            unsafe extern "C" fn(*mut mln_alloc_t, mln_size_t) -> *mut libc::c_void,
        >,
        rbtree_pool_alloc_handler,
    >(
        Some(
            mln_alloc_m
                as unsafe extern "C" fn(
                    *mut mln_alloc_t,
                    mln_size_t,
                ) -> *mut libc::c_void,
        ),
    );
    rbattr
        .pool_free = ::core::mem::transmute::<
        Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
        rbtree_pool_free_handler,
    >(Some(mln_alloc_free as unsafe extern "C" fn(*mut libc::c_void) -> ()));
    rbattr
        .cmp = Some(
        mln_lang_gc_setter_cmp
            as unsafe extern "C" fn(
                *const libc::c_void,
                *const libc::c_void,
            ) -> libc::c_int,
    );
    rbattr.data_free = None;
    lgs.visited = mln_rbtree_new(&mut rbattr);
    if (lgs.visited).is_null() {
        _mln_sys_log(
            error,
            b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 31],
                &[libc::c_char; 31],
            >(b"mln_lang_gc_item_member_setter\0"))
                .as_ptr(),
            7700 as libc::c_int,
            b"No memory.\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        abort();
    }
    lgs.gc = gc;
    mln_lang_gc_item_member_setter_recursive(&mut lgs, gc_item);
    mln_rbtree_free(lgs.visited);
}
unsafe extern "C" fn mln_lang_gc_setter_cmp(
    mut data1: *const libc::c_void,
    mut data2: *const libc::c_void,
) -> libc::c_int {
    return (data1 as mln_size_t).wrapping_sub(data2 as mln_size_t) as libc::c_int;
}
unsafe extern "C" fn mln_lang_gc_item_member_setter_recursive(
    mut lgs: *mut mln_lang_gc_setter_s,
    mut gc_item: *mut mln_lang_gc_item_t,
) {
    let mut t: *mut mln_rbtree_t = 0 as *mut mln_rbtree_t;
    let mut node: *mut mln_rbtree_node_t = 0 as *mut mln_rbtree_node_t;
    node = mln_rbtree_search((*lgs).visited, gc_item as *mut libc::c_void);
    if !(node == &mut (*(*lgs).visited).nil as *mut mln_rbtree_node_t) {
        return;
    }
    node = mln_rbtree_node_new((*lgs).visited, gc_item as *mut libc::c_void);
    if node.is_null() {
        _mln_sys_log(
            error,
            b"src/mln_lang.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 41],
                &[libc::c_char; 41],
            >(b"mln_lang_gc_item_member_setter_recursive\0"))
                .as_ptr(),
            7726 as libc::c_int,
            b"No memory.\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        abort();
    }
    mln_rbtree_insert((*lgs).visited, node);
    match (*gc_item).type_0 as libc::c_uint {
        0 => {
            t = (*(*gc_item).data.obj).members;
            mln_rbtree_iterate(
                t,
                Some(
                    mln_lang_gc_item_member_setter_obj_iterate_handler
                        as unsafe extern "C" fn(
                            *mut mln_rbtree_node_t,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                lgs as *mut libc::c_void,
            );
        }
        _ => {
            t = (*(*gc_item).data.array).elems_index;
            mln_rbtree_iterate(
                t,
                Some(
                    mln_lang_gc_item_member_setter_array_iterate_handler
                        as unsafe extern "C" fn(
                            *mut mln_rbtree_node_t,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                lgs as *mut libc::c_void,
            );
        }
    };
}
unsafe extern "C" fn mln_lang_gc_item_member_setter_obj_iterate_handler(
    mut node: *mut mln_rbtree_node_t,
    mut udata: *mut libc::c_void,
) -> libc::c_int {
    let mut val: *mut mln_lang_val_t = 0 as *mut mln_lang_val_t;
    let mut var: *mut mln_lang_var_t = (*node).data as *mut mln_lang_var_t;
    let mut lgs: *mut mln_lang_gc_setter_s = udata as *mut mln_lang_gc_setter_s;
    let mut type_0: mln_s32_t = (*(*var).val).type_0;
    val = (*var).val;
    if type_0 == 5 as libc::c_int {
        mln_gc_collect_add((*lgs).gc, (*(*val).data.obj).gc_item as *mut libc::c_void);
        mln_lang_gc_item_member_setter_recursive(lgs, (*(*val).data.obj).gc_item);
    } else if type_0 == 7 as libc::c_int {
        mln_gc_collect_add((*lgs).gc, (*(*val).data.array).gc_item as *mut libc::c_void);
        mln_lang_gc_item_member_setter_recursive(lgs, (*(*val).data.array).gc_item);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn mln_lang_gc_item_member_setter_array_iterate_handler(
    mut node: *mut mln_rbtree_node_t,
    mut udata: *mut libc::c_void,
) -> libc::c_int {
    let mut val: *mut mln_lang_val_t = 0 as *mut mln_lang_val_t;
    let mut elem: *mut mln_lang_array_elem_t = (*node).data
        as *mut mln_lang_array_elem_t;
    let mut lgs: *mut mln_lang_gc_setter_s = udata as *mut mln_lang_gc_setter_s;
    let mut type_0: mln_s32_t = 0;
    if !((*elem).key).is_null() {
        type_0 = (*(*(*elem).key).val).type_0;
        val = (*(*elem).key).val;
        if type_0 == 5 as libc::c_int {
            mln_gc_collect_add(
                (*lgs).gc,
                (*(*val).data.obj).gc_item as *mut libc::c_void,
            );
            mln_lang_gc_item_member_setter_recursive(lgs, (*(*val).data.obj).gc_item);
        } else if type_0 == 7 as libc::c_int {
            mln_gc_collect_add(
                (*lgs).gc,
                (*(*val).data.array).gc_item as *mut libc::c_void,
            );
            mln_lang_gc_item_member_setter_recursive(lgs, (*(*val).data.array).gc_item);
        }
    }
    if !((*elem).value).is_null() {
        type_0 = (*(*(*elem).value).val).type_0;
        val = (*(*elem).value).val;
        if type_0 == 5 as libc::c_int {
            mln_gc_collect_add(
                (*lgs).gc,
                (*(*val).data.obj).gc_item as *mut libc::c_void,
            );
            mln_lang_gc_item_member_setter_recursive(lgs, (*(*val).data.obj).gc_item);
        } else if type_0 == 7 as libc::c_int {
            mln_gc_collect_add(
                (*lgs).gc,
                (*(*val).data.array).gc_item as *mut libc::c_void,
            );
            mln_lang_gc_item_member_setter_recursive(lgs, (*(*val).data.array).gc_item);
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn mln_lang_gc_item_move_handler(
    mut dest_gc: *mut mln_gc_t,
    mut gc_item: *mut mln_lang_gc_item_t,
) {
    (*gc_item).gc = dest_gc;
}
unsafe extern "C" fn mln_lang_gc_item_root_setter(
    mut gc: *mut mln_gc_t,
    mut ctx: *mut mln_lang_ctx_t,
) {
    if ctx.is_null() {
        return;
    }
    let mut type_0: mln_s32_t = 0;
    let mut val: *mut mln_lang_val_t = 0 as *mut mln_lang_val_t;
    let mut hb: *mut mln_lang_hash_bucket_t = 0 as *mut mln_lang_hash_bucket_t;
    let mut end: *mut mln_lang_hash_bucket_t = 0 as *mut mln_lang_hash_bucket_t;
    let mut sym: *mut mln_lang_symbol_node_t = 0 as *mut mln_lang_symbol_node_t;
    hb = (*(*ctx).symbols).bucket;
    end = ((*(*ctx).symbols).bucket).offset((*(*ctx).symbols).len as isize);
    while hb < end {
        sym = (*hb).tail;
        while !sym.is_null() {
            if !((*sym).type_0 as libc::c_uint
                != M_LANG_SYMBOL_VAR as libc::c_int as libc::c_uint)
            {
                type_0 = (*(*(*sym).data.var).val).type_0;
                val = (*(*sym).data.var).val;
                if type_0 == 5 as libc::c_int {
                    mln_gc_collect_add(
                        gc,
                        (*(*val).data.obj).gc_item as *mut libc::c_void,
                    );
                } else if type_0 == 7 as libc::c_int {
                    mln_gc_collect_add(
                        gc,
                        (*(*val).data.array).gc_item as *mut libc::c_void,
                    );
                }
            }
            sym = (*sym).prev;
        }
        hb = hb.offset(1);
        hb;
    }
}
unsafe extern "C" fn mln_lang_gc_item_clean_searcher(
    mut gc: *mut mln_gc_t,
    mut gc_item: *mut mln_lang_gc_item_t,
) {
    let mut t: *mut mln_rbtree_t = 0 as *mut mln_rbtree_t;
    let mut gs: mln_lang_gc_scan_s = mln_lang_gc_scan_s {
        tree: 0 as *mut mln_rbtree_t,
        gc: 0 as *mut mln_gc_t,
    };
    match (*gc_item).type_0 as libc::c_uint {
        0 => {
            t = (*(*gc_item).data.obj).members;
            gs.tree = t;
            gs.gc = gc;
            mln_rbtree_iterate(
                t,
                Some(
                    mln_lang_gc_item_clean_searcher_obj_iterate_handler
                        as unsafe extern "C" fn(
                            *mut mln_rbtree_node_t,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                &mut gs as *mut mln_lang_gc_scan_s as *mut libc::c_void,
            );
        }
        _ => {
            t = (*(*gc_item).data.array).elems_index;
            gs.tree = t;
            gs.gc = gc;
            mln_rbtree_iterate(
                t,
                Some(
                    mln_lang_gc_item_clean_searcher_array_iterate_handler
                        as unsafe extern "C" fn(
                            *mut mln_rbtree_node_t,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                &mut gs as *mut mln_lang_gc_scan_s as *mut libc::c_void,
            );
        }
    };
}
unsafe extern "C" fn mln_lang_gc_item_clean_searcher_obj_iterate_handler(
    mut node: *mut mln_rbtree_node_t,
    mut udata: *mut libc::c_void,
) -> libc::c_int {
    let mut val: *mut mln_lang_val_t = 0 as *mut mln_lang_val_t;
    let mut var: *mut mln_lang_var_t = (*node).data as *mut mln_lang_var_t;
    let mut gs: *mut mln_lang_gc_scan_s = udata as *mut mln_lang_gc_scan_s;
    let mut type_0: mln_s32_t = (*(*var).val).type_0;
    val = (*var).val;
    if type_0 == 5 as libc::c_int {
        if mln_gc_clean_add((*gs).gc, (*(*val).data.obj).gc_item as *mut libc::c_void)
            < 0 as libc::c_int
        {
            if (*(*val).data.obj).ref_0 > 0 as libc::c_int as libc::c_ulong {
                (*(*val).data.obj).ref_0 = ((*(*val).data.obj).ref_0).wrapping_sub(1);
                (*(*val).data.obj).ref_0;
            }
            (*val).data.obj = 0 as *mut mln_lang_object_t;
            mln_rbtree_delete((*gs).tree, node);
            mln_rbtree_node_free((*gs).tree, node);
        }
    } else if type_0 == 7 as libc::c_int {
        if mln_gc_clean_add((*gs).gc, (*(*val).data.array).gc_item as *mut libc::c_void)
            < 0 as libc::c_int
        {
            if (*(*val).data.array).ref_0 > 0 as libc::c_int as libc::c_ulong {
                (*(*val).data.array)
                    .ref_0 = ((*(*val).data.array).ref_0).wrapping_sub(1);
                (*(*val).data.array).ref_0;
            }
            (*val).data.array = 0 as *mut mln_lang_array_t;
            mln_rbtree_delete((*gs).tree, node);
            mln_rbtree_node_free((*gs).tree, node);
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn mln_lang_gc_item_clean_searcher_array_iterate_handler(
    mut node: *mut mln_rbtree_node_t,
    mut udata: *mut libc::c_void,
) -> libc::c_int {
    let mut val: *mut mln_lang_val_t = 0 as *mut mln_lang_val_t;
    let mut elem: *mut mln_lang_array_elem_t = (*node).data
        as *mut mln_lang_array_elem_t;
    let mut gs: *mut mln_lang_gc_scan_s = udata as *mut mln_lang_gc_scan_s;
    let mut type_0: mln_s32_t = 0;
    let mut need_to_free: libc::c_int = 0 as libc::c_int;
    if !((*elem).key).is_null() {
        type_0 = (*(*(*elem).key).val).type_0;
        val = (*(*elem).key).val;
        if type_0 == 5 as libc::c_int {
            if mln_gc_clean_add(
                (*gs).gc,
                (*(*val).data.obj).gc_item as *mut libc::c_void,
            ) < 0 as libc::c_int
            {
                if (*(*val).data.obj).ref_0 > 0 as libc::c_int as libc::c_ulong {
                    (*(*val).data.obj)
                        .ref_0 = ((*(*val).data.obj).ref_0).wrapping_sub(1);
                    (*(*val).data.obj).ref_0;
                }
                (*val).data.obj = 0 as *mut mln_lang_object_t;
                need_to_free = 1 as libc::c_int;
            }
        } else if type_0 == 7 as libc::c_int {
            if mln_gc_clean_add(
                (*gs).gc,
                (*(*val).data.array).gc_item as *mut libc::c_void,
            ) < 0 as libc::c_int
            {
                if (*(*val).data.array).ref_0 > 0 as libc::c_int as libc::c_ulong {
                    (*(*val).data.array)
                        .ref_0 = ((*(*val).data.array).ref_0).wrapping_sub(1);
                    (*(*val).data.array).ref_0;
                }
                (*val).data.array = 0 as *mut mln_lang_array_t;
                need_to_free = 1 as libc::c_int;
            }
        }
    }
    if !((*elem).value).is_null() {
        type_0 = (*(*(*elem).value).val).type_0;
        val = (*(*elem).value).val;
        if type_0 == 5 as libc::c_int {
            if mln_gc_clean_add(
                (*gs).gc,
                (*(*val).data.obj).gc_item as *mut libc::c_void,
            ) < 0 as libc::c_int
            {
                if (*(*val).data.obj).ref_0 > 0 as libc::c_int as libc::c_ulong {
                    (*(*val).data.obj)
                        .ref_0 = ((*(*val).data.obj).ref_0).wrapping_sub(1);
                    (*(*val).data.obj).ref_0;
                }
                (*val).data.obj = 0 as *mut mln_lang_object_t;
                need_to_free = 1 as libc::c_int;
            }
        } else if type_0 == 7 as libc::c_int {
            if mln_gc_clean_add(
                (*gs).gc,
                (*(*val).data.array).gc_item as *mut libc::c_void,
            ) < 0 as libc::c_int
            {
                if (*(*val).data.array).ref_0 > 0 as libc::c_int as libc::c_ulong {
                    (*(*val).data.array)
                        .ref_0 = ((*(*val).data.array).ref_0).wrapping_sub(1);
                    (*(*val).data.array).ref_0;
                }
                (*val).data.array = 0 as *mut mln_lang_array_t;
                need_to_free = 1 as libc::c_int;
            }
        }
    }
    if need_to_free != 0 {
        mln_rbtree_delete((*gs).tree, node);
        mln_rbtree_node_free((*gs).tree, node);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn mln_lang_gc_item_free_handler(
    mut gc_item: *mut mln_lang_gc_item_t,
) {
    (*gc_item).gc = 0 as *mut mln_gc_t;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_ctx_resource_register(
    mut ctx: *mut mln_lang_ctx_t,
    mut name: *mut libc::c_char,
    mut data: *mut libc::c_void,
    mut free_handler: mln_lang_resource_free,
) -> libc::c_int {
    let mut rn: *mut mln_rbtree_node_t = 0 as *mut mln_rbtree_node_t;
    let mut tmp: mln_string_t = mln_string_t {
        data: 0 as *mut libc::c_uchar,
        len: 0,
        data_ref_pool_ref_0: [0; 4],
        c2rust_padding: [0; 4],
    };
    let mut lr: *mut mln_lang_resource_t = mln_alloc_m(
        (*ctx).pool,
        ::core::mem::size_of::<mln_lang_resource_t>() as libc::c_ulong,
    ) as *mut mln_lang_resource_t;
    if lr.is_null() {
        return -(1 as libc::c_int);
    }
    ({
        tmp.data = name as mln_u8ptr_t;
        tmp.len = strlen(name);
        tmp.set_data_ref(1 as libc::c_int as mln_uauto_t);
        tmp.set_pool(0 as libc::c_int as mln_uauto_t);
        tmp.set_ref_0(1 as libc::c_int as mln_uauto_t);
        &mut tmp;
        &mut tmp
    });
    (*lr).name = mln_string_pool_dup((*ctx).pool, &mut tmp);
    if ((*lr).name).is_null() {
        mln_alloc_free(lr as *mut libc::c_void);
        return -(1 as libc::c_int);
    }
    (*lr).data = data;
    (*lr).free_handler = free_handler;
    rn = mln_rbtree_node_new((*ctx).resource_set, lr as *mut libc::c_void);
    if rn.is_null() {
        mln_lang_ctx_resource_free_handler(lr);
        return -(1 as libc::c_int);
    }
    mln_rbtree_insert((*ctx).resource_set, rn);
    return 0 as libc::c_int;
}
unsafe extern "C" fn mln_lang_ctx_resource_free_handler(
    mut lr: *mut mln_lang_resource_t,
) {
    if lr.is_null() {
        return;
    }
    if ((*lr).free_handler).is_some() {
        ((*lr).free_handler).expect("non-null function pointer")((*lr).data);
    }
    let mut __s: *mut mln_string_t = (*lr).name;
    if !__s.is_null() {
        let ref mut fresh55 = (*__s).ref_0();
        let fresh56 = *fresh55;
        *fresh55 = (*fresh55).wrapping_sub(1);
        if fresh56 <= 1 as libc::c_int as libc::c_ulong {
            if (*__s).data_ref() == 0 && !((*__s).data).is_null() {
                if (*__s).pool() != 0 {
                    mln_alloc_free((*__s).data as *mut libc::c_void);
                } else {
                    free((*__s).data as *mut libc::c_void);
                }
            }
            if (*__s).pool() != 0 {
                mln_alloc_free(__s as *mut libc::c_void);
            } else {
                free(__s as *mut libc::c_void);
            }
        }
    }
    mln_alloc_free(lr as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_ctx_resource_fetch(
    mut ctx: *mut mln_lang_ctx_t,
    mut name: *mut libc::c_char,
) -> *mut libc::c_void {
    let mut rn: *mut mln_rbtree_node_t = 0 as *mut mln_rbtree_node_t;
    let mut lr: mln_lang_resource_t = mln_lang_resource_t {
        name: 0 as *mut mln_string_t,
        data: 0 as *mut libc::c_void,
        free_handler: None,
    };
    let mut s: mln_string_t = mln_string_t {
        data: 0 as *mut libc::c_uchar,
        len: 0,
        data_ref_pool_ref_0: [0; 4],
        c2rust_padding: [0; 4],
    };
    ({
        s.data = name as mln_u8ptr_t;
        s.len = strlen(name);
        s.set_data_ref(1 as libc::c_int as mln_uauto_t);
        s.set_pool(0 as libc::c_int as mln_uauto_t);
        s.set_ref_0(1 as libc::c_int as mln_uauto_t);
        &mut s;
        &mut s
    });
    lr.name = &mut s;
    rn = mln_rbtree_search(
        (*ctx).resource_set,
        &mut lr as *mut mln_lang_resource_t as *mut libc::c_void,
    );
    if rn == &mut (*(*ctx).resource_set).nil as *mut mln_rbtree_node_t {
        return 0 as *mut libc::c_void;
    }
    return (*((*rn).data as *mut mln_lang_resource_t)).data;
}
unsafe extern "C" fn mln_lang_resource_cmp(
    mut lr1: *const mln_lang_resource_t,
    mut lr2: *const mln_lang_resource_t,
) -> libc::c_int {
    return mln_string_strcmp((*lr1).name, (*lr2).name);
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_resource_register(
    mut lang: *mut mln_lang_t,
    mut name: *mut libc::c_char,
    mut data: *mut libc::c_void,
    mut free_handler: mln_lang_resource_free,
) -> libc::c_int {
    let mut rn: *mut mln_rbtree_node_t = 0 as *mut mln_rbtree_node_t;
    let mut tmp: mln_string_t = mln_string_t {
        data: 0 as *mut libc::c_uchar,
        len: 0,
        data_ref_pool_ref_0: [0; 4],
        c2rust_padding: [0; 4],
    };
    let mut lr: *mut mln_lang_resource_t = malloc(
        ::core::mem::size_of::<mln_lang_resource_t>() as libc::c_ulong,
    ) as *mut mln_lang_resource_t;
    if lr.is_null() {
        return -(1 as libc::c_int);
    }
    ({
        tmp.data = name as mln_u8ptr_t;
        tmp.len = strlen(name);
        tmp.set_data_ref(1 as libc::c_int as mln_uauto_t);
        tmp.set_pool(0 as libc::c_int as mln_uauto_t);
        tmp.set_ref_0(1 as libc::c_int as mln_uauto_t);
        &mut tmp;
        &mut tmp
    });
    (*lr).name = mln_string_dup(&mut tmp);
    if ((*lr).name).is_null() {
        free(lr as *mut libc::c_void);
        return -(1 as libc::c_int);
    }
    (*lr).data = data;
    (*lr).free_handler = free_handler;
    rn = mln_rbtree_node_new((*lang).resource_set, lr as *mut libc::c_void);
    if rn.is_null() {
        mln_lang_resource_free_handler(lr);
        return -(1 as libc::c_int);
    }
    mln_rbtree_insert((*lang).resource_set, rn);
    return 0 as libc::c_int;
}
unsafe extern "C" fn mln_lang_resource_free_handler(mut lr: *mut mln_lang_resource_t) {
    if lr.is_null() {
        return;
    }
    if ((*lr).free_handler).is_some() {
        ((*lr).free_handler).expect("non-null function pointer")((*lr).data);
    }
    let mut __s: *mut mln_string_t = (*lr).name;
    if !__s.is_null() {
        let ref mut fresh57 = (*__s).ref_0();
        let fresh58 = *fresh57;
        *fresh57 = (*fresh57).wrapping_sub(1);
        if fresh58 <= 1 as libc::c_int as libc::c_ulong {
            if (*__s).data_ref() == 0 && !((*__s).data).is_null() {
                if (*__s).pool() != 0 {
                    mln_alloc_free((*__s).data as *mut libc::c_void);
                } else {
                    free((*__s).data as *mut libc::c_void);
                }
            }
            if (*__s).pool() != 0 {
                mln_alloc_free(__s as *mut libc::c_void);
            } else {
                free(__s as *mut libc::c_void);
            }
        }
    }
    free(lr as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_resource_cancel(
    mut lang: *mut mln_lang_t,
    mut name: *mut libc::c_char,
) {
    let mut rn: *mut mln_rbtree_node_t = 0 as *mut mln_rbtree_node_t;
    let mut lr: mln_lang_resource_t = mln_lang_resource_t {
        name: 0 as *mut mln_string_t,
        data: 0 as *mut libc::c_void,
        free_handler: None,
    };
    let mut s: mln_string_t = mln_string_t {
        data: 0 as *mut libc::c_uchar,
        len: 0,
        data_ref_pool_ref_0: [0; 4],
        c2rust_padding: [0; 4],
    };
    ({
        s.data = name as mln_u8ptr_t;
        s.len = strlen(name);
        s.set_data_ref(1 as libc::c_int as mln_uauto_t);
        s.set_pool(0 as libc::c_int as mln_uauto_t);
        s.set_ref_0(1 as libc::c_int as mln_uauto_t);
        &mut s;
        &mut s
    });
    lr.name = &mut s;
    rn = mln_rbtree_search(
        (*lang).resource_set,
        &mut lr as *mut mln_lang_resource_t as *mut libc::c_void,
    );
    if rn == &mut (*(*lang).resource_set).nil as *mut mln_rbtree_node_t {
        return;
    }
    mln_rbtree_delete((*lang).resource_set, rn);
    mln_rbtree_node_free((*lang).resource_set, rn);
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_resource_fetch(
    mut lang: *mut mln_lang_t,
    mut name: *mut libc::c_char,
) -> *mut libc::c_void {
    let mut rn: *mut mln_rbtree_node_t = 0 as *mut mln_rbtree_node_t;
    let mut lr: mln_lang_resource_t = mln_lang_resource_t {
        name: 0 as *mut mln_string_t,
        data: 0 as *mut libc::c_void,
        free_handler: None,
    };
    let mut s: mln_string_t = mln_string_t {
        data: 0 as *mut libc::c_uchar,
        len: 0,
        data_ref_pool_ref_0: [0; 4],
        c2rust_padding: [0; 4],
    };
    ({
        s.data = name as mln_u8ptr_t;
        s.len = strlen(name);
        s.set_data_ref(1 as libc::c_int as mln_uauto_t);
        s.set_pool(0 as libc::c_int as mln_uauto_t);
        s.set_ref_0(1 as libc::c_int as mln_uauto_t);
        &mut s;
        &mut s
    });
    lr.name = &mut s;
    rn = mln_rbtree_search(
        (*lang).resource_set,
        &mut lr as *mut mln_lang_resource_t as *mut libc::c_void,
    );
    if rn == &mut (*(*lang).resource_set).nil as *mut mln_rbtree_node_t {
        return 0 as *mut libc::c_void;
    }
    return (*((*rn).data as *mut mln_lang_resource_t)).data;
}
#[inline]
unsafe extern "C" fn mln_lang_hash_new(
    mut ctx: *mut mln_lang_ctx_t,
) -> *mut mln_lang_hash_t {
    let mut h: *mut mln_lang_hash_t = mln_alloc_m(
        (*ctx).pool,
        ::core::mem::size_of::<mln_lang_hash_t>() as libc::c_ulong,
    ) as *mut mln_lang_hash_t;
    if h.is_null() {
        return 0 as *mut mln_lang_hash_t;
    }
    (*h)
        .bucket = mln_alloc_c(
        (*ctx).pool,
        (::core::mem::size_of::<mln_lang_hash_bucket_t>() as libc::c_ulong)
            .wrapping_mul(371 as libc::c_int as libc::c_ulong),
    ) as *mut mln_lang_hash_bucket_t;
    if ((*h).bucket).is_null() {
        mln_alloc_free(h as *mut libc::c_void);
        return 0 as *mut mln_lang_hash_t;
    }
    (*h).len = 371 as libc::c_int as mln_size_t;
    return h;
}
#[inline]
unsafe extern "C" fn mln_lang_hash_free(mut h: *mut mln_lang_hash_t) {
    let mut hb: *mut mln_lang_hash_bucket_t = 0 as *mut mln_lang_hash_bucket_t;
    let mut end: *mut mln_lang_hash_bucket_t = 0 as *mut mln_lang_hash_bucket_t;
    let mut sym: *mut mln_lang_symbol_node_t = 0 as *mut mln_lang_symbol_node_t;
    hb = (*h).bucket;
    end = ((*h).bucket).offset((*h).len as isize);
    while hb < end {
        loop {
            sym = (*hb).tail;
            if sym.is_null() {
                break;
            }
            mln_lang_sym_chain_del(&mut (*hb).head, &mut (*hb).tail, sym);
            (*sym).ctx = 0 as *mut mln_lang_ctx_t;
            mln_lang_symbol_node_free(sym as *mut libc::c_void);
        }
        hb = hb.offset(1);
        hb;
    }
    mln_alloc_free((*h).bucket as *mut libc::c_void);
    mln_alloc_free(h as *mut libc::c_void);
}
#[inline]
unsafe extern "C" fn mln_lang_hash_get_bucket(
    mut h: *mut mln_lang_hash_t,
    mut sym: *mut mln_lang_symbol_node_t,
) -> *mut mln_lang_hash_bucket_t {
    let mut idx: mln_u64_t = 0 as libc::c_int as mln_u64_t;
    let mut i: mln_u64_t = 0;
    let mut n: mln_u64_t = (*(*sym).symbol).len;
    let mut p: mln_u8ptr_t = (*(*sym).symbol).data;
    i = 0 as libc::c_int as mln_u64_t;
    while i < n {
        idx = (idx as libc::c_ulong).wrapping_add(*p.offset(i as isize) as libc::c_ulong)
            as mln_u64_t as mln_u64_t;
        i = i.wrapping_add(1);
        i;
    }
    return &mut *((*h).bucket)
        .offset(idx.wrapping_mul((*sym).layer).wrapping_rem((*h).len) as isize)
        as *mut mln_lang_hash_bucket_t;
}
unsafe extern "C" fn mln_lang_ctx_pipe_new(
    mut ctx: *mut mln_lang_ctx_t,
) -> *mut mln_lang_ctx_pipe_t {
    let mut p: *mut mln_lang_ctx_pipe_t = 0 as *mut mln_lang_ctx_pipe_t;
    p = mln_alloc_m(
        (*ctx).pool,
        ::core::mem::size_of::<mln_lang_ctx_pipe_t>() as libc::c_ulong,
    ) as *mut mln_lang_ctx_pipe_t;
    if p.is_null() {
        return 0 as *mut mln_lang_ctx_pipe_t;
    }
    if pthread_mutex_init(&mut (*p).lock, 0 as *const pthread_mutexattr_t) != 0 {
        mln_alloc_free(p as *mut libc::c_void);
        return 0 as *mut mln_lang_ctx_pipe_t;
    }
    (*p).ctx = ctx;
    if mln_array_pool_init(
        &mut (*p).list,
        ::core::mem::transmute::<
            Option::<unsafe extern "C" fn(*mut mln_array_t) -> ()>,
            array_free,
        >(Some(mln_array_destroy as unsafe extern "C" fn(*mut mln_array_t) -> ())),
        ::core::mem::size_of::<mln_array_t>() as libc::c_ulong,
        1024 as libc::c_int as mln_size_t,
        (*ctx).pool as *mut libc::c_void,
        ::core::mem::transmute::<
            Option::<
                unsafe extern "C" fn(*mut mln_alloc_t, mln_size_t) -> *mut libc::c_void,
            >,
            array_pool_alloc_handler,
        >(
            Some(
                mln_alloc_m
                    as unsafe extern "C" fn(
                        *mut mln_alloc_t,
                        mln_size_t,
                    ) -> *mut libc::c_void,
            ),
        ),
        ::core::mem::transmute::<
            Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
            array_pool_free_handler,
        >(Some(mln_alloc_free as unsafe extern "C" fn(*mut libc::c_void) -> ())),
    ) < 0 as libc::c_int
    {
        pthread_mutex_destroy(&mut (*p).lock);
        mln_alloc_free(p as *mut libc::c_void);
        return 0 as *mut mln_lang_ctx_pipe_t;
    }
    (*p).recv_handler = None;
    (*p).set_subscribed(0 as libc::c_int as mln_u32_t);
    return p;
}
unsafe extern "C" fn mln_lang_ctx_pipe_free(mut p: *mut mln_lang_ctx_pipe_t) {
    if p.is_null() {
        return;
    }
    pthread_mutex_lock(&mut (*p).lock);
    mln_array_destroy(&mut (*p).list);
    pthread_mutex_unlock(&mut (*p).lock);
    pthread_mutex_destroy(&mut (*p).lock);
    mln_alloc_free(p as *mut libc::c_void);
}
#[inline]
unsafe extern "C" fn mln_lang_ctx_pipe_elem_init(
    mut pe: *mut mln_lang_ctx_pipe_elem_t,
    mut type_0: libc::c_int,
    mut value: *mut libc::c_void,
) -> libc::c_int {
    (*pe).type_0 = type_0;
    match type_0 {
        1 => {
            (*pe).data.i = *(value as *mut mln_s64_t);
        }
        3 => {
            (*pe).data.r = *(value as *mut libc::c_double);
        }
        4 => {
            (*pe).data.s = mln_string_dup(value as *mut mln_string_t);
            if ((*pe).data.s).is_null() {
                return -(1 as libc::c_int);
            }
        }
        _ => return -(1 as libc::c_int),
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn mln_lang_ctx_pipe_elem_destroy(
    mut pe: *mut mln_lang_ctx_pipe_elem_t,
) {
    if !pe.is_null() && (*pe).type_0 == 4 as libc::c_int && !((*pe).data.s).is_null() {
        let mut __s: *mut mln_string_t = (*pe).data.s;
        if !__s.is_null() {
            let ref mut fresh59 = (*__s).ref_0();
            let fresh60 = *fresh59;
            *fresh59 = (*fresh59).wrapping_sub(1);
            if fresh60 <= 1 as libc::c_int as libc::c_ulong {
                if (*__s).data_ref() == 0 && !((*__s).data).is_null() {
                    if (*__s).pool() != 0 {
                        mln_alloc_free((*__s).data as *mut libc::c_void);
                    } else {
                        free((*__s).data as *mut libc::c_void);
                    }
                }
                if (*__s).pool() != 0 {
                    mln_alloc_free(__s as *mut libc::c_void);
                } else {
                    free(__s as *mut libc::c_void);
                }
            }
        }
    }
}
unsafe extern "C" fn mln_lang_func_pipe(mut ctx: *mut mln_lang_ctx_t) -> libc::c_int {
    let mut val: *mut mln_lang_val_t = 0 as *mut mln_lang_val_t;
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut func: *mut mln_lang_func_detail_t = 0 as *mut mln_lang_func_detail_t;
    let mut funcname: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"Pipe\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    let mut v1: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"op\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    let mut v2: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"data\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    func = mln_lang_func_detail_new(
        ctx,
        M_FUNC_INTERNAL,
        ::core::mem::transmute::<
            Option::<unsafe extern "C" fn(*mut mln_lang_ctx_t) -> *mut mln_lang_var_t>,
            *mut libc::c_void,
        >(
            Some(
                mln_lang_func_pipe_process
                    as unsafe extern "C" fn(*mut mln_lang_ctx_t) -> *mut mln_lang_var_t,
            ),
        ),
        0 as *mut mln_lang_exp_t,
        0 as *mut mln_lang_exp_t,
    );
    if func.is_null() {
        mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    val = mln_lang_val_new(ctx, 0 as libc::c_int, 0 as *mut libc::c_void);
    if val.is_null() {
        mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        mln_lang_func_detail_free(func);
        return -(1 as libc::c_int);
    }
    var = mln_lang_var_new(
        ctx,
        &mut v1,
        M_LANG_VAR_NORMAL,
        val,
        0 as *mut mln_lang_set_detail_t,
    );
    if var.is_null() {
        mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        mln_lang_val_free(val);
        mln_lang_func_detail_free(func);
        return -(1 as libc::c_int);
    }
    mln_lang_func_detail_arg_append(func, var);
    val = mln_lang_val_new(ctx, 0 as libc::c_int, 0 as *mut libc::c_void);
    if val.is_null() {
        mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        mln_lang_func_detail_free(func);
        return -(1 as libc::c_int);
    }
    var = mln_lang_var_new(
        ctx,
        &mut v2,
        M_LANG_VAR_REFER,
        val,
        0 as *mut mln_lang_set_detail_t,
    );
    if var.is_null() {
        mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        mln_lang_val_free(val);
        mln_lang_func_detail_free(func);
        return -(1 as libc::c_int);
    }
    mln_lang_func_detail_arg_append(func, var);
    val = mln_lang_val_new(ctx, 6 as libc::c_int, func as *mut libc::c_void);
    if val.is_null() {
        mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        mln_lang_func_detail_free(func);
        return -(1 as libc::c_int);
    }
    var = mln_lang_var_new(
        ctx,
        &mut funcname,
        M_LANG_VAR_NORMAL,
        val,
        0 as *mut mln_lang_set_detail_t,
    );
    if var.is_null() {
        mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        mln_lang_val_free(val);
        return -(1 as libc::c_int);
    }
    if mln_lang_symbol_node_join(ctx, M_LANG_SYMBOL_VAR, var as *mut libc::c_void)
        < 0 as libc::c_int
    {
        mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        mln_lang_var_free(var as *mut libc::c_void);
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn mln_lang_func_pipe_process(
    mut ctx: *mut mln_lang_ctx_t,
) -> *mut mln_lang_var_t {
    let mut ret_var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut v1: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"op\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 3]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    let mut v2: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"data\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    let mut op_sub: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"subscribe\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 10]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    let mut op_unsub: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"unsubscribe\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 12]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    let mut op_recv: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"recv\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    let mut op_send: mln_string_t = {
        let mut init = mln_string_t {
            data_ref_pool_ref_0: [0; 4],
            c2rust_padding: [0; 4],
            data: b"send\0" as *const u8 as *const libc::c_char as mln_u8ptr_t,
            len: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        };
        init.set_data_ref(1 as libc::c_int as mln_uauto_t);
        init.set_pool(0 as libc::c_int as mln_uauto_t);
        init.set_ref_0(1 as libc::c_int as mln_uauto_t);
        init
    };
    let mut sym: *mut mln_lang_symbol_node_t = 0 as *mut mln_lang_symbol_node_t;
    let mut p: *mut mln_lang_ctx_pipe_t = 0 as *mut mln_lang_ctx_pipe_t;
    let mut cb: mln_lang_ctx_pipe_recv_cb_t = None;
    let mut op: *mut mln_string_t = 0 as *mut mln_string_t;
    let mut rc: libc::c_int = 0 as libc::c_int;
    sym = mln_lang_symbol_node_search(ctx, &mut v1, 1 as libc::c_int);
    if sym.is_null() {
        mln_lang_errmsg(
            ctx,
            b"Argument 1 missing.\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        return 0 as *mut mln_lang_var_t;
    }
    if (*sym).type_0 as libc::c_uint != M_LANG_SYMBOL_VAR as libc::c_int as libc::c_uint
        || (*(*(*sym).data.var).val).type_0 != 4 as libc::c_int
    {
        mln_lang_errmsg(
            ctx,
            b"Invalid type of argument 1.\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        return 0 as *mut mln_lang_var_t;
    }
    op = (*(*(*sym).data.var).val).data.s;
    sym = mln_lang_symbol_node_search(ctx, &mut v2, 1 as libc::c_int);
    if sym.is_null() {
        mln_lang_errmsg(
            ctx,
            b"Argument 2 missing.\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        return 0 as *mut mln_lang_var_t;
    }
    if (*sym).type_0 as libc::c_uint != M_LANG_SYMBOL_VAR as libc::c_int as libc::c_uint
    {
        mln_lang_errmsg(
            ctx,
            b"Invalid type of argument 2.\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        return 0 as *mut mln_lang_var_t;
    }
    var = (*sym).data.var;
    if mln_string_strcmp(op, &mut op_sub) == 0 {
        p = mln_lang_ctx_resource_fetch(
            ctx,
            b"pipe\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        ) as *mut mln_lang_ctx_pipe_t;
        if p.is_null() {
            p = mln_lang_ctx_pipe_new(ctx);
            if p.is_null() {
                mln_lang_errmsg(
                    ctx,
                    b"No memory.\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                );
                return 0 as *mut mln_lang_var_t;
            }
            if mln_lang_ctx_resource_register(
                ctx,
                b"pipe\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                p as *mut libc::c_void,
                ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(*mut mln_lang_ctx_pipe_t) -> ()>,
                    mln_lang_resource_free,
                >(
                    Some(
                        mln_lang_ctx_pipe_free
                            as unsafe extern "C" fn(*mut mln_lang_ctx_pipe_t) -> (),
                    ),
                ),
            ) < 0 as libc::c_int
            {
                mln_lang_ctx_pipe_free(p);
                mln_lang_errmsg(
                    ctx,
                    b"No memory.\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                );
                return 0 as *mut mln_lang_var_t;
            }
        }
        pthread_mutex_lock(&mut (*p).lock);
        (*p).set_subscribed(1 as libc::c_int as mln_u32_t);
        pthread_mutex_unlock(&mut (*p).lock);
        ret_var = mln_lang_var_create_nil(ctx, 0 as *mut mln_string_t);
    } else if mln_string_strcmp(op, &mut op_unsub) == 0 {
        p = mln_lang_ctx_resource_fetch(
            ctx,
            b"pipe\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        ) as *mut mln_lang_ctx_pipe_t;
        if !p.is_null() {
            pthread_mutex_lock(&mut (*p).lock);
            (*p).set_subscribed(0 as libc::c_int as mln_u32_t);
            pthread_mutex_unlock(&mut (*p).lock);
        }
        ret_var = mln_lang_var_create_nil(ctx, 0 as *mut mln_string_t);
    } else if mln_string_strcmp(op, &mut op_recv) == 0 {
        p = mln_lang_ctx_resource_fetch(
            ctx,
            b"pipe\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        ) as *mut mln_lang_ctx_pipe_t;
        if !p.is_null() {
            pthread_mutex_lock(&mut (*p).lock);
            ret_var = mln_lang_func_pipe_process_array_generate(ctx, p);
            pthread_mutex_unlock(&mut (*p).lock);
        } else {
            ret_var = mln_lang_var_create_false(ctx, 0 as *mut mln_string_t);
        }
    } else if mln_string_strcmp(op, &mut op_send) == 0 {
        p = mln_lang_ctx_resource_fetch(
            ctx,
            b"pipe\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        ) as *mut mln_lang_ctx_pipe_t;
        if !p.is_null() {
            pthread_mutex_lock(&mut (*p).lock);
            cb = (*p).recv_handler;
            pthread_mutex_unlock(&mut (*p).lock);
            if cb.is_some() {
                rc = cb.expect("non-null function pointer")(ctx, (*var).val);
            }
            ret_var = if rc == 0 {
                mln_lang_var_create_true(ctx, 0 as *mut mln_string_t)
            } else {
                mln_lang_var_create_false(ctx, 0 as *mut mln_string_t)
            };
        } else {
            ret_var = mln_lang_var_create_false(ctx, 0 as *mut mln_string_t);
        }
    } else {
        mln_lang_errmsg(
            ctx,
            b"Invalid argument 2.\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        return 0 as *mut mln_lang_var_t;
    }
    if ret_var.is_null() {
        mln_lang_errmsg(
            ctx,
            b"No memory.\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
    }
    return ret_var;
}
#[inline]
unsafe extern "C" fn mln_lang_func_pipe_process_array_generate(
    mut ctx: *mut mln_lang_ctx_t,
    mut pipe: *mut mln_lang_ctx_pipe_t,
) -> *mut mln_lang_var_t {
    let mut ret_var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut var: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut v: *mut mln_lang_var_t = 0 as *mut mln_lang_var_t;
    let mut arr: *mut mln_lang_array_t = 0 as *mut mln_lang_array_t;
    let mut a: *mut mln_lang_array_t = 0 as *mut mln_lang_array_t;
    let mut pa: *mut mln_array_t = 0 as *mut mln_array_t;
    let mut paend: *mut mln_array_t = 0 as *mut mln_array_t;
    let mut pe: *mut mln_lang_ctx_pipe_elem_t = 0 as *mut mln_lang_ctx_pipe_elem_t;
    let mut peend: *mut mln_lang_ctx_pipe_elem_t = 0 as *mut mln_lang_ctx_pipe_elem_t;
    ret_var = mln_lang_var_create_array(ctx, 0 as *mut mln_string_t);
    if ret_var.is_null() {
        return 0 as *mut mln_lang_var_t;
    }
    arr = (*(*ret_var).val).data.array;
    paend = (*pipe).list.elts as *mut mln_array_t;
    pa = paend;
    paend = paend.offset((*pipe).list.nelts as isize);
    while pa < paend {
        var = mln_lang_var_create_array(ctx, 0 as *mut mln_string_t);
        if var.is_null() {
            mln_lang_var_free(ret_var as *mut libc::c_void);
            return 0 as *mut mln_lang_var_t;
        }
        v = mln_lang_array_get(ctx, arr, 0 as *mut mln_lang_var_t);
        if v.is_null() {
            mln_lang_var_free(ret_var as *mut libc::c_void);
            mln_lang_var_free(var as *mut libc::c_void);
            return 0 as *mut mln_lang_var_t;
        }
        mln_lang_var_assign(v, (*var).val);
        mln_lang_var_free(var as *mut libc::c_void);
        a = (*(*v).val).data.array;
        peend = (*pa).elts as *mut mln_lang_ctx_pipe_elem_t;
        pe = peend;
        peend = peend.offset((*pa).nelts as isize);
        while pe < peend {
            v = mln_lang_array_get(ctx, a, 0 as *mut mln_lang_var_t);
            if v.is_null() {
                mln_lang_var_free(ret_var as *mut libc::c_void);
                return 0 as *mut mln_lang_var_t;
            }
            match (*pe).type_0 {
                1 => {
                    mln_lang_var_set_int(v, (*pe).data.i);
                }
                3 => {
                    mln_lang_var_set_real(v, (*pe).data.r);
                }
                4 => {
                    let mut s: *mut mln_string_t = mln_string_pool_dup(
                        (*ctx).pool,
                        (*pe).data.s,
                    );
                    if s.is_null() {
                        mln_lang_var_free(ret_var as *mut libc::c_void);
                        return 0 as *mut mln_lang_var_t;
                    }
                    mln_lang_var_set_string(v, s);
                }
                _ => {
                    mln_lang_var_free(ret_var as *mut libc::c_void);
                    return 0 as *mut mln_lang_var_t;
                }
            }
            pe = pe.offset(1);
            pe;
        }
        pa = pa.offset(1);
        pa;
    }
    mln_array_reset(&mut (*pipe).list);
    return ret_var;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_ctx_pipe_send(
    mut ctx: *mut mln_lang_ctx_t,
    mut fmt: *mut libc::c_char,
    mut args: ...
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    let mut arg: ::core::ffi::VaListImpl;
    arg = args.clone();
    rc = mln_lang_ctx_pipe_do_send(ctx, fmt, arg.as_va_list());
    return rc;
}
#[inline]
unsafe extern "C" fn mln_lang_ctx_pipe_do_send(
    mut ctx: *mut mln_lang_ctx_t,
    mut fmt: *mut libc::c_char,
    mut arg: ::core::ffi::VaList,
) -> libc::c_int {
    let mut p: *mut mln_lang_ctx_pipe_t = 0 as *mut mln_lang_ctx_pipe_t;
    let mut pe: *mut mln_lang_ctx_pipe_elem_t = 0 as *mut mln_lang_ctx_pipe_elem_t;
    let mut a: *mut mln_array_t = 0 as *mut mln_array_t;
    p = mln_lang_ctx_resource_fetch(
        ctx,
        b"pipe\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    ) as *mut mln_lang_ctx_pipe_t;
    if p.is_null() {
        return 0 as libc::c_int;
    }
    if (*p).ctx != ctx {
        return -(1 as libc::c_int);
    }
    pthread_mutex_lock(&mut (*p).lock);
    if (*p).subscribed() == 0 {
        pthread_mutex_unlock(&mut (*p).lock);
        return -(1 as libc::c_int);
    }
    a = mln_array_push(&mut (*p).list) as *mut mln_array_t;
    if a.is_null() {
        pthread_mutex_unlock(&mut (*p).lock);
        return -(1 as libc::c_int);
    }
    if mln_array_pool_init(
        a,
        ::core::mem::transmute::<
            Option::<unsafe extern "C" fn(*mut mln_lang_ctx_pipe_elem_t) -> ()>,
            array_free,
        >(
            Some(
                mln_lang_ctx_pipe_elem_destroy
                    as unsafe extern "C" fn(*mut mln_lang_ctx_pipe_elem_t) -> (),
            ),
        ),
        ::core::mem::size_of::<mln_lang_ctx_pipe_elem_t>() as libc::c_ulong,
        6 as libc::c_int as mln_size_t,
        (*ctx).pool as *mut libc::c_void,
        ::core::mem::transmute::<
            Option::<
                unsafe extern "C" fn(*mut mln_alloc_t, mln_size_t) -> *mut libc::c_void,
            >,
            array_pool_alloc_handler,
        >(
            Some(
                mln_alloc_m
                    as unsafe extern "C" fn(
                        *mut mln_alloc_t,
                        mln_size_t,
                    ) -> *mut libc::c_void,
            ),
        ),
        ::core::mem::transmute::<
            Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
            array_pool_free_handler,
        >(Some(mln_alloc_free as unsafe extern "C" fn(*mut libc::c_void) -> ())),
    ) < 0 as libc::c_int
    {
        mln_array_pop(&mut (*p).list);
        pthread_mutex_unlock(&mut (*p).lock);
        return -(1 as libc::c_int);
    }
    while *fmt != 0 {
        pe = mln_array_push(a) as *mut mln_lang_ctx_pipe_elem_t;
        if pe.is_null() {
            mln_array_pop(&mut (*p).list);
            pthread_mutex_unlock(&mut (*p).lock);
            return -(1 as libc::c_int);
        }
        (*pe).data.s = 0 as *mut mln_string_t;
        match *fmt as libc::c_int {
            105 => {
                let mut tmp: mln_s64_t = arg.arg::<mln_s64_t>();
                mln_lang_ctx_pipe_elem_init(
                    pe,
                    1 as libc::c_int,
                    &mut tmp as *mut mln_s64_t as *mut libc::c_void,
                );
            }
            115 => {
                let mut str: *mut libc::c_char = arg.arg::<*mut libc::c_char>();
                let mut tmp_0: mln_string_t = mln_string_t {
                    data: 0 as *mut libc::c_uchar,
                    len: 0,
                    data_ref_pool_ref_0: [0; 4],
                    c2rust_padding: [0; 4],
                };
                ({
                    tmp_0.data = str as mln_u8ptr_t;
                    tmp_0.len = strlen(str);
                    tmp_0.set_data_ref(1 as libc::c_int as mln_uauto_t);
                    tmp_0.set_pool(0 as libc::c_int as mln_uauto_t);
                    tmp_0.set_ref_0(1 as libc::c_int as mln_uauto_t);
                    &mut tmp_0;
                    &mut tmp_0
                });
                if mln_lang_ctx_pipe_elem_init(
                    pe,
                    4 as libc::c_int,
                    &mut tmp_0 as *mut mln_string_t as *mut libc::c_void,
                ) < 0 as libc::c_int
                {
                    mln_array_pop(&mut (*p).list);
                    pthread_mutex_unlock(&mut (*p).lock);
                    return -(1 as libc::c_int);
                }
            }
            83 => {
                let mut tmp_1: *mut mln_string_t = arg.arg::<*mut mln_string_t>();
                if mln_lang_ctx_pipe_elem_init(
                    pe,
                    4 as libc::c_int,
                    tmp_1 as *mut libc::c_void,
                ) < 0 as libc::c_int
                {
                    mln_array_pop(&mut (*p).list);
                    pthread_mutex_unlock(&mut (*p).lock);
                    return -(1 as libc::c_int);
                }
            }
            114 => {
                let mut tmp_2: libc::c_double = arg.arg::<libc::c_double>();
                mln_lang_ctx_pipe_elem_init(
                    pe,
                    3 as libc::c_int,
                    &mut tmp_2 as *mut libc::c_double as *mut libc::c_void,
                );
            }
            _ => {
                mln_array_pop(&mut (*p).list);
                pthread_mutex_unlock(&mut (*p).lock);
                return -(1 as libc::c_int);
            }
        }
        fmt = fmt.offset(1);
        fmt;
    }
    pthread_mutex_unlock(&mut (*p).lock);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn mln_lang_ctx_pipe_recv_handler_set(
    mut ctx: *mut mln_lang_ctx_t,
    mut recv_handler: mln_lang_ctx_pipe_recv_cb_t,
) -> libc::c_int {
    let mut p: *mut mln_lang_ctx_pipe_t = 0 as *mut mln_lang_ctx_pipe_t;
    p = mln_lang_ctx_resource_fetch(
        ctx,
        b"pipe\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    ) as *mut mln_lang_ctx_pipe_t;
    if p.is_null() {
        p = mln_lang_ctx_pipe_new(ctx);
        if p.is_null() {
            return -(1 as libc::c_int);
        }
        if mln_lang_ctx_resource_register(
            ctx,
            b"pipe\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            p as *mut libc::c_void,
            ::core::mem::transmute::<
                Option::<unsafe extern "C" fn(*mut mln_lang_ctx_pipe_t) -> ()>,
                mln_lang_resource_free,
            >(
                Some(
                    mln_lang_ctx_pipe_free
                        as unsafe extern "C" fn(*mut mln_lang_ctx_pipe_t) -> (),
                ),
            ),
        ) < 0 as libc::c_int
        {
            mln_lang_ctx_pipe_free(p);
            return -(1 as libc::c_int);
        }
    }
    if (*p).ctx != ctx {
        return -(1 as libc::c_int);
    }
    pthread_mutex_lock(&mut (*p).lock);
    (*p).recv_handler = recv_handler;
    pthread_mutex_unlock(&mut (*p).lock);
    return 0 as libc::c_int;
}
